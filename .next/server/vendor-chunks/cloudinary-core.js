"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cloudinary-core";
exports.ids = ["vendor-chunks/cloudinary-core"];
exports.modules = {

/***/ "(action-browser)/./node_modules/cloudinary-core/cloudinary-core.js":
/*!*********************************************************!*\
  !*** ./node_modules/cloudinary-core/cloudinary-core.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n   * cloudinary-core.js\n   * Cloudinary's JavaScript library - Version 2.13.0\n   * Copyright Cloudinary\n   * see https://github.com/cloudinary/cloudinary_js\n   *\n   */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! lodash/assign */ \"lodash/assign\"), __webpack_require__(/*! lodash/cloneDeep */ \"lodash/cloneDeep\"), __webpack_require__(/*! lodash/compact */ \"lodash/compact\"), __webpack_require__(/*! lodash/difference */ \"lodash/difference\"), __webpack_require__(/*! lodash/functions */ \"lodash/functions\"), __webpack_require__(/*! lodash/identity */ \"lodash/identity\"), __webpack_require__(/*! lodash/includes */ \"lodash/includes\"), __webpack_require__(/*! lodash/isArray */ \"lodash/isArray\"), __webpack_require__(/*! lodash/isElement */ \"lodash/isElement\"), __webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"), __webpack_require__(/*! lodash/isPlainObject */ \"lodash/isPlainObject\"), __webpack_require__(/*! lodash/isString */ \"lodash/isString\"), __webpack_require__(/*! lodash/merge */ \"lodash/merge\"), __webpack_require__(/*! lodash/trim */ \"lodash/trim\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_lodash_assign__, __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__, __WEBPACK_EXTERNAL_MODULE_lodash_compact__, __WEBPACK_EXTERNAL_MODULE_lodash_difference__, __WEBPACK_EXTERNAL_MODULE_lodash_functions__, __WEBPACK_EXTERNAL_MODULE_lodash_identity__, __WEBPACK_EXTERNAL_MODULE_lodash_includes__, __WEBPACK_EXTERNAL_MODULE_lodash_isArray__, __WEBPACK_EXTERNAL_MODULE_lodash_isElement__, __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__, __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__, __WEBPACK_EXTERNAL_MODULE_lodash_isString__, __WEBPACK_EXTERNAL_MODULE_lodash_merge__, __WEBPACK_EXTERNAL_MODULE_lodash_trim__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_2864__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_2864__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_2864__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_2864__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_2864__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_2864__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_2864__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_2864__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_2864__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_2864__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_2864__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_2864__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_2864__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_2864__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_2864__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_2864__(__nested_webpack_require_2864__.s = \"./src/namespace/cloudinary-core.js\");\n    /******/ }({\n        /***/ \"./src/namespace/cloudinary-core.js\": /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_7160__) {\n            \"use strict\";\n            // ESM COMPAT FLAG\n            __nested_webpack_require_7160__.r(__nested_webpack_exports__);\n            // EXPORTS\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ClientHintsMetaTag\", function() {\n                return /* reexport */ clienthintsmetatag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Cloudinary\", function() {\n                return /* reexport */ cloudinary;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Condition\", function() {\n                return /* reexport */ condition;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Configuration\", function() {\n                return /* reexport */ src_configuration;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"crc32\", function() {\n                return /* reexport */ src_crc32;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Expression\", function() {\n                return /* reexport */ expression;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"FetchLayer\", function() {\n                return /* reexport */ fetchlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"HtmlTag\", function() {\n                return /* reexport */ htmltag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ImageTag\", function() {\n                return /* reexport */ imagetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Layer\", function() {\n                return /* reexport */ layer_layer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"PictureTag\", function() {\n                return /* reexport */ picturetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"SubtitlesLayer\", function() {\n                return /* reexport */ subtitleslayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"TextLayer\", function() {\n                return /* reexport */ textlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Transformation\", function() {\n                return /* reexport */ src_transformation;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"utf8_encode\", function() {\n                return /* reexport */ src_utf8_encode;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Util\", function() {\n                return /* reexport */ lodash_namespaceObject;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"VideoTag\", function() {\n                return /* reexport */ videotag;\n            });\n            // NAMESPACE OBJECT: ./src/constants.js\n            var constants_namespaceObject = {};\n            __nested_webpack_require_7160__.r(constants_namespaceObject);\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"VERSION\", function() {\n                return VERSION;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"CF_SHARED_CDN\", function() {\n                return CF_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"OLD_AKAMAI_SHARED_CDN\", function() {\n                return OLD_AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"AKAMAI_SHARED_CDN\", function() {\n                return AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SHARED_CDN\", function() {\n                return SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_TIMEOUT_MS\", function() {\n                return DEFAULT_TIMEOUT_MS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_POSTER_OPTIONS\", function() {\n                return DEFAULT_POSTER_OPTIONS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCE_TYPES\", function() {\n                return DEFAULT_VIDEO_SOURCE_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SEO_TYPES\", function() {\n                return SEO_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_IMAGE_PARAMS\", function() {\n                return DEFAULT_IMAGE_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_PARAMS\", function() {\n                return DEFAULT_VIDEO_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCES\", function() {\n                return DEFAULT_VIDEO_SOURCES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_EXTERNAL_LIBRARIES\", function() {\n                return DEFAULT_EXTERNAL_LIBRARIES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"PLACEHOLDER_IMAGE_MODES\", function() {\n                return PLACEHOLDER_IMAGE_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"ACCESSIBILITY_MODES\", function() {\n                return ACCESSIBILITY_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"URL_KEYS\", function() {\n                return URL_KEYS;\n            });\n            // NAMESPACE OBJECT: ./src/util/lodash.js\n            var lodash_namespaceObject = {};\n            __nested_webpack_require_7160__.r(lodash_namespaceObject);\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getSDKAnalyticsSignature\", function() {\n                return getSDKAnalyticsSignature;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAnalyticsOptions\", function() {\n                return getAnalyticsOptions;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"assign\", function() {\n                return assign_root_assign_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cloneDeep\", function() {\n                return cloneDeep_root_cloneDeep_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"compact\", function() {\n                return compact_root_compact_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"difference\", function() {\n                return difference_root_difference_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"functions\", function() {\n                return functions_root_functions_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"identity\", function() {\n                return identity_root_identity_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"includes\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isArray\", function() {\n                return isArray_root_isArray_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isPlainObject\", function() {\n                return isPlainObject_root_isPlainObject_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isString\", function() {\n                return isString_root_isString_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"merge\", function() {\n                return merge_root_merge_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"contains\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isIntersectionObserverSupported\", function() {\n                return isIntersectionObserverSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNativeLazyLoadSupported\", function() {\n                return isNativeLazyLoadSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"detectIntersection\", function() {\n                return detectIntersection;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"omit\", function() {\n                return omit;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"allStrings\", function() {\n                return baseutil_allStrings;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"without\", function() {\n                return without;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNumberLike\", function() {\n                return isNumberLike;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"smartEscape\", function() {\n                return smartEscape;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"defaults\", function() {\n                return defaults;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objectProto\", function() {\n                return objectProto;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objToString\", function() {\n                return objToString;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isObject\", function() {\n                return isObject;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"funcTag\", function() {\n                return funcTag;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"reWords\", function() {\n                return reWords;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"camelCase\", function() {\n                return camelCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"snakeCase\", function() {\n                return snakeCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"convertKeys\", function() {\n                return convertKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withCamelCaseKeys\", function() {\n                return withCamelCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withSnakeCaseKeys\", function() {\n                return withSnakeCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64Encode\", function() {\n                return base64Encode;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64EncodeURL\", function() {\n                return base64EncodeURL;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"extractUrlParams\", function() {\n                return extractUrlParams;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"patchFetchFormat\", function() {\n                return patchFetchFormat;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"optionConsume\", function() {\n                return optionConsume;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEmpty\", function() {\n                return isEmpty;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isAndroid\", function() {\n                return isAndroid;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEdge\", function() {\n                return isEdge;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isChrome\", function() {\n                return isChrome;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isSafari\", function() {\n                return isSafari;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isElement\", function() {\n                return isElement_root_isElement_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isFunction\", function() {\n                return isFunction_root_isFunction_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"trim\", function() {\n                return trim_root_trim_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getData\", function() {\n                return lodash_getData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setData\", function() {\n                return lodash_setData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAttribute\", function() {\n                return lodash_getAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttribute\", function() {\n                return lodash_setAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"removeAttribute\", function() {\n                return lodash_removeAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttributes\", function() {\n                return setAttributes;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"hasClass\", function() {\n                return lodash_hasClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"addClass\", function() {\n                return lodash_addClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getStyles\", function() {\n                return getStyles;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssExpand\", function() {\n                return cssExpand;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"domStyle\", function() {\n                return domStyle;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"curCSS\", function() {\n                return curCSS;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssValue\", function() {\n                return cssValue;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"augmentWidthOrHeight\", function() {\n                return augmentWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getWidthOrHeight\", function() {\n                return getWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"width\", function() {\n                return lodash_width;\n            });\n            // CONCATENATED MODULE: ./src/utf8_encode.js\n            /**\n * UTF8 encoder\n * @private\n */ var utf8_encode;\n            /* harmony default export */ var src_utf8_encode = utf8_encode = function utf8_encode(argString) {\n                var c1, enc, end, n, start, string, stringl, utftext; // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n                // +   improved by: sowberry\n                // +    tweaked by: Jack\n                // +   bugfixed by: Onno Marsman\n                // +   improved by: Yves Sucaet\n                // +   bugfixed by: Onno Marsman\n                // +   bugfixed by: Ulrich\n                // +   bugfixed by: Rafal Kukawski\n                // +   improved by: kirilloid\n                // *     example 1: utf8_encode('Kevin van Zonneveld');\n                // *     returns 1: 'Kevin van Zonneveld'\n                if (argString === null || typeof argString === \"undefined\") {\n                    return \"\";\n                }\n                string = argString + \"\"; // .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                utftext = \"\";\n                start = void 0;\n                end = void 0;\n                stringl = 0;\n                start = end = 0;\n                stringl = string.length;\n                n = 0;\n                while(n < stringl){\n                    c1 = string.charCodeAt(n);\n                    enc = null;\n                    if (c1 < 128) {\n                        end++;\n                    } else if (c1 > 127 && c1 < 2048) {\n                        enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);\n                    } else {\n                        enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);\n                    }\n                    if (enc !== null) {\n                        if (end > start) {\n                            utftext += string.slice(start, end);\n                        }\n                        utftext += enc;\n                        start = end = n + 1;\n                    }\n                    n++;\n                }\n                if (end > start) {\n                    utftext += string.slice(start, stringl);\n                }\n                return utftext;\n            };\n            // CONCATENATED MODULE: ./src/crc32.js\n            /**\n * CRC32 calculator\n * Depends on 'utf8_encode'\n * @private\n * @param {string} str - The string to calculate the CRC32 for.\n * @return {number}\n */ function crc32(str) {\n                var crc, i, iTop, table, x, y; // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: T0bsn\n                // +   improved by: http://stackoverflow.com/questions/2647935/javascript-crc32-function-and-php-crc32-not-matching\n                // -    depends on: utf8_encode\n                // *     example 1: crc32('Kevin van Zonneveld');\n                // *     returns 1: 1249991249\n                str = src_utf8_encode(str);\n                table = \"00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D\";\n                crc = 0;\n                x = 0;\n                y = 0;\n                crc = crc ^ -1;\n                i = 0;\n                iTop = str.length;\n                while(i < iTop){\n                    y = (crc ^ str.charCodeAt(i)) & 0xFF;\n                    x = \"0x\" + table.substr(y * 9, 8);\n                    crc = crc >>> 8 ^ x;\n                    i++;\n                }\n                crc = crc ^ -1; //convert to unsigned 32-bit int if needed\n                if (crc < 0) {\n                    crc += 4294967296;\n                }\n                return crc;\n            }\n            /* harmony default export */ var src_crc32 = crc32;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/stringPad.js\n            function stringPad(value, targetLength, padString) {\n                targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\n                padString = String(typeof padString !== \"undefined\" ? padString : \" \");\n                if (value.length > targetLength) {\n                    return String(value);\n                } else {\n                    targetLength = targetLength - value.length;\n                    if (targetLength > padString.length) {\n                        padString += repeatStringNumTimes(padString, targetLength / padString.length);\n                    }\n                    return padString.slice(0, targetLength) + String(value);\n                }\n            }\n            function repeatStringNumTimes(string, times) {\n                var repeatedString = \"\";\n                while(times > 0){\n                    repeatedString += string;\n                    times--;\n                }\n                return repeatedString;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/base64Map.js\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            var base64Map_num = 0;\n            var map = {};\n            _toConsumableArray(chars).forEach(function(_char) {\n                var key = base64Map_num.toString(2);\n                key = stringPad(key, 6, \"0\");\n                map[key] = _char;\n                base64Map_num++;\n            });\n            /**\n * Map of six-bit binary codes to Base64 characters\n */ /* harmony default export */ var base64Map = map;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/reverseVersion.js\n            /**\n * @description A semVer like string, x.y.z or x.y is allowed\n *              Reverses the version positions, x.y.z turns to z.y.x\n *              Pads each segment with '0' so they have length of 2\n *              Example: 1.2.3 -> 03.02.01\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} in the form of zz.yy.xx (\n */ function reverseVersion(semVer) {\n                if (semVer.split(\".\").length < 2) {\n                    throw new Error(\"invalid semVer, must have at least two segments\");\n                } // Split by '.', reverse, create new array with padded values and concat it together\n                return semVer.split(\".\").reverse().map(function(segment) {\n                    return stringPad(segment, 2, \"0\");\n                }).join(\".\");\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/encodeVersion.js\n            /**\n * @description Encodes a semVer-like version string\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} A string built from 3 characters of the base64 table that encode the semVer\n */ function encodeVersion(semVer) {\n                var strResult = \"\"; // support x.y or x.y.z by using 'parts' as a variable\n                var parts = semVer.split(\".\").length;\n                var paddedStringLength = parts * 6; // we pad to either 12 or 18 characters\n                // reverse (but don't mirror) the version. 1.5.15 -> 15.5.1\n                // Pad to two spaces, 15.5.1 -> 15.05.01\n                var paddedReversedSemver = reverseVersion(semVer); // turn 15.05.01 to a string '150501' then to a number 150501\n                var num = parseInt(paddedReversedSemver.split(\".\").join(\"\")); // Represent as binary, add left padding to 12 or 18 characters.\n                // 150,501 -> 100100101111100101\n                var paddedBinary = num.toString(2);\n                paddedBinary = stringPad(paddedBinary, paddedStringLength, \"0\"); // Stop in case an invalid version number was provided\n                // paddedBinary must be built from sections of 6 bits\n                if (paddedBinary.length % 6 !== 0) {\n                    throw \"Version must be smaller than 43.21.26)\";\n                } // turn every 6 bits into a character using the base64Map\n                paddedBinary.match(/.{1,6}/g).forEach(function(bitString) {\n                    // console.log(bitString);\n                    strResult += base64Map[bitString];\n                });\n                return strResult;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getSDKAnalyticsSignature.js\n            /**\n * @description Gets the SDK signature by encoding the SDK version and tech version\n * @param {{\n *    [techVersion]:string,\n *    [sdkSemver]: string,\n *    [sdkCode]: string,\n *    [feature]: string\n * }} analyticsOptions\n * @return {string} sdkAnalyticsSignature\n */ function getSDKAnalyticsSignature() {\n                var analyticsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                try {\n                    var twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n                    var encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n                    var encodedTechVersion = encodeVersion(twoPartVersion);\n                    var featureCode = analyticsOptions.feature;\n                    var SDKCode = analyticsOptions.sdkCode;\n                    var algoVersion = \"A\"; // The algo version is determined here, it should not be an argument\n                    return \"\".concat(algoVersion).concat(SDKCode).concat(encodedSDKVersion).concat(encodedTechVersion).concat(featureCode);\n                } catch (e) {\n                    // Either SDK or Node versions were unparsable\n                    return \"E\";\n                }\n            }\n            /**\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' || 'x.y' || string} semVerStr\n */ function removePatchFromSemver(semVerStr) {\n                var parts = semVerStr.split(\".\");\n                return \"\".concat(parts[0], \".\").concat(parts[1]);\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getAnalyticsOptions.js\n            /**\n * @description Gets the analyticsOptions from options- should include sdkSemver, techVersion, sdkCode, and feature\n * @param options\n * @returns {{sdkSemver: (string), sdkCode, feature: string, techVersion: (string)} || {}}\n */ function getAnalyticsOptions(options) {\n                var analyticsOptions = {\n                    sdkSemver: options.sdkSemver,\n                    techVersion: options.techVersion,\n                    sdkCode: options.sdkCode,\n                    feature: \"0\"\n                };\n                if (options.urlAnalytics) {\n                    if (options.accessibility) {\n                        analyticsOptions.feature = \"D\";\n                    }\n                    if (options.loading === \"lazy\") {\n                        analyticsOptions.feature = \"C\";\n                    }\n                    if (options.responsive) {\n                        analyticsOptions.feature = \"A\";\n                    }\n                    if (options.placeholder) {\n                        analyticsOptions.feature = \"B\";\n                    }\n                    return analyticsOptions;\n                } else {\n                    return {};\n                }\n            }\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/assign\",\"commonjs2\":\"lodash/assign\",\"amd\":\"lodash/assign\",\"root\":[\"_\",\"assign\"]}\n            var assign_root_assign_ = __nested_webpack_require_7160__(\"lodash/assign\");\n            var assign_root_assign_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(assign_root_assign_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/cloneDeep\",\"commonjs2\":\"lodash/cloneDeep\",\"amd\":\"lodash/cloneDeep\",\"root\":[\"_\",\"cloneDeep\"]}\n            var cloneDeep_root_cloneDeep_ = __nested_webpack_require_7160__(\"lodash/cloneDeep\");\n            var cloneDeep_root_cloneDeep_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(cloneDeep_root_cloneDeep_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/compact\",\"commonjs2\":\"lodash/compact\",\"amd\":\"lodash/compact\",\"root\":[\"_\",\"compact\"]}\n            var compact_root_compact_ = __nested_webpack_require_7160__(\"lodash/compact\");\n            var compact_root_compact_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(compact_root_compact_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/difference\",\"commonjs2\":\"lodash/difference\",\"amd\":\"lodash/difference\",\"root\":[\"_\",\"difference\"]}\n            var difference_root_difference_ = __nested_webpack_require_7160__(\"lodash/difference\");\n            var difference_root_difference_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(difference_root_difference_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/functions\",\"commonjs2\":\"lodash/functions\",\"amd\":\"lodash/functions\",\"root\":[\"_\",\"functions\"]}\n            var functions_root_functions_ = __nested_webpack_require_7160__(\"lodash/functions\");\n            var functions_root_functions_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(functions_root_functions_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/identity\",\"commonjs2\":\"lodash/identity\",\"amd\":\"lodash/identity\",\"root\":[\"_\",\"identity\"]}\n            var identity_root_identity_ = __nested_webpack_require_7160__(\"lodash/identity\");\n            var identity_root_identity_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(identity_root_identity_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/includes\",\"commonjs2\":\"lodash/includes\",\"amd\":\"lodash/includes\",\"root\":[\"_\",\"includes\"]}\n            var includes_root_includes_ = __nested_webpack_require_7160__(\"lodash/includes\");\n            var includes_root_includes_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(includes_root_includes_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isArray\",\"commonjs2\":\"lodash/isArray\",\"amd\":\"lodash/isArray\",\"root\":[\"_\",\"isArray\"]}\n            var isArray_root_isArray_ = __nested_webpack_require_7160__(\"lodash/isArray\");\n            var isArray_root_isArray_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isArray_root_isArray_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isPlainObject\",\"commonjs2\":\"lodash/isPlainObject\",\"amd\":\"lodash/isPlainObject\",\"root\":[\"_\",\"isPlainObject\"]}\n            var isPlainObject_root_isPlainObject_ = __nested_webpack_require_7160__(\"lodash/isPlainObject\");\n            var isPlainObject_root_isPlainObject_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isPlainObject_root_isPlainObject_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isString\",\"commonjs2\":\"lodash/isString\",\"amd\":\"lodash/isString\",\"root\":[\"_\",\"isString\"]}\n            var isString_root_isString_ = __nested_webpack_require_7160__(\"lodash/isString\");\n            var isString_root_isString_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isString_root_isString_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/merge\",\"commonjs2\":\"lodash/merge\",\"amd\":\"lodash/merge\",\"root\":[\"_\",\"merge\"]}\n            var merge_root_merge_ = __nested_webpack_require_7160__(\"lodash/merge\");\n            var merge_root_merge_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(merge_root_merge_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isElement\",\"commonjs2\":\"lodash/isElement\",\"amd\":\"lodash/isElement\",\"root\":[\"_\",\"isElement\"]}\n            var isElement_root_isElement_ = __nested_webpack_require_7160__(\"lodash/isElement\");\n            var isElement_root_isElement_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isElement_root_isElement_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isFunction\",\"commonjs2\":\"lodash/isFunction\",\"amd\":\"lodash/isFunction\",\"root\":[\"_\",\"isFunction\"]}\n            var isFunction_root_isFunction_ = __nested_webpack_require_7160__(\"lodash/isFunction\");\n            var isFunction_root_isFunction_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isFunction_root_isFunction_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/trim\",\"commonjs2\":\"lodash/trim\",\"amd\":\"lodash/trim\",\"root\":[\"_\",\"trim\"]}\n            var trim_root_trim_ = __nested_webpack_require_7160__(\"lodash/trim\");\n            var trim_root_trim_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(trim_root_trim_);\n            // CONCATENATED MODULE: ./src/util/lazyLoad.js\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, _typeof(obj);\n            }\n            /*\n * Includes utility methods for lazy loading media\n */ /**\n * Check if IntersectionObserver is supported\n * @return {boolean} true if window.IntersectionObserver is defined\n */ function isIntersectionObserverSupported() {\n                // Check that 'IntersectionObserver' property is defined on window\n                return  false && 0;\n            }\n            /**\n * Check if native lazy loading is supported\n * @return {boolean} true if 'loading' property is defined for HTMLImageElement\n */ function isNativeLazyLoadSupported() {\n                return (typeof HTMLImageElement === \"undefined\" ? \"undefined\" : _typeof(HTMLImageElement)) === \"object\" && HTMLImageElement.prototype.loading;\n            }\n            /**\n * Calls onIntersect() when intersection is detected, or when\n * no native lazy loading or when IntersectionObserver isn't supported.\n * @param {Element} el - the element to observe\n * @param {function} onIntersect - called when the given element is in view\n */ function detectIntersection(el, onIntersect) {\n                try {\n                    if (isNativeLazyLoadSupported() || !isIntersectionObserverSupported()) {\n                        // Return if there's no need or possibility to detect intersection\n                        onIntersect();\n                        return;\n                    } // Detect intersection with given element using IntersectionObserver\n                    var observer = new IntersectionObserver(function(entries) {\n                        entries.forEach(function(entry) {\n                            if (entry.isIntersecting) {\n                                onIntersect();\n                                observer.unobserve(entry.target);\n                            }\n                        });\n                    }, {\n                        threshold: [\n                            0,\n                            0.01\n                        ]\n                    });\n                    observer.observe(el);\n                } catch (e) {\n                    onIntersect();\n                }\n            }\n            // CONCATENATED MODULE: ./src/constants.js\n            var VERSION = \"2.5.0\";\n            var CF_SHARED_CDN = \"d3jpl91pxevbkh.cloudfront.net\";\n            var OLD_AKAMAI_SHARED_CDN = \"cloudinary-a.akamaihd.net\";\n            var AKAMAI_SHARED_CDN = \"res.cloudinary.com\";\n            var SHARED_CDN = AKAMAI_SHARED_CDN;\n            var DEFAULT_TIMEOUT_MS = 10000;\n            var DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            var DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var SEO_TYPES = {\n                \"image/upload\": \"images\",\n                \"image/private\": \"private_images\",\n                \"image/authenticated\": \"authenticated_images\",\n                \"raw/upload\": \"files\",\n                \"video/upload\": \"videos\"\n            };\n            /**\n* @const {Object} Cloudinary.DEFAULT_IMAGE_PARAMS\n* Defaults values for image parameters.\n*\n* (Previously defined using option_consume() )\n */ var DEFAULT_IMAGE_PARAMS = {\n                resource_type: \"image\",\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n* Defaults values for video parameters.\n* @const {Object} Cloudinary.DEFAULT_VIDEO_PARAMS\n* (Previously defined using option_consume() )\n */ var DEFAULT_VIDEO_PARAMS = {\n                fallback_content: \"\",\n                resource_type: \"video\",\n                source_transformation: {},\n                source_types: DEFAULT_VIDEO_SOURCE_TYPES,\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n * Recommended sources for video tag\n * @const {Object} Cloudinary.DEFAULT_VIDEO_SOURCES\n */ var DEFAULT_VIDEO_SOURCES = [\n                {\n                    type: \"mp4\",\n                    codecs: \"hev1\",\n                    transformations: {\n                        video_codec: \"h265\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    codecs: \"vp9\",\n                    transformations: {\n                        video_codec: \"vp9\"\n                    }\n                },\n                {\n                    type: \"mp4\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                }\n            ];\n            var DEFAULT_EXTERNAL_LIBRARIES = {\n                seeThru: \"https://unpkg.com/seethru@4/dist/seeThru.min.js\"\n            };\n            /**\n * Predefined placeholder transformations\n * @const {Object} Cloudinary.PLACEHOLDER_IMAGE_MODES\n */ var PLACEHOLDER_IMAGE_MODES = {\n                \"blur\": [\n                    {\n                        effect: \"blur:2000\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Default\n                \"pixelate\": [\n                    {\n                        effect: \"pixelate\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Generates a pixel size image which color is the predominant color of the original image.\n                \"predominant-color-pixel\": [\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 1,\n                        height: 1,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                // Generates an image which color is the predominant color of the original image.\n                \"predominant-color\": [\n                    {\n                        variables: [\n                            [\n                                \"$currWidth\",\n                                \"w\"\n                            ],\n                            [\n                                \"$currHeight\",\n                                \"h\"\n                            ]\n                        ]\n                    },\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 10,\n                        height: 10,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        width: \"$currWidth\",\n                        height: \"$currHeight\",\n                        crop: \"fill\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                \"vectorize\": [\n                    {\n                        effect: \"vectorize:3:0.1\",\n                        fetch_format: \"svg\"\n                    }\n                ]\n            };\n            /**\n * Predefined accessibility transformations\n * @const {Object} Cloudinary.ACCESSIBILITY_MODES\n */ var ACCESSIBILITY_MODES = {\n                darkmode: \"tint:75:black\",\n                brightmode: \"tint:50:white\",\n                monochrome: \"grayscale\",\n                colorblind: \"assist_colorblind\"\n            };\n            /**\n * A list of keys used by the url() function.\n * @private\n */ var URL_KEYS = [\n                \"accessibility\",\n                \"api_secret\",\n                \"auth_token\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"format\",\n                \"placeholder\",\n                \"private_cdn\",\n                \"resource_type\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"sign_url\",\n                \"signature\",\n                \"ssl_detected\",\n                \"type\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\"\n            ];\n            /**\n * The resource storage type\n * @typedef type\n * @enum {string}\n * @property  {string} 'upload' A resource uploaded directly to Cloudinary\n * @property  {string} 'fetch' A resource fetched by Cloudinary from a 3rd party storage\n * @property  {string} 'private'\n * @property  {string} 'authenticated'\n * @property  {string} 'sprite'\n * @property  {string} 'facebook'\n * @property  {string} 'twitter'\n * @property  {string} 'youtube'\n * @property  {string} 'vimeo'\n *\n */ /**\n * The resource type\n * @typedef resourceType\n * @enum {string}\n * @property {string} 'image' An image file\n * @property {string} 'video' A video file\n * @property {string} 'raw'   A raw file\n */ // CONCATENATED MODULE: ./src/util/baseutil.js\n            function baseutil_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return baseutil_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, baseutil_typeof(obj);\n            }\n            /*\n * Includes common utility methods and shims\n */ function omit(obj, keys) {\n                obj = obj || {};\n                var srcKeys = Object.keys(obj).filter(function(key) {\n                    return !includes_root_includes_default()(keys, key);\n                });\n                var filtered = {};\n                srcKeys.forEach(function(key) {\n                    return filtered[key] = obj[key];\n                });\n                return filtered;\n            }\n            /**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */ var baseutil_allStrings = function allStrings(list) {\n                return list.length && list.every(isString_root_isString_default.a);\n            };\n            /**\n* Creates a new array without the given item.\n* @function Util.without\n* @param {Array} array - original array\n* @param {*} item - the item to exclude from the new array\n* @return {Array} a new array made of the original array's items except for `item`\n */ var without = function without(array, item) {\n                return array.filter(function(v) {\n                    return v !== item;\n                });\n            };\n            /**\n* Return true is value is a number or a string representation of a number.\n* @function Util.isNumberLike\n* @param {*} value\n* @returns {boolean} true if value is a number\n* @example\n*    Util.isNumber(0) // true\n*    Util.isNumber(\"1.3\") // true\n*    Util.isNumber(\"\") // false\n*    Util.isNumber(undefined) // false\n */ var isNumberLike = function isNumberLike(value) {\n                return value != null && !isNaN(parseFloat(value));\n            };\n            /**\n * Escape all characters matching unsafe in the given string\n * @function Util.smartEscape\n * @param {string} string - source string to escape\n * @param {RegExp} unsafe - characters that must be escaped\n * @return {string} escaped string\n */ var smartEscape = function smartEscape(string) {\n                var unsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /([^a-zA-Z0-9_.\\-\\/:]+)/g;\n                return string.replace(unsafe, function(match) {\n                    return match.split(\"\").map(function(c) {\n                        return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n                    }).join(\"\");\n                });\n            };\n            /**\n * Assign values from sources if they are not defined in the destination.\n * Once a value is set it does not change\n * @function Util.defaults\n * @param {Object} destination - the object to assign defaults to\n * @param {...Object} source - the source object(s) to assign defaults from\n * @return {Object} destination after it was modified\n */ var defaults = function defaults(destination) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                return sources.reduce(function(dest, source) {\n                    var key, value;\n                    for(key in source){\n                        value = source[key];\n                        if (dest[key] === void 0) {\n                            dest[key] = value;\n                        }\n                    }\n                    return dest;\n                }, destination);\n            };\n            /*********** lodash functions */ var objectProto = Object.prototype;\n            /**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */ var objToString = objectProto.toString;\n            /**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n#isObject({});\n * // => true\n *\n#isObject([1, 2, 3]);\n * // => true\n *\n#isObject(1);\n * // => false\n */ var isObject = function isObject(value) {\n                var type; // Avoid a V8 JIT bug in Chrome 19-20.\n                // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n                type = baseutil_typeof(value);\n                return !!value && (type === \"object\" || type === \"function\");\n            };\n            var funcTag = \"[object Function]\";\n            /**\n* Checks if `value` is classified as a `Function` object.\n* @function Util.isFunction\n* @param {*} value The value to check.\n* @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n* @example\n*\n* function Foo(){};\n* isFunction(Foo);\n* // => true\n*\n* isFunction(/abc/);\n* // => false\n */ var isFunction = function isFunction(value) {\n                // The use of `Object#toString` avoids issues with the `typeof` operator\n                // in older versions of Chrome and Safari which return 'function' for regexes\n                // and Safari 8 which returns 'object' for typed array constructors.\n                return isObject(value) && objToString.call(value) === funcTag;\n            };\n            /*********** lodash functions */ /** Used to match words to create compound words. */ var reWords = function() {\n                var lower, upper;\n                upper = \"[A-Z]\";\n                lower = \"[a-z]+\";\n                return RegExp(upper + \"+(?=\" + upper + lower + \")|\" + upper + \"?\" + lower + \"|\" + upper + \"+|[0-9]+\", \"g\");\n            }();\n            /**\n* Convert string to camelCase\n* @function Util.camelCase\n* @param {string} source - the string to convert\n* @return {string} in camelCase format\n */ var camelCase = function camelCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.charAt(0).toLocaleUpperCase() + word.slice(1).toLocaleLowerCase();\n                });\n                words[0] = words[0].toLocaleLowerCase();\n                return words.join(\"\");\n            };\n            /**\n * Convert string to snake_case\n * @function Util.snakeCase\n * @param {string} source - the string to convert\n * @return {string} in snake_case format\n */ var snakeCase = function snakeCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.toLocaleLowerCase();\n                });\n                return words.join(\"_\");\n            };\n            /**\n * Creates a new object from source, with the keys transformed using the converter.\n * @param {object} source\n * @param {function|null} converter\n * @returns {object}\n */ var convertKeys = function convertKeys(source, converter) {\n                var result, value;\n                result = {};\n                for(var key in source){\n                    value = source[key];\n                    if (converter) {\n                        key = converter(key);\n                    }\n                    if (!isEmpty(key)) {\n                        result[key] = value;\n                    }\n                }\n                return result;\n            };\n            /**\n * Create a copy of the source object with all keys in camelCase\n * @function Util.withCamelCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withCamelCaseKeys = function withCamelCaseKeys(source) {\n                return convertKeys(source, camelCase);\n            };\n            /**\n * Create a copy of the source object with all keys in snake_case\n * @function Util.withSnakeCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withSnakeCaseKeys = function withSnakeCaseKeys(source) {\n                return convertKeys(source, snakeCase);\n            }; // Browser\n            // Node.js\n            var base64Encode = typeof btoa !== \"undefined\" && isFunction(btoa) ? btoa : typeof Buffer !== \"undefined\" && isFunction(Buffer) ? function(input) {\n                if (!(input instanceof Buffer)) {\n                    input = new Buffer.from(String(input), \"binary\");\n                }\n                return input.toString(\"base64\");\n            } : function(input) {\n                throw new Error(\"No base64 encoding function found\");\n            };\n            /**\n* Returns the Base64-decoded version of url.<br>\n* This method delegates to `btoa` if present. Otherwise it tries `Buffer`.\n* @function Util.base64EncodeURL\n* @param {string} url - the url to encode. the value is URIdecoded and then re-encoded before converting to base64 representation\n* @return {string} the base64 representation of the URL\n */ var base64EncodeURL = function base64EncodeURL(url) {\n                try {\n                    url = decodeURI(url);\n                } finally{\n                    url = encodeURI(url);\n                }\n                return base64Encode(url);\n            };\n            /**\n * Create a new object with only URL parameters\n * @param {object} options The source object\n * @return {Object} An object containing only URL parameters\n */ function extractUrlParams(options) {\n                return URL_KEYS.reduce(function(obj, key) {\n                    if (options[key] != null) {\n                        obj[key] = options[key];\n                    }\n                    return obj;\n                }, {});\n            }\n            /**\n * Handle the format parameter for fetch urls\n * @private\n * @param options url and transformation options. This argument may be changed by the function!\n */ function patchFetchFormat(options) {\n                if (options == null) {\n                    options = {};\n                }\n                if (options.type === \"fetch\") {\n                    if (options.fetch_format == null) {\n                        options.fetch_format = optionConsume(options, \"format\");\n                    }\n                }\n            }\n            /**\n * Deletes `option_name` from `options` and return the value if present.\n * If `options` doesn't contain `option_name` the default value is returned.\n * @param {Object} options a collection\n * @param {String} option_name the name (key) of the desired value\n * @param {*} [default_value] the value to return is option_name is missing\n */ function optionConsume(options, option_name, default_value) {\n                var result = options[option_name];\n                delete options[option_name];\n                if (result != null) {\n                    return result;\n                } else {\n                    return default_value;\n                }\n            }\n            /**\n * Returns true if value is empty:\n * <ul>\n *   <li>value is null or undefined</li>\n *   <li>value is an array or string of length 0</li>\n *   <li>value is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param value\n * @returns {boolean} true if value is empty\n */ function isEmpty(value) {\n                if (value == null) {\n                    return true;\n                }\n                if (typeof value.length == \"number\") {\n                    return value.length === 0;\n                }\n                if (typeof value.size == \"number\") {\n                    return value.size === 0;\n                }\n                if (baseutil_typeof(value) == \"object\") {\n                    for(var key in value){\n                        if (value.hasOwnProperty(key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return true;\n            }\n            // CONCATENATED MODULE: ./src/util/browser.js\n            /**\n * Based on video.js implementation:\n * https://github.com/videojs/video.js/blob/4238f5c1d88890547153e7e1de7bd0d1d8e0b236/src/js/utils/browser.js\n */ /**\n* Retrieve from the navigator the user agent property.\n* @returns user agent property.\n*/ function getUserAgent() {\n                return navigator && navigator.userAgent || \"\";\n            }\n            /**\n * Detect if current browser is any Android\n * @returns true if current browser is Android, false otherwise.\n */ function isAndroid() {\n                var userAgent = getUserAgent();\n                return /Android/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is any Edge\n * @returns true if current browser is Edge, false otherwise.\n */ function isEdge() {\n                var userAgent = getUserAgent();\n                return /Edg/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is chrome.\n * @returns true if current browser is Chrome, false otherwise.\n */ function isChrome() {\n                var userAgent = getUserAgent();\n                return !isEdge() && (/Chrome/i.test(userAgent) || /CriOS/i.test(userAgent));\n            }\n            /**\n * Detect if current browser is Safari.\n * @returns true if current browser is Safari, false otherwise.\n */ function isSafari() {\n                // User agents for other browsers might include \"Safari\" so we must exclude them.\n                // For example - this is the chrome user agent on windows 10:\n                // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\n                var userAgent = getUserAgent();\n                return /Safari/i.test(userAgent) && !isChrome() && !isAndroid() && !isEdge();\n            }\n            // CONCATENATED MODULE: ./src/util/lodash.js\n            var nodeContains;\n            /*\n * Includes utility methods and lodash / jQuery shims\n */ /**\n * Get data from the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will get the `data-` attribute\n * @param {Element} element - the element to get the data from\n * @param {string} name - the name of the data item\n * @returns the value associated with the `name`\n * @function Util.getData\n */ var lodash_getData = function getData(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name);\n                }\n            };\n            /**\n * Set data in the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will set the `data-` attribute\n * @function Util.setData\n * @param {Element} element - the element to set the data in\n * @param {string} name - the name of the data item\n * @param {*} value - the value to be set\n *\n */ var lodash_setData = function setData(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name, value);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name, value);\n                }\n            };\n            /**\n * Get attribute from the DOM element.\n *\n * @function Util.getAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @returns {*} the value of the attribute\n *\n */ var lodash_getAttribute = function getAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(name);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name);\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(name);\n                }\n            };\n            /**\n * Set attribute in the DOM element.\n *\n * @function Util.setAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @param {*} value - the value to be set\n */ var lodash_setAttribute = function setAttribute(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(name, value);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name, value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(name, value);\n                }\n            };\n            /**\n * Remove an attribute in the DOM element.\n *\n * @function Util.removeAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n */ var lodash_removeAttribute = function removeAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.removeAttribute):\n                        return element.removeAttribute(name);\n                    default:\n                        return lodash_setAttribute(element, void 0);\n                }\n            };\n            /**\n * Set a group of attributes to the element\n * @function Util.setAttributes\n * @param {Element} element - the element to set the attributes for\n * @param {Object} attributes - a hash of attribute names and values\n */ var setAttributes = function setAttributes(element, attributes) {\n                var name, results, value;\n                results = [];\n                for(name in attributes){\n                    value = attributes[name];\n                    if (value != null) {\n                        results.push(lodash_setAttribute(element, name, value));\n                    } else {\n                        results.push(lodash_removeAttribute(element, name));\n                    }\n                }\n                return results;\n            };\n            /**\n * Checks if element has a css class\n * @function Util.hasClass\n * @param {Element} element - the element to check\n * @param {string} name - the class name\n @returns {boolean} true if the element has the class\n */ var lodash_hasClass = function hasClass(element, name) {\n                if (isElement_root_isElement_default()(element)) {\n                    return element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")));\n                }\n            };\n            /**\n * Add class to the element\n * @function Util.addClass\n * @param {Element} element - the element\n * @param {string} name - the class name to add\n */ var lodash_addClass = function addClass(element, name) {\n                if (!element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")))) {\n                    return element.className = trim_root_trim_default()(\"\".concat(element.className, \" \").concat(name));\n                }\n            }; // The following code is taken from jQuery\n            var getStyles = function getStyles(elem) {\n                // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n                // IE throws on elements created in popups\n                // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n                if (elem.ownerDocument.defaultView.opener) {\n                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n                }\n                return window.getComputedStyle(elem, null);\n            };\n            var cssExpand = [\n                \"Top\",\n                \"Right\",\n                \"Bottom\",\n                \"Left\"\n            ];\n            nodeContains = function nodeContains(a, b) {\n                var adown, bup;\n                adown = a.nodeType === 9 ? a.documentElement : a;\n                bup = b && b.parentNode;\n                return a === bup || !!(bup && bup.nodeType === 1 && adown.contains(bup));\n            }; // Truncated version of jQuery.style(elem, name)\n            var domStyle = function domStyle(elem, name) {\n                if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n                    return elem.style[name];\n                }\n            };\n            var curCSS = function curCSS(elem, name, computed) {\n                var maxWidth, minWidth, ret, rmargin, style, width;\n                rmargin = /^margin/;\n                width = void 0;\n                minWidth = void 0;\n                maxWidth = void 0;\n                ret = void 0;\n                style = elem.style;\n                computed = computed || getStyles(elem);\n                if (computed) {\n                    // Support: IE9\n                    // getPropertyValue is only needed for .css('filter') (#12537)\n                    ret = computed.getPropertyValue(name) || computed[name];\n                }\n                if (computed) {\n                    if (ret === \"\" && !nodeContains(elem.ownerDocument, elem)) {\n                        ret = domStyle(elem, name);\n                    } // Support: iOS < 6\n                    // A tribute to the \"awesome hack by Dean Edwards\"\n                    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n                    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n                    if (rnumnonpx.test(ret) && rmargin.test(name)) {\n                        // Remember the original values\n                        width = style.width;\n                        minWidth = style.minWidth;\n                        maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n                        style.minWidth = style.maxWidth = style.width = ret;\n                        ret = computed.width; // Revert the changed values\n                        style.width = width;\n                        style.minWidth = minWidth;\n                        style.maxWidth = maxWidth;\n                    }\n                } // Support: IE\n                // IE returns zIndex value as an integer.\n                if (ret !== undefined) {\n                    return ret + \"\";\n                } else {\n                    return ret;\n                }\n            };\n            var cssValue = function cssValue(elem, name, convert, styles) {\n                var val;\n                val = curCSS(elem, name, styles);\n                if (convert) {\n                    return parseFloat(val);\n                } else {\n                    return val;\n                }\n            };\n            var augmentWidthOrHeight = function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n                var i, len, side, sides, val; // If we already have the right measurement, avoid augmentation\n                // Otherwise initialize for horizontal or vertical properties\n                if (extra === (isBorderBox ? \"border\" : \"content\")) {\n                    return 0;\n                } else {\n                    sides = name === \"width\" ? [\n                        \"Right\",\n                        \"Left\"\n                    ] : [\n                        \"Top\",\n                        \"Bottom\"\n                    ];\n                    val = 0;\n                    for(i = 0, len = sides.length; i < len; i++){\n                        side = sides[i];\n                        if (extra === \"margin\") {\n                            // Both box models exclude margin, so add it if we want it\n                            val += cssValue(elem, extra + side, true, styles);\n                        }\n                        if (isBorderBox) {\n                            if (extra === \"content\") {\n                                // border-box includes padding, so remove it if we want content\n                                val -= cssValue(elem, \"padding\".concat(side), true, styles);\n                            }\n                            if (extra !== \"margin\") {\n                                // At this point, extra isn't border nor margin, so remove border\n                                val -= cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        } else {\n                            // At this point, extra isn't content, so add padding\n                            val += cssValue(elem, \"padding\".concat(side), true, styles);\n                            if (extra !== \"padding\") {\n                                // At this point, extra isn't content nor padding, so add border\n                                val += cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        }\n                    }\n                    return val;\n                }\n            };\n            var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n            var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n            var getWidthOrHeight = function getWidthOrHeight(elem, name, extra) {\n                var isBorderBox, styles, val, valueIsBorderBox; // Start with offset property, which is equivalent to the border-box value\n                valueIsBorderBox = true;\n                val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight;\n                styles = getStyles(elem);\n                isBorderBox = cssValue(elem, \"boxSizing\", false, styles) === \"border-box\"; // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n                if (val <= 0 || val == null) {\n                    // Fall back to computed then uncomputed css if necessary\n                    val = curCSS(elem, name, styles);\n                    if (val < 0 || val == null) {\n                        val = elem.style[name];\n                    }\n                    if (rnumnonpx.test(val)) {\n                        // Computed unit is not pixels. Stop here and return.\n                        return val;\n                    } // Check for style in case a browser which returns unreliable values\n                    // for getComputedStyle silently falls back to the reliable elem.style\n                    //    valueIsBorderBox = isBorderBox and (support.boxSizingReliable() or val is elem.style[name])\n                    valueIsBorderBox = isBorderBox && val === elem.style[name]; // Normalize \"\", auto, and prepare for extra\n                    val = parseFloat(val) || 0;\n                } // Use the active box-sizing model to add/subtract irrelevant styles\n                return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles);\n            };\n            var lodash_width = function width(element) {\n                return getWidthOrHeight(element, \"width\", \"content\");\n            };\n            /**\n * @class Util\n */ /**\n * Returns true if item is a string\n * @function Util.isString\n * @param item\n * @returns {boolean} true if item is a string\n */ /**\n * Returns true if item is empty:\n * <ul>\n *   <li>item is null or undefined</li>\n *   <li>item is an array or string of length 0</li>\n *   <li>item is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param item\n * @returns {boolean} true if item is empty\n */ /**\n * Assign source properties to destination.\n * If the property is an object it is assigned as a whole, overriding the destination object.\n * @function Util.assign\n * @param {Object} destination - the object to assign to\n */ /**\n * Recursively assign source properties to destination\n * @function Util.merge\n * @param {Object} destination - the object to assign to\n * @param {...Object} [sources] The source objects.\n */ /**\n * Create a new copy of the given object, including all internal objects.\n * @function Util.cloneDeep\n * @param {Object} value - the object to clone\n * @return {Object} a new deep copy of the object\n */ /**\n * Creates a new array from the parameter with \"falsey\" values removed\n * @function Util.compact\n * @param {Array} array - the array to remove values from\n * @return {Array} a new array without falsey values\n */ /**\n * Check if a given item is included in the given array\n * @function Util.contains\n * @param {Array} array - the array to search in\n * @param {*} item - the item to search for\n * @return {boolean} true if the item is included in the array\n */ /**\n * Returns values in the given array that are not included in the other array\n * @function Util.difference\n * @param {Array} arr - the array to select from\n * @param {Array} values - values to filter from arr\n * @return {Array} the filtered values\n */ /**\n * Returns a list of all the function names in obj\n * @function Util.functions\n * @param {Object} object - the object to inspect\n * @return {Array} a list of functions of object\n */ /**\n * Returns the provided value. This functions is used as a default predicate function.\n * @function Util.identity\n * @param {*} value\n * @return {*} the provided value\n */ /**\n * Remove leading or trailing spaces from text\n * @function Util.trim\n * @param {string} text\n * @return {string} the `text` without leading or trailing spaces\n */ // CONCATENATED MODULE: ./src/expression.js\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Represents a transformation expression.\n * @param {string} expressionStr - An expression in string format.\n * @class Expression\n * Normally this class is not instantiated directly\n */ var Expression = /*#__PURE__*/ function() {\n                function Expression(expressionStr) {\n                    _classCallCheck(this, Expression);\n                    /**\n     * @protected\n     * @inner Expression-expressions\n     */ this.expressions = [];\n                    if (expressionStr != null) {\n                        this.expressions.push(Expression.normalize(expressionStr));\n                    }\n                }\n                /**\n   * Convenience constructor method\n   * @function Expression.new\n   */ _createClass(Expression, [\n                    {\n                        key: \"serialize\",\n                        value: /**\n     * Serialize the expression\n     * @return {string} the expression as a string\n     */ function serialize() {\n                            return Expression.normalize(this.expressions.join(\"_\"));\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"getParent\",\n                        value: function getParent() {\n                            return this.parent;\n                        }\n                    },\n                    {\n                        key: \"setParent\",\n                        value: function setParent(parent) {\n                            this.parent = parent;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"predicate\",\n                        value: function predicate(name, operator, value) {\n                            if (Expression.OPERATORS[operator] != null) {\n                                operator = Expression.OPERATORS[operator];\n                            }\n                            this.expressions.push(\"\".concat(name, \"_\").concat(operator, \"_\").concat(value));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"and\",\n                        value: function and() {\n                            this.expressions.push(\"and\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"or\",\n                        value: function or() {\n                            this.expressions.push(\"or\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"then\",\n                        value: function then() {\n                            return this.getParent()[\"if\"](this.toString());\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(_value) {\n                            this.expressions.push(_value);\n                            return this;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(expressionStr) {\n                            return new this(expressionStr);\n                        }\n                    },\n                    {\n                        key: \"normalize\",\n                        value: function normalize(expression) {\n                            if (expression == null) {\n                                return expression;\n                            }\n                            expression = String(expression);\n                            var operators = \"\\\\|\\\\||>=|<=|&&|!=|>|=|<|/|-|\\\\+|\\\\*|\\\\^\"; // operators\n                            var operatorsPattern = \"((\" + operators + \")(?=[ _]))\";\n                            var operatorsReplaceRE = new RegExp(operatorsPattern, \"g\");\n                            expression = expression.replace(operatorsReplaceRE, function(match) {\n                                return Expression.OPERATORS[match];\n                            }); // predefined variables\n                            // The :${v} part is to prevent normalization of vars with a preceding colon (such as :duration),\n                            // It won't be found in PREDEFINED_VARS and so won't be normalized.\n                            // It is done like this because ie11 does not support regex lookbehind\n                            var predefinedVarsPattern = \"(\" + Object.keys(Expression.PREDEFINED_VARS).map(function(v) {\n                                return \":\".concat(v, \"|\").concat(v);\n                            }).join(\"|\") + \")\";\n                            var userVariablePattern = \"(\\\\$_*[^_ ]+)\";\n                            var variablesReplaceRE = new RegExp(\"\".concat(userVariablePattern, \"|\").concat(predefinedVarsPattern), \"g\");\n                            expression = expression.replace(variablesReplaceRE, function(match) {\n                                return Expression.PREDEFINED_VARS[match] || match;\n                            });\n                            return expression.replace(/[ _]+/g, \"_\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return new this(name).value(value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width() {\n                            return new this(\"width\");\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height() {\n                            return new this(\"height\");\n                        }\n                    },\n                    {\n                        key: \"initialWidth\",\n                        value: function initialWidth() {\n                            return new this(\"initialWidth\");\n                        }\n                    },\n                    {\n                        key: \"initialHeight\",\n                        value: function initialHeight() {\n                            return new this(\"initialHeight\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio() {\n                            return new this(\"aspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"initialAspectRatio\",\n                        value: function initialAspectRatio() {\n                            return new this(\"initialAspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount() {\n                            return new this(\"pageCount\");\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount() {\n                            return new this(\"faceCount\");\n                        }\n                    },\n                    {\n                        key: \"currentPage\",\n                        value: function currentPage() {\n                            return new this(\"currentPage\");\n                        }\n                    },\n                    {\n                        key: \"tags\",\n                        value: function tags() {\n                            return new this(\"tags\");\n                        }\n                    },\n                    {\n                        key: \"pageX\",\n                        value: function pageX() {\n                            return new this(\"pageX\");\n                        }\n                    },\n                    {\n                        key: \"pageY\",\n                        value: function pageY() {\n                            return new this(\"pageY\");\n                        }\n                    }\n                ]);\n                return Expression;\n            }();\n            /**\n * @internal\n */ Expression.OPERATORS = {\n                \"=\": \"eq\",\n                \"!=\": \"ne\",\n                \"<\": \"lt\",\n                \">\": \"gt\",\n                \"<=\": \"lte\",\n                \">=\": \"gte\",\n                \"&&\": \"and\",\n                \"||\": \"or\",\n                \"*\": \"mul\",\n                \"/\": \"div\",\n                \"+\": \"add\",\n                \"-\": \"sub\",\n                \"^\": \"pow\"\n            };\n            /**\n * @internal\n */ Expression.PREDEFINED_VARS = {\n                \"aspect_ratio\": \"ar\",\n                \"aspectRatio\": \"ar\",\n                \"current_page\": \"cp\",\n                \"currentPage\": \"cp\",\n                \"duration\": \"du\",\n                \"face_count\": \"fc\",\n                \"faceCount\": \"fc\",\n                \"height\": \"h\",\n                \"initial_aspect_ratio\": \"iar\",\n                \"initial_duration\": \"idu\",\n                \"initial_height\": \"ih\",\n                \"initial_width\": \"iw\",\n                \"initialAspectRatio\": \"iar\",\n                \"initialDuration\": \"idu\",\n                \"initialHeight\": \"ih\",\n                \"initialWidth\": \"iw\",\n                \"page_count\": \"pc\",\n                \"page_x\": \"px\",\n                \"page_y\": \"py\",\n                \"pageCount\": \"pc\",\n                \"pageX\": \"px\",\n                \"pageY\": \"py\",\n                \"tags\": \"tags\",\n                \"width\": \"w\"\n            };\n            /**\n * @internal\n */ Expression.BOUNDRY = \"[ _]+\";\n            /* harmony default export */ var expression = Expression;\n            // CONCATENATED MODULE: ./src/condition.js\n            function condition_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return condition_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, condition_typeof(obj);\n            }\n            function condition_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function condition_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function condition_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) condition_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) condition_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) _setPrototypeOf(subClass, superClass);\n            }\n            function _setPrototypeOf(o, p) {\n                _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return _setPrototypeOf(o, p);\n            }\n            function _createSuper(Derived) {\n                var hasNativeReflectConstruct = _isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = _getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = _getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return _possibleConstructorReturn(this, result);\n                };\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (call && (condition_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return _assertThisInitialized(self);\n            }\n            function _assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function _isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function _getPrototypeOf(o) {\n                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return _getPrototypeOf(o);\n            }\n            /**\n * Represents a transformation condition.\n * @param {string} conditionStr - a condition in string format\n * @class Condition\n * @example\n * // normally this class is not instantiated directly\n * var tr = cloudinary.Transformation.new()\n *    .if().width( \">\", 1000).and().aspectRatio(\"<\", \"3:4\").then()\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n * var tr = cloudinary.Transformation.new()\n *    .if(\"w > 1000 and aspectRatio < 3:4\")\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n */ var Condition = /*#__PURE__*/ function(_Expression) {\n                _inherits(Condition, _Expression);\n                var _super = _createSuper(Condition);\n                function Condition(conditionStr) {\n                    condition_classCallCheck(this, Condition);\n                    return _super.call(this, conditionStr);\n                }\n                /**\n   * @function Condition#height\n   * @param {string} operator the comparison operator (e.g. \"<\", \"lt\")\n   * @param {string|number} value the right hand side value\n   * @return {Condition} this condition\n   */ condition_createClass(Condition, [\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(operator, value) {\n                            return this.predicate(\"du\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"initialDuration\",\n                        value: function initialDuration(operator, value) {\n                            return this.predicate(\"idu\", operator, value);\n                        }\n                    }\n                ]);\n                return Condition;\n            }(expression);\n            /* harmony default export */ var condition = Condition;\n            // CONCATENATED MODULE: ./src/configuration.js\n            function _slicedToArray(arr, i) {\n                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || configuration_unsupportedIterableToArray(arr, i) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function configuration_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return configuration_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return configuration_arrayLikeToArray(o, minLen);\n            }\n            function configuration_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function _iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function _arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function configuration_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function configuration_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function configuration_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) configuration_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) configuration_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Class for defining account configuration options.\n * Depends on 'utils'\n */ /**\n * Class for defining account configuration options.\n * @constructor Configuration\n * @param {Object} options - The account configuration parameters to set.\n * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\"\n *  target=\"_new\">Available configuration options</a>\n */ var configuration_Configuration = /*#__PURE__*/ function() {\n                function Configuration(options) {\n                    configuration_classCallCheck(this, Configuration);\n                    this.configuration = options == null ? {} : cloneDeep_root_cloneDeep_default()(options);\n                    defaults(this.configuration, DEFAULT_CONFIGURATION_PARAMS);\n                }\n                /**\n   * Initializes the configuration. This method is a convenience method that invokes both\n   *  {@link Configuration#fromEnvironment|fromEnvironment()} (Node.js environment only)\n   *  and {@link Configuration#fromDocument|fromDocument()}.\n   *  It first tries to retrieve the configuration from the environment variable.\n   *  If not available, it tries from the document meta tags.\n   * @function Configuration#init\n   * @return {Configuration} returns `this` for chaining\n   * @see fromDocument\n   * @see fromEnvironment\n   */ configuration_createClass(Configuration, [\n                    {\n                        key: \"init\",\n                        value: function init() {\n                            this.fromEnvironment();\n                            this.fromDocument();\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(name, value) {\n                            this.configuration[name] = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"get\",\n                        value: function get(name) {\n                            return this.configuration[name];\n                        }\n                    },\n                    {\n                        key: \"merge\",\n                        value: function merge(config) {\n                            assign_root_assign_default()(this.configuration, cloneDeep_root_cloneDeep_default()(config));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromDocument\",\n                        value: function fromDocument() {\n                            var el, i, len, meta_elements;\n                            meta_elements = typeof document !== \"undefined\" && document !== null ? document.querySelectorAll('meta[name^=\"cloudinary_\"]') : void 0;\n                            if (meta_elements) {\n                                for(i = 0, len = meta_elements.length; i < len; i++){\n                                    el = meta_elements[i];\n                                    this.configuration[el.getAttribute(\"name\").replace(\"cloudinary_\", \"\")] = el.getAttribute(\"content\");\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromEnvironment\",\n                        value: function fromEnvironment() {\n                            var _this = this;\n                            var cloudinary_url, query, uri, uriRegex;\n                            if (typeof process !== \"undefined\" && process !== null && process.env && process.env.CLOUDINARY_URL) {\n                                cloudinary_url = process.env.CLOUDINARY_URL;\n                                uriRegex = /cloudinary:\\/\\/(?:(\\w+)(?:\\:([\\w-]+))?@)?([\\w\\.-]+)(?:\\/([^?]*))?(?:\\?(.+))?/;\n                                uri = uriRegex.exec(cloudinary_url);\n                                if (uri) {\n                                    if (uri[3] != null) {\n                                        this.configuration[\"cloud_name\"] = uri[3];\n                                    }\n                                    if (uri[1] != null) {\n                                        this.configuration[\"api_key\"] = uri[1];\n                                    }\n                                    if (uri[2] != null) {\n                                        this.configuration[\"api_secret\"] = uri[2];\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"private_cdn\"] = uri[4] != null;\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"secure_distribution\"] = uri[4];\n                                    }\n                                    query = uri[5];\n                                    if (query != null) {\n                                        query.split(\"&\").forEach(function(value) {\n                                            var _value$split = value.split(\"=\"), _value$split2 = _slicedToArray(_value$split, 2), k = _value$split2[0], v = _value$split2[1];\n                                            if (v == null) {\n                                                v = true;\n                                            }\n                                            _this.configuration[k] = v;\n                                        });\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"config\",\n                        value: function config(new_config, new_value) {\n                            switch(false){\n                                case new_value === void 0:\n                                    this.set(new_config, new_value);\n                                    return this.configuration;\n                                case !isString_root_isString_default()(new_config):\n                                    return this.get(new_config);\n                                case !isPlainObject_root_isPlainObject_default()(new_config):\n                                    this.merge(new_config);\n                                    return this.configuration;\n                                default:\n                                    // Backward compatibility - return the internal object\n                                    return this.configuration;\n                            }\n                        }\n                    },\n                    {\n                        key: \"toOptions\",\n                        value: function toOptions() {\n                            return cloneDeep_root_cloneDeep_default()(this.configuration);\n                        }\n                    }\n                ]);\n                return Configuration;\n            }();\n            var DEFAULT_CONFIGURATION_PARAMS = {\n                responsive_class: \"cld-responsive\",\n                responsive_use_breakpoints: true,\n                round_dpr: true,\n                secure: ( false ? 0 : void 0) === \"https:\"\n            };\n            configuration_Configuration.CONFIG_PARAMS = [\n                \"api_key\",\n                \"api_secret\",\n                \"callback\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"private_cdn\",\n                \"protocol\",\n                \"resource_type\",\n                \"responsive\",\n                \"responsive_class\",\n                \"responsive_use_breakpoints\",\n                \"responsive_width\",\n                \"round_dpr\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"type\",\n                \"upload_preset\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\",\n                \"externalLibraries\",\n                \"max_timeout_ms\"\n            ];\n            /* harmony default export */ var src_configuration = configuration_Configuration;\n            // CONCATENATED MODULE: ./src/layer/layer.js\n            function layer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function layer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function layer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) layer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) layer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            var layer_Layer = /*#__PURE__*/ function() {\n                /**\n   * Layer\n   * @constructor Layer\n   * @param {Object} options - layer parameters\n   */ function Layer1(options) {\n                    var _this = this;\n                    layer_classCallCheck(this, Layer1);\n                    this.options = {};\n                    if (options != null) {\n                        [\n                            \"resourceType\",\n                            \"type\",\n                            \"publicId\",\n                            \"format\"\n                        ].forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                }\n                layer_createClass(Layer1, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(value) {\n                            this.options.resourceType = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(value) {\n                            this.options.type = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"publicId\",\n                        value: function publicId(value) {\n                            this.options.publicId = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getPublicId\",\n                        value: function getPublicId() {\n                            var ref;\n                            return (ref = this.options.publicId) != null ? ref.replace(/\\//g, \":\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"getFullPublicId\",\n                        value: function getFullPublicId() {\n                            if (this.options.format != null) {\n                                return this.getPublicId() + \".\" + this.options.format;\n                            } else {\n                                return this.getPublicId();\n                            }\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            this.options.format = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components;\n                            components = [];\n                            if (this.options.publicId == null) {\n                                throw \"Must supply publicId\";\n                            }\n                            if (!(this.options.resourceType === \"image\")) {\n                                components.push(this.options.resourceType);\n                            }\n                            if (!(this.options.type === \"upload\")) {\n                                components.push(this.options.type);\n                            }\n                            components.push(this.getFullPublicId());\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.options);\n                        }\n                    }\n                ]);\n                return Layer1;\n            }();\n            /* harmony default export */ var layer_layer = layer_Layer;\n            // CONCATENATED MODULE: ./src/layer/textlayer.js\n            function textlayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return textlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, textlayer_typeof(obj);\n            }\n            function textlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function textlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function textlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) textlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) textlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function textlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) textlayer_setPrototypeOf(subClass, superClass);\n            }\n            function textlayer_setPrototypeOf(o, p) {\n                textlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return textlayer_setPrototypeOf(o, p);\n            }\n            function textlayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = textlayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = textlayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = textlayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return textlayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function textlayer_possibleConstructorReturn(self, call) {\n                if (call && (textlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return textlayer_assertThisInitialized(self);\n            }\n            function textlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function textlayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function textlayer_getPrototypeOf(o) {\n                textlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return textlayer_getPrototypeOf(o);\n            }\n            var textlayer_TextLayer = /*#__PURE__*/ function(_Layer) {\n                textlayer_inherits(TextLayer, _Layer);\n                var _super = textlayer_createSuper(TextLayer);\n                /**\n   * @constructor TextLayer\n   * @param {Object} options - layer parameters\n   */ function TextLayer(options) {\n                    var _this;\n                    textlayer_classCallCheck(this, TextLayer);\n                    var keys;\n                    _this = _super.call(this, options);\n                    keys = [\n                        \"resourceType\",\n                        \"resourceType\",\n                        \"fontFamily\",\n                        \"fontSize\",\n                        \"fontWeight\",\n                        \"fontStyle\",\n                        \"textDecoration\",\n                        \"textAlign\",\n                        \"stroke\",\n                        \"letterSpacing\",\n                        \"lineSpacing\",\n                        \"fontHinting\",\n                        \"fontAntialiasing\",\n                        \"text\",\n                        \"textStyle\"\n                    ];\n                    if (options != null) {\n                        keys.forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                    _this.options.resourceType = \"text\";\n                    return _this;\n                }\n                textlayer_createClass(TextLayer, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(_resourceType) {\n                            throw \"Cannot modify resourceType for text layers\";\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(_type) {\n                            throw \"Cannot modify type for text layers\";\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(_format) {\n                            throw \"Cannot modify format for text layers\";\n                        }\n                    },\n                    {\n                        key: \"fontFamily\",\n                        value: function fontFamily(_fontFamily) {\n                            this.options.fontFamily = _fontFamily;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontSize\",\n                        value: function fontSize(_fontSize) {\n                            this.options.fontSize = _fontSize;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontWeight\",\n                        value: function fontWeight(_fontWeight) {\n                            this.options.fontWeight = _fontWeight;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontStyle\",\n                        value: function fontStyle(_fontStyle) {\n                            this.options.fontStyle = _fontStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textDecoration\",\n                        value: function textDecoration(_textDecoration) {\n                            this.options.textDecoration = _textDecoration;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textAlign\",\n                        value: function textAlign(_textAlign) {\n                            this.options.textAlign = _textAlign;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"stroke\",\n                        value: function stroke(_stroke) {\n                            this.options.stroke = _stroke;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"letterSpacing\",\n                        value: function letterSpacing(_letterSpacing) {\n                            this.options.letterSpacing = _letterSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"lineSpacing\",\n                        value: function lineSpacing(_lineSpacing) {\n                            this.options.lineSpacing = _lineSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontHinting\",\n                        value: function fontHinting(_fontHinting) {\n                            this.options.fontHinting = _fontHinting;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontAntialiasing\",\n                        value: function fontAntialiasing(_fontAntialiasing) {\n                            this.options.fontAntialiasing = _fontAntialiasing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"text\",\n                        value: function text(_text) {\n                            this.options.text = _text;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(_textStyle) {\n                            this.options.textStyle = _textStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components, hasPublicId, hasStyle, publicId, re, res, start, style, text, textSource;\n                            style = this.textStyleIdentifier();\n                            if (this.options.publicId != null) {\n                                publicId = this.getFullPublicId();\n                            }\n                            if (this.options.text != null) {\n                                hasPublicId = !isEmpty(publicId);\n                                hasStyle = !isEmpty(style);\n                                if (hasPublicId && hasStyle || !hasPublicId && !hasStyle) {\n                                    throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay, but not both!\";\n                                }\n                                re = /\\$\\([a-zA-Z]\\w*\\)/g;\n                                start = 0; //        textSource = text.replace(new RegExp(\"[,/]\", 'g'), (c)-> \"%#{c.charCodeAt(0).toString(16).toUpperCase()}\")\n                                textSource = smartEscape(this.options.text, /[,\\/]/g);\n                                text = \"\";\n                                while(res = re.exec(textSource)){\n                                    text += smartEscape(textSource.slice(start, res.index));\n                                    text += res[0];\n                                    start = res.index + res[0].length;\n                                }\n                                text += smartEscape(textSource.slice(start));\n                            }\n                            components = [\n                                this.options.resourceType,\n                                style,\n                                publicId,\n                                text\n                            ];\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"textStyleIdentifier\",\n                        value: function textStyleIdentifier() {\n                            // Note: if a text-style argument is provided as a whole, it overrides everything else, no mix and match.\n                            if (!isEmpty(this.options.textStyle)) {\n                                return this.options.textStyle;\n                            }\n                            var components;\n                            components = [];\n                            if (this.options.fontWeight !== \"normal\") {\n                                components.push(this.options.fontWeight);\n                            }\n                            if (this.options.fontStyle !== \"normal\") {\n                                components.push(this.options.fontStyle);\n                            }\n                            if (this.options.textDecoration !== \"none\") {\n                                components.push(this.options.textDecoration);\n                            }\n                            components.push(this.options.textAlign);\n                            if (this.options.stroke !== \"none\") {\n                                components.push(this.options.stroke);\n                            }\n                            if (!(isEmpty(this.options.letterSpacing) && !isNumberLike(this.options.letterSpacing))) {\n                                components.push(\"letter_spacing_\" + this.options.letterSpacing);\n                            }\n                            if (!(isEmpty(this.options.lineSpacing) && !isNumberLike(this.options.lineSpacing))) {\n                                components.push(\"line_spacing_\" + this.options.lineSpacing);\n                            }\n                            if (!isEmpty(this.options.fontAntialiasing)) {\n                                components.push(\"antialias_\" + this.options.fontAntialiasing);\n                            }\n                            if (!isEmpty(this.options.fontHinting)) {\n                                components.push(\"hinting_\" + this.options.fontHinting);\n                            }\n                            if (!isEmpty(compact_root_compact_default()(components))) {\n                                if (isEmpty(this.options.fontFamily)) {\n                                    throw \"Must supply fontFamily. \".concat(components);\n                                }\n                                if (isEmpty(this.options.fontSize) && !isNumberLike(this.options.fontSize)) {\n                                    throw \"Must supply fontSize.\";\n                                }\n                            }\n                            components.unshift(this.options.fontFamily, this.options.fontSize);\n                            components = compact_root_compact_default()(components).join(\"_\");\n                            return components;\n                        }\n                    }\n                ]);\n                return TextLayer;\n            }(layer_layer);\n            ;\n            /* harmony default export */ var textlayer = textlayer_TextLayer;\n            // CONCATENATED MODULE: ./src/layer/subtitleslayer.js\n            function subtitleslayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return subtitleslayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, subtitleslayer_typeof(obj);\n            }\n            function subtitleslayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function subtitleslayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) subtitleslayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) subtitleslayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function subtitleslayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function subtitleslayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) subtitleslayer_setPrototypeOf(subClass, superClass);\n            }\n            function subtitleslayer_setPrototypeOf(o, p) {\n                subtitleslayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return subtitleslayer_setPrototypeOf(o, p);\n            }\n            function subtitleslayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = subtitleslayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = subtitleslayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = subtitleslayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return subtitleslayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function subtitleslayer_possibleConstructorReturn(self, call) {\n                if (call && (subtitleslayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return subtitleslayer_assertThisInitialized(self);\n            }\n            function subtitleslayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function subtitleslayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function subtitleslayer_getPrototypeOf(o) {\n                subtitleslayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return subtitleslayer_getPrototypeOf(o);\n            }\n            var SubtitlesLayer = /*#__PURE__*/ function(_TextLayer) {\n                subtitleslayer_inherits(SubtitlesLayer, _TextLayer);\n                var _super = subtitleslayer_createSuper(SubtitlesLayer);\n                /**\n   * Represent a subtitles layer\n   * @constructor SubtitlesLayer\n   * @param {Object} options - layer parameters\n   */ function SubtitlesLayer(options) {\n                    var _this;\n                    subtitleslayer_classCallCheck(this, SubtitlesLayer);\n                    _this = _super.call(this, options);\n                    _this.options.resourceType = \"subtitles\";\n                    return _this;\n                }\n                return subtitleslayer_createClass(SubtitlesLayer);\n            }(textlayer);\n            /* harmony default export */ var subtitleslayer = SubtitlesLayer;\n            // CONCATENATED MODULE: ./src/layer/fetchlayer.js\n            function fetchlayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return fetchlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, fetchlayer_typeof(obj);\n            }\n            function fetchlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function fetchlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function fetchlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) fetchlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) fetchlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function fetchlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) fetchlayer_setPrototypeOf(subClass, superClass);\n            }\n            function fetchlayer_setPrototypeOf(o, p) {\n                fetchlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return fetchlayer_setPrototypeOf(o, p);\n            }\n            function fetchlayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = fetchlayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = fetchlayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = fetchlayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return fetchlayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function fetchlayer_possibleConstructorReturn(self, call) {\n                if (call && (fetchlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return fetchlayer_assertThisInitialized(self);\n            }\n            function fetchlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function fetchlayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function fetchlayer_getPrototypeOf(o) {\n                fetchlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return fetchlayer_getPrototypeOf(o);\n            }\n            var fetchlayer_FetchLayer = /*#__PURE__*/ function(_Layer) {\n                fetchlayer_inherits(FetchLayer, _Layer);\n                var _super = fetchlayer_createSuper(FetchLayer);\n                /**\n   * @class FetchLayer\n   * @classdesc Creates an image layer using a remote URL.\n   * @param {Object|string} options - layer parameters or a url\n   * @param {string} options.url the url of the image to fetch\n   */ function FetchLayer(options) {\n                    var _this;\n                    fetchlayer_classCallCheck(this, FetchLayer);\n                    _this = _super.call(this, options);\n                    if (isString_root_isString_default()(options)) {\n                        _this.options.url = options;\n                    } else if (options != null ? options.url : void 0) {\n                        _this.options.url = options.url;\n                    }\n                    return _this;\n                }\n                fetchlayer_createClass(FetchLayer, [\n                    {\n                        key: \"url\",\n                        value: function url(_url) {\n                            this.options.url = _url;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return \"fetch:\".concat(base64EncodeURL(this.options.url));\n                        }\n                    }\n                ]);\n                return FetchLayer;\n            }(layer_layer);\n            /* harmony default export */ var fetchlayer = fetchlayer_FetchLayer;\n            // CONCATENATED MODULE: ./src/parameters.js\n            function parameters_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return parameters_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, parameters_typeof(obj);\n            }\n            function _get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    _get = Reflect.get.bind();\n                } else {\n                    _get = function _get(target, property, receiver) {\n                        var base = _superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return _get.apply(this, arguments);\n            }\n            function _superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = parameters_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function parameters_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) parameters_setPrototypeOf(subClass, superClass);\n            }\n            function parameters_setPrototypeOf(o, p) {\n                parameters_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return parameters_setPrototypeOf(o, p);\n            }\n            function parameters_createSuper(Derived) {\n                var hasNativeReflectConstruct = parameters_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = parameters_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = parameters_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return parameters_possibleConstructorReturn(this, result);\n                };\n            }\n            function parameters_possibleConstructorReturn(self, call) {\n                if (call && (parameters_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return parameters_assertThisInitialized(self);\n            }\n            function parameters_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function parameters_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function parameters_getPrototypeOf(o) {\n                parameters_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return parameters_getPrototypeOf(o);\n            }\n            function parameters_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function parameters_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function parameters_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) parameters_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) parameters_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */ var parameters_Param = /*#__PURE__*/ function() {\n                /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */ function Param(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, Param);\n                    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */ this.name = name;\n                    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */ this.shortName = shortName;\n                    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */ this.process = process1;\n                }\n                /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */ parameters_createClass(Param, [\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            this.origValue = origValue;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var val, valid;\n                            val = this.value();\n                            valid = isArray_root_isArray_default()(val) || isPlainObject_root_isPlainObject_default()(val) || isString_root_isString_default()(val) ? !isEmpty(val) : val != null;\n                            if (this.shortName != null && valid) {\n                                return \"\".concat(this.shortName, \"_\").concat(val);\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return this.process(this.origValue);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"norm_color\",\n                        value: function norm_color(value) {\n                            return value != null ? value.replace(/^#/, \"rgb:\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"build_array\",\n                        value: function build_array(arg) {\n                            if (arg == null) {\n                                return [];\n                            } else if (isArray_root_isArray_default()(arg)) {\n                                return arg;\n                            } else {\n                                return [\n                                    arg\n                                ];\n                            }\n                        }\n                    },\n                    {\n                        key: \"process_video_params\",\n                        value: function process_video_params(param) {\n                            var video;\n                            switch(param.constructor){\n                                case Object:\n                                    video = \"\";\n                                    if (\"codec\" in param) {\n                                        video = param.codec;\n                                        if (\"profile\" in param) {\n                                            video += \":\" + param.profile;\n                                            if (\"level\" in param) {\n                                                video += \":\" + param.level;\n                                                if (\"b_frames\" in param && param.b_frames === false) {\n                                                    video += \":bframes_no\";\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return video;\n                                case String:\n                                    return param;\n                                default:\n                                    return null;\n                            }\n                        }\n                    }\n                ]);\n                return Param;\n            }();\n            var parameters_ArrayParam = /*#__PURE__*/ function(_Param) {\n                parameters_inherits(ArrayParam, _Param);\n                var _super = parameters_createSuper(ArrayParam);\n                /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */ function ArrayParam(name, shortName) {\n                    var _this;\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, ArrayParam);\n                    _this = _super.call(this, name, shortName, process1);\n                    _this.sep = sep;\n                    return _this;\n                }\n                parameters_createClass(ArrayParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            if (this.shortName != null) {\n                                var arrayValue = this.value();\n                                if (isEmpty(arrayValue)) {\n                                    return \"\";\n                                } else if (isString_root_isString_default()(arrayValue)) {\n                                    return \"\".concat(this.shortName, \"_\").concat(arrayValue);\n                                } else {\n                                    var flat = arrayValue.map(function(t) {\n                                        return isFunction_root_isFunction_default()(t.serialize) ? t.serialize() : t;\n                                    }).join(this.sep);\n                                    return \"\".concat(this.shortName, \"_\").concat(flat);\n                                }\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            var _this2 = this;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return this.origValue.map(function(v) {\n                                    return _this2.process(v);\n                                });\n                            } else {\n                                return this.process(this.origValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            if (origValue == null || isArray_root_isArray_default()(origValue)) {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, [\n                                    origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n                return ArrayParam;\n            }(parameters_Param);\n            var parameters_TransformationParam = /*#__PURE__*/ function(_Param2) {\n                parameters_inherits(TransformationParam, _Param2);\n                var _super2 = parameters_createSuper(TransformationParam);\n                /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */ function TransformationParam(name) {\n                    var _this3;\n                    var shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, TransformationParam);\n                    _this3 = _super2.call(this, name, shortName, process1);\n                    _this3.sep = sep;\n                    return _this3;\n                }\n                /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */ parameters_createClass(TransformationParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var _this4 = this;\n                            var result = \"\";\n                            var val = this.value();\n                            if (isEmpty(val)) {\n                                return result;\n                            } // val is an array of strings so join them\n                            if (baseutil_allStrings(val)) {\n                                var joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n                                if (!isEmpty(joined)) {\n                                    // in case options.transformation was not set with an empty string (val != ['']);\n                                    result = \"\".concat(this.shortName, \"_\").concat(joined);\n                                }\n                            } else {\n                                // Convert val to an array of strings\n                                result = val.map(function(t) {\n                                    if (isString_root_isString_default()(t) && !isEmpty(t)) {\n                                        return \"\".concat(_this4.shortName, \"_\").concat(t);\n                                    }\n                                    if (isFunction_root_isFunction_default()(t.serialize)) {\n                                        return t.serialize();\n                                    }\n                                    if (isPlainObject_root_isPlainObject_default()(t) && !isEmpty(t)) {\n                                        return new src_transformation(t).serialize();\n                                    }\n                                    return undefined;\n                                }).filter(function(t) {\n                                    return t;\n                                });\n                            }\n                            return result;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue1) {\n                            this.origValue = origValue1;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, this.origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, [\n                                    this.origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n                return TransformationParam;\n            }(parameters_Param);\n            var number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\n            var offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\n            var parameters_RangeParam = /*#__PURE__*/ function(_Param3) {\n                parameters_inherits(RangeParam, _Param3);\n                var _super3 = parameters_createSuper(RangeParam);\n                /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */ function RangeParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n                    parameters_classCallCheck(this, RangeParam);\n                    return _super3.call(this, name, shortName, process1);\n                }\n                parameters_createClass(RangeParam, null, [\n                    {\n                        key: \"norm_range_value\",\n                        value: function norm_range_value(value) {\n                            var offset = String(value).match(new RegExp(\"^\" + offset_any_pattern + \"$\"));\n                            if (offset) {\n                                var modifier = offset[5] != null ? \"p\" : \"\";\n                                value = (offset[1] || offset[4]) + modifier;\n                            }\n                            return expression.normalize(value);\n                        }\n                    }\n                ]);\n                return RangeParam;\n            }(parameters_Param);\n            var parameters_RawParam = /*#__PURE__*/ function(_Param4) {\n                parameters_inherits(RawParam, _Param4);\n                var _super4 = parameters_createSuper(RawParam);\n                function RawParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, RawParam);\n                    return _super4.call(this, name, shortName, process1);\n                }\n                parameters_createClass(RawParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return this.value();\n                        }\n                    }\n                ]);\n                return RawParam;\n            }(parameters_Param);\n            var parameters_LayerParam = /*#__PURE__*/ function(_Param5) {\n                parameters_inherits(LayerParam, _Param5);\n                var _super5 = parameters_createSuper(LayerParam);\n                function LayerParam() {\n                    parameters_classCallCheck(this, LayerParam);\n                    return _super5.apply(this, arguments);\n                }\n                parameters_createClass(LayerParam, [\n                    {\n                        key: \"value\",\n                        value: // @return [string] layer transformation string\n                        // @private\n                        function value() {\n                            if (this.origValue == null) {\n                                return \"\";\n                            }\n                            var result;\n                            if (this.origValue instanceof layer_layer) {\n                                result = this.origValue;\n                            } else if (isPlainObject_root_isPlainObject_default()(this.origValue)) {\n                                var layerOptions = withCamelCaseKeys(this.origValue);\n                                if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n                                    result = new textlayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"subtitles\") {\n                                    result = new subtitleslayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n                                    result = new fetchlayer(layerOptions);\n                                } else {\n                                    result = new layer_layer(layerOptions);\n                                }\n                            } else if (isString_root_isString_default()(this.origValue)) {\n                                if (/^fetch:.+/.test(this.origValue)) {\n                                    result = new fetchlayer(this.origValue.substr(6));\n                                } else {\n                                    result = this.origValue;\n                                }\n                            } else {\n                                result = \"\";\n                            }\n                            return result.toString();\n                        }\n                    }\n                ], [\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(layer) {\n                            return new textlayer(layer).textStyleIdentifier();\n                        }\n                    }\n                ]);\n                return LayerParam;\n            }(parameters_Param);\n            var parameters_ExpressionParam = /*#__PURE__*/ function(_Param6) {\n                parameters_inherits(ExpressionParam, _Param6);\n                var _super6 = parameters_createSuper(ExpressionParam);\n                function ExpressionParam() {\n                    parameters_classCallCheck(this, ExpressionParam);\n                    return _super6.apply(this, arguments);\n                }\n                parameters_createClass(ExpressionParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return expression.normalize(_get(parameters_getPrototypeOf(ExpressionParam.prototype), \"serialize\", this).call(this));\n                        }\n                    }\n                ]);\n                return ExpressionParam;\n            }(parameters_Param);\n            // CONCATENATED MODULE: ./src/transformation.js\n            function transformation_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return transformation_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, transformation_typeof(obj);\n            }\n            function transformation_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) transformation_setPrototypeOf(subClass, superClass);\n            }\n            function transformation_setPrototypeOf(o, p) {\n                transformation_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return transformation_setPrototypeOf(o, p);\n            }\n            function transformation_createSuper(Derived) {\n                var hasNativeReflectConstruct = transformation_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = transformation_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = transformation_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return transformation_possibleConstructorReturn(this, result);\n                };\n            }\n            function transformation_possibleConstructorReturn(self, call) {\n                if (call && (transformation_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return transformation_assertThisInitialized(self);\n            }\n            function transformation_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function transformation_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function transformation_getPrototypeOf(o) {\n                transformation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return transformation_getPrototypeOf(o);\n            }\n            function transformation_slicedToArray(arr, i) {\n                return transformation_arrayWithHoles(arr) || transformation_iterableToArrayLimit(arr, i) || transformation_unsupportedIterableToArray(arr, i) || transformation_nonIterableRest();\n            }\n            function transformation_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function transformation_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return transformation_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transformation_arrayLikeToArray(o, minLen);\n            }\n            function transformation_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function transformation_iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function transformation_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function transformation_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function transformation_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function transformation_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) transformation_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) transformation_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */ function assignNotNull(target) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                sources.forEach(function(source) {\n                    Object.keys(source).forEach(function(key) {\n                        if (source[key] != null) {\n                            target[key] = source[key];\n                        }\n                    });\n                });\n                return target;\n            }\n            /**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */ var transformation_TransformationBase = /*#__PURE__*/ function() {\n                /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */ function TransformationBase(options) {\n                    transformation_classCallCheck(this, TransformationBase);\n                    /** @private */ /** @private */ var parent, trans;\n                    parent = void 0;\n                    trans = {};\n                    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */ this.toOptions = function(withChain) {\n                        var opt = {};\n                        if (withChain == null) {\n                            withChain = true;\n                        }\n                        Object.keys(trans).forEach(function(key) {\n                            return opt[key] = trans[key].origValue;\n                        });\n                        assignNotNull(opt, this.otherOptions);\n                        if (withChain && !isEmpty(this.chained)) {\n                            var list = this.chained.map(function(tr) {\n                                return tr.toOptions();\n                            });\n                            list.push(opt);\n                            opt = {};\n                            assignNotNull(opt, this.otherOptions);\n                            opt.transformation = list;\n                        }\n                        return opt;\n                    };\n                    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */ this.setParent = function(object) {\n                        parent = object;\n                        if (object != null) {\n                            this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n                        }\n                        return this;\n                    };\n                    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */ this.getParent = function() {\n                        return parent;\n                    }; // Helper methods to create parameter methods\n                    // These methods are defined here because they access `trans` which is\n                    // a private member of `TransformationBase`\n                    /** @protected */ this.param = function(value, name, abbr, defaultValue, process1) {\n                        if (process1 == null) {\n                            if (isFunction_root_isFunction_default()(defaultValue)) {\n                                process1 = defaultValue;\n                            } else {\n                                process1 = identity_root_identity_default.a;\n                            }\n                        }\n                        trans[name] = new parameters_Param(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rawParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RawParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rangeParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RangeParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.arrayParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_ArrayParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.transformationParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_TransformationParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    this.layerParam = function(value, name, abbr) {\n                        trans[name] = new parameters_LayerParam(name, abbr).set(value);\n                        return this;\n                    }; // End Helper methods\n                    /**\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */ this.getValue = function(name) {\n                        var value = trans[name] && trans[name].value();\n                        return value != null ? value : this.otherOptions[name];\n                    };\n                    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */ this.get = function(name) {\n                        return trans[name];\n                    };\n                    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */ this.remove = function(name) {\n                        var temp;\n                        switch(false){\n                            case trans[name] == null:\n                                temp = trans[name];\n                                delete trans[name];\n                                return temp.origValue;\n                            case this.otherOptions[name] == null:\n                                temp = this.otherOptions[name];\n                                delete this.otherOptions[name];\n                                return temp;\n                            default:\n                                return null;\n                        }\n                    };\n                    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */ this.keys = function() {\n                        var key;\n                        return (function() {\n                            var results;\n                            results = [];\n                            for(key in trans){\n                                if (key != null) {\n                                    results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n                                }\n                            }\n                            return results;\n                        })().sort();\n                    };\n                    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */ this.toPlainObject = function() {\n                        var hash, key, list;\n                        hash = {};\n                        for(key in trans){\n                            hash[key] = trans[key].value();\n                            if (isPlainObject_root_isPlainObject_default()(hash[key])) {\n                                hash[key] = cloneDeep_root_cloneDeep_default()(hash[key]);\n                            }\n                        }\n                        if (!isEmpty(this.chained)) {\n                            list = this.chained.map(function(tr) {\n                                return tr.toPlainObject();\n                            });\n                            list.push(hash);\n                            hash = {\n                                transformation: list\n                            };\n                        }\n                        return hash;\n                    };\n                    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */ this.chain = function() {\n                        var names, tr;\n                        names = Object.getOwnPropertyNames(trans);\n                        if (names.length !== 0) {\n                            tr = new this.constructor(this.toOptions(false));\n                            this.resetTransformations();\n                            this.chained.push(tr);\n                        }\n                        return this;\n                    };\n                    this.resetTransformations = function() {\n                        trans = {};\n                        return this;\n                    };\n                    this.otherOptions = {};\n                    this.chained = [];\n                    this.fromOptions(options);\n                }\n                /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */ transformation_createClass(TransformationBase, [\n                    {\n                        key: \"fromOptions\",\n                        value: function fromOptions() {\n                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                            if (options instanceof TransformationBase) {\n                                this.fromTransformation(options);\n                            } else {\n                                if (isString_root_isString_default()(options) || isArray_root_isArray_default()(options)) {\n                                    options = {\n                                        transformation: options\n                                    };\n                                }\n                                options = cloneDeep_root_cloneDeep_default()(options, function(value) {\n                                    if (value instanceof TransformationBase || value instanceof Layer) {\n                                        return new value.clone();\n                                    }\n                                }); // Handling of \"if\" statements precedes other options as it creates a chained transformation\n                                if (options[\"if\"]) {\n                                    this.set(\"if\", options[\"if\"]);\n                                    delete options[\"if\"];\n                                }\n                                for(var key in options){\n                                    var opt = options[key];\n                                    if (opt != null) {\n                                        if (key.match(VAR_NAME_RE)) {\n                                            if (key !== \"$attr\") {\n                                                this.set(\"variable\", key, opt);\n                                            }\n                                        } else {\n                                            this.set(key, opt);\n                                        }\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromTransformation\",\n                        value: function fromTransformation(other) {\n                            var _this = this;\n                            if (other instanceof TransformationBase) {\n                                other.keys().forEach(function(key) {\n                                    return _this.set(key, other.get(key).origValue);\n                                });\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(key) {\n                            var camelKey;\n                            camelKey = camelCase(key);\n                            for(var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                                values[_key2 - 1] = arguments[_key2];\n                            }\n                            if (includes_root_includes_default()(transformation_Transformation.methods, camelKey)) {\n                                this[camelKey].apply(this, values);\n                            } else {\n                                this.otherOptions[key] = values[0];\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"hasLayer\",\n                        value: function hasLayer() {\n                            return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n                            resultArray = this.chained.map(function(tr) {\n                                return tr.serialize();\n                            });\n                            paramList = this.keys();\n                            transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n                            ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n                            variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n                            paramList = difference_root_difference_default()(paramList, [\n                                \"transformation\",\n                                \"if\",\n                                \"variables\"\n                            ]);\n                            vars = [];\n                            transformationList = [];\n                            for(j = 0, len = paramList.length; j < len; j++){\n                                t = paramList[j];\n                                if (t.match(VAR_NAME_RE)) {\n                                    vars.push(t + \"_\" + expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n                                } else {\n                                    transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n                                }\n                            }\n                            switch(false){\n                                case !isString_root_isString_default()(transformations):\n                                    transformationList.push(transformations);\n                                    break;\n                                case !isArray_root_isArray_default()(transformations):\n                                    resultArray = resultArray.concat(transformations);\n                            }\n                            transformationList = function() {\n                                var k, len1, results;\n                                results = [];\n                                for(k = 0, len1 = transformationList.length; k < len1; k++){\n                                    value = transformationList[k];\n                                    if (isArray_root_isArray_default()(value) && !isEmpty(value) || !isArray_root_isArray_default()(value) && value) {\n                                        results.push(value);\n                                    }\n                                }\n                                return results;\n                            }();\n                            transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n                            if (ifParam === \"if_end\") {\n                                transformationList.push(ifParam);\n                            } else if (!isEmpty(ifParam)) {\n                                transformationList.unshift(ifParam);\n                            }\n                            transformationString = compact_root_compact_default()(transformationList).join(this.param_separator);\n                            if (!isEmpty(transformationString)) {\n                                resultArray.push(transformationString);\n                            }\n                            return compact_root_compact_default()(resultArray).join(this.trans_separator);\n                        }\n                    },\n                    {\n                        key: \"toHtmlAttributes\",\n                        value: /**\n     * Returns the attributes for an HTML tag.\n     * @function Cloudinary.toHtmlAttributes\n     * @return PlainObject\n     */ function toHtmlAttributes() {\n                            var _this2 = this;\n                            var attrName, height, options, ref2, ref3, value, width;\n                            options = {};\n                            var snakeCaseKey;\n                            Object.keys(this.otherOptions).forEach(function(key) {\n                                value = _this2.otherOptions[key];\n                                snakeCaseKey = snakeCase(key);\n                                if (!includes_root_includes_default()(transformation_Transformation.PARAM_NAMES, snakeCaseKey) && !includes_root_includes_default()(URL_KEYS, snakeCaseKey)) {\n                                    attrName = /^html_/.test(key) ? key.slice(5) : key;\n                                    options[attrName] = value;\n                                }\n                            }); // convert all \"html_key\" to \"key\" with the same value\n                            this.keys().forEach(function(key) {\n                                if (/^html_/.test(key)) {\n                                    options[camelCase(key.slice(5))] = _this2.getValue(key);\n                                }\n                            });\n                            if (!(this.hasLayer() || this.getValue(\"angle\") || includes_root_includes_default()([\n                                \"fit\",\n                                \"limit\",\n                                \"lfill\"\n                            ], this.getValue(\"crop\")))) {\n                                width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n                                height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n                                if (parseFloat(width) >= 1.0) {\n                                    if (options.width == null) {\n                                        options.width = width;\n                                    }\n                                }\n                                if (parseFloat(height) >= 1.0) {\n                                    if (options.height == null) {\n                                        options.height = height;\n                                    }\n                                }\n                            }\n                            return options;\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: /**\n     * Delegate to the parent (up the call chain) to produce HTML\n     * @function Transformation#toHtml\n     * @return {string} HTML representation of the parent if possible.\n     * @example\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\n     * tag.toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n     */ function toHtml() {\n                            var ref;\n                            return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.toOptions(true));\n                        }\n                    }\n                ], [\n                    {\n                        key: \"listNames\",\n                        value: function listNames() {\n                            return transformation_Transformation.methods;\n                        }\n                    },\n                    {\n                        key: \"isValidParamName\",\n                        value: function isValidParamName(name) {\n                            return transformation_Transformation.methods.indexOf(camelCase(name)) >= 0;\n                        }\n                    }\n                ]);\n                return TransformationBase;\n            }();\n            var VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\n            transformation_TransformationBase.prototype.trans_separator = \"/\";\n            transformation_TransformationBase.prototype.param_separator = \",\";\n            function lastArgCallback(args) {\n                var callback;\n                callback = args != null ? args[args.length - 1] : void 0;\n                if (isFunction_root_isFunction_default()(callback)) {\n                    return callback;\n                } else {\n                    return void 0;\n                }\n            }\n            function processVar(varArray) {\n                var j, len, name, results, v;\n                if (isArray_root_isArray_default()(varArray)) {\n                    results = [];\n                    for(j = 0, len = varArray.length; j < len; j++){\n                        var _varArray$j = transformation_slicedToArray(varArray[j], 2);\n                        name = _varArray$j[0];\n                        v = _varArray$j[1];\n                        results.push(\"\".concat(name, \"_\").concat(expression.normalize(v)));\n                    }\n                    return results;\n                } else {\n                    return varArray;\n                }\n            }\n            function processCustomFunction(_ref) {\n                var function_type = _ref.function_type, source = _ref.source;\n                if (function_type === \"remote\") {\n                    return [\n                        function_type,\n                        btoa(source)\n                    ].join(\":\");\n                } else if (function_type === \"wasm\") {\n                    return [\n                        function_type,\n                        source\n                    ].join(\":\");\n                }\n            }\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */ /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */ var transformation_Transformation = /*#__PURE__*/ function(_TransformationBase) {\n                transformation_inherits(Transformation, _TransformationBase);\n                var _super = transformation_createSuper(Transformation);\n                /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */ function Transformation(options) {\n                    transformation_classCallCheck(this, Transformation);\n                    return _super.call(this, options);\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */ transformation_createClass(Transformation, [\n                    {\n                        key: \"angle\",\n                        value: /*\n      Transformation Parameters\n    */ function angle(value) {\n                            return this.arrayParam(value, \"angle\", \"a\", \".\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"audioCodec\",\n                        value: function audioCodec(value) {\n                            return this.param(value, \"audio_codec\", \"ac\");\n                        }\n                    },\n                    {\n                        key: \"audioFrequency\",\n                        value: function audioFrequency(value) {\n                            return this.param(value, \"audio_frequency\", \"af\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(value) {\n                            return this.param(value, \"aspect_ratio\", \"ar\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"background\",\n                        value: function background(value) {\n                            return this.param(value, \"background\", \"b\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"bitRate\",\n                        value: function bitRate(value) {\n                            return this.param(value, \"bit_rate\", \"br\");\n                        }\n                    },\n                    {\n                        key: \"border\",\n                        value: function border(value) {\n                            return this.param(value, \"border\", \"bo\", function(border) {\n                                if (isPlainObject_root_isPlainObject_default()(border)) {\n                                    border = assign_root_assign_default()({}, {\n                                        color: \"black\",\n                                        width: 2\n                                    }, border);\n                                    return \"\".concat(border.width, \"px_solid_\").concat(parameters_Param.norm_color(border.color));\n                                } else {\n                                    return border;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"color\",\n                        value: function color(value) {\n                            return this.param(value, \"color\", \"co\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"colorSpace\",\n                        value: function colorSpace(value) {\n                            return this.param(value, \"color_space\", \"cs\");\n                        }\n                    },\n                    {\n                        key: \"crop\",\n                        value: function crop(value) {\n                            return this.param(value, \"crop\", \"c\");\n                        }\n                    },\n                    {\n                        key: \"customFunction\",\n                        value: function customFunction(value) {\n                            return this.param(value, \"custom_function\", \"fn\", function() {\n                                return processCustomFunction(value);\n                            });\n                        }\n                    },\n                    {\n                        key: \"customPreFunction\",\n                        value: function customPreFunction(value) {\n                            if (this.get(\"custom_function\")) {\n                                return;\n                            }\n                            return this.rawParam(value, \"custom_function\", \"\", function() {\n                                value = processCustomFunction(value);\n                                return value ? \"fn_pre:\".concat(value) : value;\n                            });\n                        }\n                    },\n                    {\n                        key: \"defaultImage\",\n                        value: function defaultImage(value) {\n                            return this.param(value, \"default_image\", \"d\");\n                        }\n                    },\n                    {\n                        key: \"delay\",\n                        value: function delay(value) {\n                            return this.param(value, \"delay\", \"dl\");\n                        }\n                    },\n                    {\n                        key: \"density\",\n                        value: function density(value) {\n                            return this.param(value, \"density\", \"dn\");\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(value) {\n                            return this.rangeParam(value, \"duration\", \"du\");\n                        }\n                    },\n                    {\n                        key: \"dpr\",\n                        value: function dpr(value) {\n                            return this.param(value, \"dpr\", \"dpr\", function(dpr) {\n                                dpr = dpr.toString();\n                                if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n                                    return dpr + \".0\";\n                                } else {\n                                    return expression.normalize(dpr);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"effect\",\n                        value: function effect(value) {\n                            return this.arrayParam(value, \"effect\", \"e\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"else\",\n                        value: function _else() {\n                            return this[\"if\"](\"else\");\n                        }\n                    },\n                    {\n                        key: \"endIf\",\n                        value: function endIf() {\n                            return this[\"if\"](\"end\");\n                        }\n                    },\n                    {\n                        key: \"endOffset\",\n                        value: function endOffset(value) {\n                            return this.rangeParam(value, \"end_offset\", \"eo\");\n                        }\n                    },\n                    {\n                        key: \"fallbackContent\",\n                        value: function fallbackContent(value) {\n                            return this.param(value, \"fallback_content\");\n                        }\n                    },\n                    {\n                        key: \"fetchFormat\",\n                        value: function fetchFormat(value) {\n                            return this.param(value, \"fetch_format\", \"f\");\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            return this.param(value, \"format\");\n                        }\n                    },\n                    {\n                        key: \"flags\",\n                        value: function flags(value) {\n                            return this.arrayParam(value, \"flags\", \"fl\", \".\");\n                        }\n                    },\n                    {\n                        key: \"gravity\",\n                        value: function gravity(value) {\n                            return this.param(value, \"gravity\", \"g\");\n                        }\n                    },\n                    {\n                        key: \"fps\",\n                        value: function fps(value) {\n                            return this.param(value, \"fps\", \"fps\", function(fps) {\n                                if (isString_root_isString_default()(fps)) {\n                                    return fps;\n                                } else if (isArray_root_isArray_default()(fps)) {\n                                    return fps.join(\"-\");\n                                } else {\n                                    return fps;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(value) {\n                            var _this3 = this;\n                            return this.param(value, \"height\", \"h\", function() {\n                                if (_this3.getValue(\"crop\") || _this3.getValue(\"overlay\") || _this3.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"htmlHeight\",\n                        value: function htmlHeight(value) {\n                            return this.param(value, \"html_height\");\n                        }\n                    },\n                    {\n                        key: \"htmlWidth\",\n                        value: function htmlWidth(value) {\n                            return this.param(value, \"html_width\");\n                        }\n                    },\n                    {\n                        key: \"if\",\n                        value: function _if() {\n                            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n                            var i, ifVal, j, ref, trIf, trRest;\n                            switch(value){\n                                case \"else\":\n                                    this.chain();\n                                    return this.param(value, \"if\", \"if\");\n                                case \"end\":\n                                    this.chain();\n                                    for(i = j = ref = this.chained.length - 1; j >= 0; i = j += -1){\n                                        ifVal = this.chained[i].getValue(\"if\");\n                                        if (ifVal === \"end\") {\n                                            break;\n                                        } else if (ifVal != null) {\n                                            trIf = Transformation[\"new\"]()[\"if\"](ifVal);\n                                            this.chained[i].remove(\"if\");\n                                            trRest = this.chained[i];\n                                            this.chained[i] = Transformation[\"new\"]().transformation([\n                                                trIf,\n                                                trRest\n                                            ]);\n                                            if (ifVal !== \"else\") {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    return this.param(value, \"if\", \"if\");\n                                case \"\":\n                                    return condition[\"new\"]().setParent(this);\n                                default:\n                                    return this.param(value, \"if\", \"if\", function(value) {\n                                        return condition[\"new\"](value).toString();\n                                    });\n                            }\n                        }\n                    },\n                    {\n                        key: \"keyframeInterval\",\n                        value: function keyframeInterval(value) {\n                            return this.param(value, \"keyframe_interval\", \"ki\");\n                        }\n                    },\n                    {\n                        key: \"ocr\",\n                        value: function ocr(value) {\n                            return this.param(value, \"ocr\", \"ocr\");\n                        }\n                    },\n                    {\n                        key: \"offset\",\n                        value: function offset(value) {\n                            var end_o, start_o;\n                            var _ref2 = isFunction_root_isFunction_default()(value != null ? value.split : void 0) ? value.split(\"..\") : isArray_root_isArray_default()(value) ? value : [\n                                null,\n                                null\n                            ];\n                            var _ref3 = transformation_slicedToArray(_ref2, 2);\n                            start_o = _ref3[0];\n                            end_o = _ref3[1];\n                            if (start_o != null) {\n                                this.startOffset(start_o);\n                            }\n                            if (end_o != null) {\n                                return this.endOffset(end_o);\n                            }\n                        }\n                    },\n                    {\n                        key: \"opacity\",\n                        value: function opacity(value) {\n                            return this.param(value, \"opacity\", \"o\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"overlay\",\n                        value: function overlay(value) {\n                            return this.layerParam(value, \"overlay\", \"l\");\n                        }\n                    },\n                    {\n                        key: \"page\",\n                        value: function page(value) {\n                            return this.param(value, \"page\", \"pg\");\n                        }\n                    },\n                    {\n                        key: \"poster\",\n                        value: function poster(value) {\n                            return this.param(value, \"poster\");\n                        }\n                    },\n                    {\n                        key: \"prefix\",\n                        value: function prefix(value) {\n                            return this.param(value, \"prefix\", \"p\");\n                        }\n                    },\n                    {\n                        key: \"quality\",\n                        value: function quality(value) {\n                            return this.param(value, \"quality\", \"q\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"radius\",\n                        value: function radius(value) {\n                            return this.arrayParam(value, \"radius\", \"r\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"rawTransformation\",\n                        value: function rawTransformation(value) {\n                            return this.rawParam(value, \"raw_transformation\");\n                        }\n                    },\n                    {\n                        key: \"size\",\n                        value: function size(value) {\n                            var height, width;\n                            if (isFunction_root_isFunction_default()(value != null ? value.split : void 0)) {\n                                var _value$split = value.split(\"x\");\n                                var _value$split2 = transformation_slicedToArray(_value$split, 2);\n                                width = _value$split2[0];\n                                height = _value$split2[1];\n                                this.width(width);\n                                return this.height(height);\n                            }\n                        }\n                    },\n                    {\n                        key: \"sourceTypes\",\n                        value: function sourceTypes(value) {\n                            return this.param(value, \"source_types\");\n                        }\n                    },\n                    {\n                        key: \"sourceTransformation\",\n                        value: function sourceTransformation(value) {\n                            return this.param(value, \"source_transformation\");\n                        }\n                    },\n                    {\n                        key: \"startOffset\",\n                        value: function startOffset(value) {\n                            return this.rangeParam(value, \"start_offset\", \"so\");\n                        }\n                    },\n                    {\n                        key: \"streamingProfile\",\n                        value: function streamingProfile(value) {\n                            return this.param(value, \"streaming_profile\", \"sp\");\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(value) {\n                            return this.transformationParam(value, \"transformation\", \"t\");\n                        }\n                    },\n                    {\n                        key: \"underlay\",\n                        value: function underlay(value) {\n                            return this.layerParam(value, \"underlay\", \"u\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return this.param(value, name, name);\n                        }\n                    },\n                    {\n                        key: \"variables\",\n                        value: function variables(values) {\n                            return this.arrayParam(values, \"variables\");\n                        }\n                    },\n                    {\n                        key: \"videoCodec\",\n                        value: function videoCodec(value) {\n                            return this.param(value, \"video_codec\", \"vc\", parameters_Param.process_video_params);\n                        }\n                    },\n                    {\n                        key: \"videoSampling\",\n                        value: function videoSampling(value) {\n                            return this.param(value, \"video_sampling\", \"vs\");\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(value) {\n                            var _this4 = this;\n                            return this.param(value, \"width\", \"w\", function() {\n                                if (_this4.getValue(\"crop\") || _this4.getValue(\"overlay\") || _this4.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"x\",\n                        value: function x(value) {\n                            return this.param(value, \"x\", \"x\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"y\",\n                        value: function y(value) {\n                            return this.param(value, \"y\", \"y\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"zoom\",\n                        value: function zoom(value) {\n                            return this.param(value, \"zoom\", \"z\", expression.normalize);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new Transformation(options);\n                        }\n                    }\n                ]);\n                return Transformation;\n            }(transformation_TransformationBase);\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */ transformation_Transformation.methods = [\n                \"angle\",\n                \"audioCodec\",\n                \"audioFrequency\",\n                \"aspectRatio\",\n                \"background\",\n                \"bitRate\",\n                \"border\",\n                \"color\",\n                \"colorSpace\",\n                \"crop\",\n                \"customFunction\",\n                \"customPreFunction\",\n                \"defaultImage\",\n                \"delay\",\n                \"density\",\n                \"duration\",\n                \"dpr\",\n                \"effect\",\n                \"else\",\n                \"endIf\",\n                \"endOffset\",\n                \"fallbackContent\",\n                \"fetchFormat\",\n                \"format\",\n                \"flags\",\n                \"gravity\",\n                \"fps\",\n                \"height\",\n                \"htmlHeight\",\n                \"htmlWidth\",\n                \"if\",\n                \"keyframeInterval\",\n                \"ocr\",\n                \"offset\",\n                \"opacity\",\n                \"overlay\",\n                \"page\",\n                \"poster\",\n                \"prefix\",\n                \"quality\",\n                \"radius\",\n                \"rawTransformation\",\n                \"size\",\n                \"sourceTypes\",\n                \"sourceTransformation\",\n                \"startOffset\",\n                \"streamingProfile\",\n                \"transformation\",\n                \"underlay\",\n                \"variable\",\n                \"variables\",\n                \"videoCodec\",\n                \"videoSampling\",\n                \"width\",\n                \"x\",\n                \"y\",\n                \"zoom\"\n            ];\n            /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */ transformation_Transformation.PARAM_NAMES = transformation_Transformation.methods.map(snakeCase).concat(src_configuration.CONFIG_PARAMS);\n            /* harmony default export */ var src_transformation = transformation_Transformation;\n            // CONCATENATED MODULE: ./src/tags/htmltag.js\n            function htmltag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function htmltag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function htmltag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) htmltag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) htmltag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Generic HTML tag\n * Depends on 'transformation', 'util'\n */ /**\n * Represents an HTML (DOM) tag\n * @constructor HtmlTag\n * @param {string} name - the name of the tag\n * @param {string} [publicId]\n * @param {Object} options\n * @example tag = new HtmlTag( 'div', { 'width': 10})\n */ var htmltag_HtmlTag = /*#__PURE__*/ function() {\n                function HtmlTag(name, publicId, options) {\n                    htmltag_classCallCheck(this, HtmlTag);\n                    var transformation;\n                    this.name = name;\n                    this.publicId = publicId;\n                    if (options == null) {\n                        if (isPlainObject_root_isPlainObject_default()(publicId)) {\n                            options = publicId;\n                            this.publicId = void 0;\n                        } else {\n                            options = {};\n                        }\n                    }\n                    transformation = new src_transformation(options);\n                    transformation.setParent(this);\n                    this.transformation = function() {\n                        return transformation;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * Creates a new instance of an HTML (DOM) tag\n   * @function HtmlTag.new\n   * @param {string} name - the name of the tag\n   * @param {string} [publicId]\n   * @param {Object} options\n   * @return {HtmlTag}\n   * @example tag = HtmlTag.new( 'div', { 'width': 10})\n   */ htmltag_createClass(HtmlTag, [\n                    {\n                        key: \"htmlAttrs\",\n                        value: /**\n     * combine key and value from the `attr` to generate an HTML tag attributes string.\n     * `Transformation::toHtmlTagOptions` is used to filter out transformation and configuration keys.\n     * @protected\n     * @param {Object} attrs\n     * @return {string} the attributes in the format `'key1=\"value1\" key2=\"value2\"'`\n     * @ignore\n     */ function htmlAttrs(attrs) {\n                            var key, pairs, value;\n                            return pairs = (function() {\n                                var results;\n                                results = [];\n                                for(key in attrs){\n                                    value = escapeQuotes(attrs[key]);\n                                    if (value) {\n                                        results.push(htmltag_toAttribute(key, value));\n                                    }\n                                }\n                                return results;\n                            })().sort().join(\" \");\n                        }\n                    },\n                    {\n                        key: \"getOptions\",\n                        value: function getOptions() {\n                            return this.transformation().toOptions();\n                        }\n                    },\n                    {\n                        key: \"getOption\",\n                        value: function getOption(name) {\n                            return this.transformation().getValue(name);\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            // The attributes are be computed from the options every time this method is invoked.\n                            var htmlAttributes = this.transformation().toHtmlAttributes();\n                            Object.keys(htmlAttributes).forEach(function(key) {\n                                if (isPlainObject_root_isPlainObject_default()(htmlAttributes[key])) {\n                                    delete htmlAttributes[key];\n                                }\n                            });\n                            if (htmlAttributes.attributes) {\n                                // Currently HTML attributes are defined both at the top level and under 'attributes'\n                                merge_root_merge_default()(htmlAttributes, htmlAttributes.attributes);\n                                delete htmlAttributes.attributes;\n                            }\n                            return htmlAttributes;\n                        }\n                    },\n                    {\n                        key: \"setAttr\",\n                        value: function setAttr(name, value) {\n                            this.transformation().set(\"html_\".concat(name), value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getAttr\",\n                        value: function getAttr(name) {\n                            return this.attributes()[\"html_\".concat(name)] || this.attributes()[name];\n                        }\n                    },\n                    {\n                        key: \"removeAttr\",\n                        value: function removeAttr(name) {\n                            var ref;\n                            return (ref = this.transformation().remove(\"html_\".concat(name))) != null ? ref : this.transformation().remove(name);\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"openTag\",\n                        value: function openTag() {\n                            var tag = \"<\" + this.name;\n                            var htmlAttrs = this.htmlAttrs(this.attributes());\n                            if (htmlAttrs && htmlAttrs.length > 0) {\n                                tag += \" \" + htmlAttrs;\n                            }\n                            return tag + \">\";\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\".concat(this.name, \">\");\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: function toHtml() {\n                            return this.openTag() + this.content() + this.closeTag();\n                        }\n                    },\n                    {\n                        key: \"toDOM\",\n                        value: function toDOM() {\n                            var element, name, ref, value;\n                            if (!isFunction_root_isFunction_default()(typeof document !== \"undefined\" && document !== null ? document.createElement : void 0)) {\n                                throw \"Can't create DOM if document is not present!\";\n                            }\n                            element = document.createElement(this.name);\n                            ref = this.attributes();\n                            for(name in ref){\n                                value = ref[name];\n                                element.setAttribute(name, value);\n                            }\n                            return element;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(name, publicId, options) {\n                            return new this(name, publicId, options);\n                        }\n                    },\n                    {\n                        key: \"isResponsive\",\n                        value: function isResponsive(tag, responsiveClass) {\n                            var dataSrc;\n                            dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                            return lodash_hasClass(tag, responsiveClass) && /\\bw_auto\\b/.exec(dataSrc);\n                        }\n                    }\n                ]);\n                return HtmlTag;\n            }();\n            ;\n            /**\n * Represent the given key and value as an HTML attribute.\n * @function toAttribute\n * @protected\n * @param {string} key - attribute name\n * @param {*|boolean} value - the value of the attribute. If the value is boolean `true`, return the key only.\n * @returns {string} the attribute\n *\n */ function htmltag_toAttribute(key, value) {\n                if (!value) {\n                    return void 0;\n                } else if (value === true) {\n                    return key;\n                } else {\n                    return \"\".concat(key, '=\"').concat(value, '\"');\n                }\n            }\n            /**\n * If given value is a string, replaces quotes with character entities (&#34;, &#39;)\n * @param value - value to change\n * @returns {*} changed value\n */ function escapeQuotes(value) {\n                return isString_root_isString_default()(value) ? value.replace('\"', \"&#34;\").replace(\"'\", \"&#39;\") : value;\n            }\n            /* harmony default export */ var htmltag = htmltag_HtmlTag;\n            // CONCATENATED MODULE: ./src/url.js\n            var _excluded = [\n                \"placeholder\",\n                \"accessibility\"\n            ];\n            function _objectWithoutProperties(source, excluded) {\n                if (source == null) return {};\n                var target = _objectWithoutPropertiesLoose(source, excluded);\n                var key, i;\n                if (Object.getOwnPropertySymbols) {\n                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n                    for(i = 0; i < sourceSymbolKeys.length; i++){\n                        key = sourceSymbolKeys[i];\n                        if (excluded.indexOf(key) >= 0) continue;\n                        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                        target[key] = source[key];\n                    }\n                }\n                return target;\n            }\n            function _objectWithoutPropertiesLoose(source, excluded) {\n                if (source == null) return {};\n                var target = {};\n                var sourceKeys = Object.keys(source);\n                var key, i;\n                for(i = 0; i < sourceKeys.length; i++){\n                    key = sourceKeys[i];\n                    if (excluded.indexOf(key) >= 0) continue;\n                    target[key] = source[key];\n                }\n                return target;\n            }\n            /**\n * Adds protocol, host, pathname prefixes to given string\n * @param str\n * @returns {string}\n */ function makeUrl(str) {\n                var prefix = document.location.protocol + \"//\" + document.location.host;\n                if (str[0] === \"?\") {\n                    prefix += document.location.pathname;\n                } else if (str[0] !== \"/\") {\n                    prefix += document.location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n                }\n                return prefix + str;\n            }\n            /**\n * Check is given string is a url\n * @param str\n * @returns {boolean}\n */ function isUrl(str) {\n                return str ? !!str.match(/^https?:\\//) : false;\n            } // Produce a number between 1 and 5 to be used for cdn sub domains designation\n            function cdnSubdomainNumber(publicId) {\n                return src_crc32(publicId) % 5 + 1;\n            }\n            /**\n * Removes signature from options and returns the signature\n * Makes sure signature is empty or of this format: s--signature--\n * @param {object} options\n * @returns {string} the formatted signature\n */ function handleSignature(options) {\n                var signature = options.signature;\n                var isFormatted = !signature || signature.indexOf(\"s--\") === 0 && signature.substr(-2) === \"--\";\n                delete options.signature;\n                return isFormatted ? signature : \"s--\".concat(signature, \"--\");\n            }\n            /**\n * Create the URL prefix for Cloudinary resources.\n * @param {string} publicId the resource public ID\n * @param {object} options additional options\n * @param {string} options.cloud_name - the cloud name.\n * @param {boolean} [options.cdn_subdomain=false] - Whether to automatically build URLs with\n *  multiple CDN sub-domains.\n * @param {string} [options.private_cdn] - Boolean (default: false). Should be set to true for Advanced plan's users\n *  that have a private CDN distribution.\n * @param {string} [options.protocol=\"http://\"] - the URI protocol to use. If options.secure is true,\n *  the value is overridden to \"https://\"\n * @param {string} [options.secure_distribution] - The domain name of the CDN distribution to use for building HTTPS URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution.\n * @param {string} [options.cname] - Custom domain name to use for building HTTP URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution and a custom CNAME.\n * @param {boolean} [options.secure_cdn_subdomain=true] - When options.secure is true and this parameter is false,\n *  the subdomain is set to \"res\".\n * @param {boolean} [options.secure=false] - Force HTTPS URLs of images even if embedded in non-secure HTTP pages.\n *  When this value is true, options.secure_distribution will be used as host if provided, and options.protocol is set\n *  to \"https://\".\n * @returns {string} the URL prefix for the resource.\n * @private\n */ function handlePrefix(publicId, options) {\n                if (options.cloud_name && options.cloud_name[0] === \"/\") {\n                    return \"/res\" + options.cloud_name;\n                } // defaults\n                var protocol = \"http://\";\n                var cdnPart = \"\";\n                var subdomain = \"res\";\n                var host = \".cloudinary.com\";\n                var path = \"/\" + options.cloud_name; // modifications\n                if (options.protocol) {\n                    protocol = options.protocol + \"//\";\n                }\n                if (options.private_cdn) {\n                    cdnPart = options.cloud_name + \"-\";\n                    path = \"\";\n                }\n                if (options.cdn_subdomain) {\n                    subdomain = \"res-\" + cdnSubdomainNumber(publicId);\n                }\n                if (options.secure) {\n                    protocol = \"https://\";\n                    if (options.secure_cdn_subdomain === false) {\n                        subdomain = \"res\";\n                    }\n                    if (options.secure_distribution != null && options.secure_distribution !== OLD_AKAMAI_SHARED_CDN && options.secure_distribution !== SHARED_CDN) {\n                        cdnPart = \"\";\n                        subdomain = \"\";\n                        host = options.secure_distribution;\n                    }\n                } else if (options.cname) {\n                    protocol = \"http://\";\n                    cdnPart = \"\";\n                    subdomain = options.cdn_subdomain ? \"a\" + (src_crc32(publicId) % 5 + 1) + \".\" : \"\";\n                    host = options.cname;\n                }\n                return [\n                    protocol,\n                    cdnPart,\n                    subdomain,\n                    host,\n                    path\n                ].join(\"\");\n            }\n            /**\n * Return the resource type and action type based on the given configuration\n * @function Cloudinary#handleResourceType\n * @param {Object|string} resource_type\n * @param {string} [type='upload']\n * @param {string} [url_suffix]\n * @param {boolean} [use_root_path]\n * @param {boolean} [shorten]\n * @returns {string} resource_type/type\n * @ignore\n */ function handleResourceType(_ref) {\n                var _ref$resource_type = _ref.resource_type, resource_type = _ref$resource_type === void 0 ? \"image\" : _ref$resource_type, _ref$type = _ref.type, type = _ref$type === void 0 ? \"upload\" : _ref$type, url_suffix = _ref.url_suffix, use_root_path = _ref.use_root_path, shorten = _ref.shorten;\n                var options, resourceType = resource_type;\n                if (isPlainObject_root_isPlainObject_default()(resourceType)) {\n                    options = resourceType;\n                    resourceType = options.resource_type;\n                    type = options.type;\n                    shorten = options.shorten;\n                }\n                if (type == null) {\n                    type = \"upload\";\n                }\n                if (url_suffix != null) {\n                    resourceType = SEO_TYPES[\"\".concat(resourceType, \"/\").concat(type)];\n                    type = null;\n                    if (resourceType == null) {\n                        throw new Error(\"URL Suffix only supported for \".concat(Object.keys(SEO_TYPES).join(\", \")));\n                    }\n                }\n                if (use_root_path) {\n                    if (resourceType === \"image\" && type === \"upload\" || resourceType === \"images\") {\n                        resourceType = null;\n                        type = null;\n                    } else {\n                        throw new Error(\"Root path only supported for image/upload\");\n                    }\n                }\n                if (shorten && resourceType === \"image\" && type === \"upload\") {\n                    resourceType = \"iu\";\n                    type = null;\n                }\n                return [\n                    resourceType,\n                    type\n                ].join(\"/\");\n            }\n            /**\n * Encode publicId\n * @param publicId\n * @returns {string} encoded publicId\n */ function encodePublicId(publicId) {\n                return encodeURIComponent(publicId).replace(/%3A/g, \":\").replace(/%2F/g, \"/\");\n            }\n            /**\n * Encode and format publicId\n * @param publicId\n * @param options\n * @returns {string} publicId\n */ function formatPublicId(publicId, options) {\n                if (isUrl(publicId)) {\n                    publicId = encodePublicId(publicId);\n                } else {\n                    try {\n                        // Make sure publicId is URI encoded.\n                        publicId = decodeURIComponent(publicId);\n                    } catch (error) {}\n                    publicId = encodePublicId(publicId);\n                    if (options.url_suffix) {\n                        publicId = publicId + \"/\" + options.url_suffix;\n                    }\n                    if (options.format) {\n                        if (!options.trust_public_id) {\n                            publicId = publicId.replace(/\\.(jpg|png|gif|webp)$/, \"\");\n                        }\n                        publicId = publicId + \".\" + options.format;\n                    }\n                }\n                return publicId;\n            }\n            /**\n * Get any error with url options\n * @param options\n * @returns {string} if error, otherwise return undefined\n */ function validate(options) {\n                var cloud_name = options.cloud_name, url_suffix = options.url_suffix;\n                if (!cloud_name) {\n                    return \"Unknown cloud_name\";\n                }\n                if (url_suffix && url_suffix.match(/[\\.\\/]/)) {\n                    return \"url_suffix should not include . or /\";\n                }\n            }\n            /**\n * Get version part of the url\n * @param publicId\n * @param options\n * @returns {string}\n */ function handleVersion(publicId, options) {\n                // force_version param means to make sure there is a version in the url (Default is true)\n                var isForceVersion = options.force_version || typeof options.force_version === \"undefined\"; // Is version included in publicId or in options, or publicId is a url (doesn't need version)\n                var isVersionExist = publicId.indexOf(\"/\") < 0 || publicId.match(/^v[0-9]+/) || isUrl(publicId) || options.version;\n                if (isForceVersion && !isVersionExist) {\n                    options.version = 1;\n                }\n                return options.version ? \"v\".concat(options.version) : \"\";\n            }\n            /**\n * Get final transformation component for url string\n * @param options\n * @returns {string}\n */ function handleTransformation(options) {\n                var _ref2 = options || {}, placeholder = _ref2.placeholder, accessibility = _ref2.accessibility, otherOptions = _objectWithoutProperties(_ref2, _excluded);\n                var result = new src_transformation(otherOptions); // Append accessibility transformations\n                if (accessibility && ACCESSIBILITY_MODES[accessibility]) {\n                    result.chain().effect(ACCESSIBILITY_MODES[accessibility]);\n                } // Append placeholder transformations\n                if (placeholder) {\n                    if (placeholder === \"predominant-color\" && result.getValue(\"width\") && result.getValue(\"height\")) {\n                        placeholder += \"-pixel\";\n                    }\n                    var placeholderTransformations = PLACEHOLDER_IMAGE_MODES[placeholder] || PLACEHOLDER_IMAGE_MODES.blur;\n                    placeholderTransformations.forEach(function(t) {\n                        return result.chain().transformation(t);\n                    });\n                }\n                return result.serialize();\n            }\n            /**\n * If type is 'fetch', update publicId to be a url\n * @param publicId\n * @param type\n * @returns {string}\n */ function preparePublicId(publicId, _ref3) {\n                var type = _ref3.type;\n                return !isUrl(publicId) && type === \"fetch\" ? makeUrl(publicId) : publicId;\n            }\n            /**\n * Generate url string\n * @param publicId\n * @param options\n * @returns {string} final url\n */ function urlString(publicId, options) {\n                if (isUrl(publicId) && (options.type === \"upload\" || options.type === \"asset\")) {\n                    return publicId;\n                }\n                var version = handleVersion(publicId, options);\n                var transformationString = handleTransformation(options);\n                var prefix = handlePrefix(publicId, options);\n                var signature = handleSignature(options);\n                var resourceType = handleResourceType(options);\n                publicId = formatPublicId(publicId, options);\n                return compact_root_compact_default()([\n                    prefix,\n                    resourceType,\n                    signature,\n                    transformationString,\n                    version,\n                    publicId\n                ]).join(\"/\").replace(/([^:])\\/+/g, \"$1/\") // replace '///' with '//'\n                .replace(\" \", \"%20\");\n            }\n            /**\n * Merge options and config with defaults\n * update options fetch_format according to 'type' param\n * @param options\n * @param config\n * @returns {*} updated options\n */ function prepareOptions(options, config) {\n                if (options instanceof src_transformation) {\n                    options = options.toOptions();\n                }\n                options = defaults({}, options, config, DEFAULT_IMAGE_PARAMS);\n                if (options.type === \"fetch\") {\n                    options.fetch_format = options.fetch_format || options.format;\n                }\n                return options;\n            }\n            /**\n * Generates a URL for any asset in your Media library.\n * @function url\n * @ignore\n * @param {string} publicId - The public ID of the media asset.\n * @param {Object} [options={}] - The {@link Transformation} parameters to include in the URL.\n * @param {object} [config={}] - URL configuration parameters\n * @param {type} [options.type='upload'] - The asset's storage type.\n *  For details on all fetch types, see\n * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n *  target=\"_blank\">Fetch types</a>.\n * @param {Object} [options.resource_type='image'] - The type of asset. <p>Possible values:<br/>\n *  - `image`<br/>\n *  - `video`<br/>\n *  - `raw`\n * @param {signature} [options.signature='s--12345678--'] - The signature component of a\n *  signed delivery URL of the format: /s--SIGNATURE--/.\n *  For details on signatures, see\n * <a href=\"https://cloudinary.com/documentation/signatures\" target=\"_blank\">Signatures</a>.\n * @return {string} The media asset URL.\n * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n *  Available image transformations</a>\n * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n *  Available video transformations</a>\n */ function url_url(publicId) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                if (!publicId) {\n                    return publicId;\n                }\n                options = prepareOptions(options, config);\n                publicId = preparePublicId(publicId, options);\n                var error = validate(options);\n                if (error) {\n                    throw error;\n                }\n                var resultUrl = urlString(publicId, options);\n                if (options.urlAnalytics) {\n                    var analyticsOptions = getAnalyticsOptions(options);\n                    var sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions); // url might already have a '?' query param\n                    var appender = \"?\";\n                    if (resultUrl.indexOf(\"?\") >= 0) {\n                        appender = \"&\";\n                    }\n                    resultUrl = \"\".concat(resultUrl).concat(appender, \"_a=\").concat(sdkAnalyticsSignature);\n                }\n                if (options.auth_token) {\n                    var _appender = resultUrl.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\n                    resultUrl = \"\".concat(resultUrl).concat(_appender, \"__cld_token__=\").concat(options.auth_token);\n                }\n                return resultUrl;\n            }\n            ;\n            // CONCATENATED MODULE: ./src/util/generateBreakpoints.js\n            function generateBreakpoints_slicedToArray(arr, i) {\n                return generateBreakpoints_arrayWithHoles(arr) || generateBreakpoints_iterableToArrayLimit(arr, i) || generateBreakpoints_unsupportedIterableToArray(arr, i) || generateBreakpoints_nonIterableRest();\n            }\n            function generateBreakpoints_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function generateBreakpoints_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return generateBreakpoints_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return generateBreakpoints_arrayLikeToArray(o, minLen);\n            }\n            function generateBreakpoints_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function generateBreakpoints_iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function generateBreakpoints_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            /**\n * Helper function. Gets or populates srcset breakpoints using provided parameters\n * Either the breakpoints or min_width, max_width, max_images must be provided.\n *\n * @private\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\n *\n * @return {number[]} Array of breakpoints\n *\n */ function generateBreakpoints(srcset) {\n                var breakpoints = srcset.breakpoints || [];\n                if (breakpoints.length) {\n                    return breakpoints;\n                }\n                var _map = [\n                    srcset.min_width,\n                    srcset.max_width,\n                    srcset.max_images\n                ].map(Number), _map2 = generateBreakpoints_slicedToArray(_map, 3), min_width = _map2[0], max_width = _map2[1], max_images = _map2[2];\n                if ([\n                    min_width,\n                    max_width,\n                    max_images\n                ].some(isNaN)) {\n                    throw \"Either (min_width, max_width, max_images) \" + \"or breakpoints must be provided to the image srcset attribute\";\n                }\n                if (min_width > max_width) {\n                    throw \"min_width must be less than max_width\";\n                }\n                if (max_images <= 0) {\n                    throw \"max_images must be a positive integer\";\n                } else if (max_images === 1) {\n                    min_width = max_width;\n                }\n                var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\n                for(var current = min_width; current < max_width; current += stepSize){\n                    breakpoints.push(current);\n                }\n                breakpoints.push(max_width);\n                return breakpoints;\n            }\n            // CONCATENATED MODULE: ./src/util/srcsetUtils.js\n            var srcsetUtils_isEmpty = isEmpty;\n            /**\n * Options used to generate the srcset attribute.\n * @typedef {object} srcset\n * @property {(number[]|string[])}   [breakpoints] An array of breakpoints.\n * @property {number}                [min_width]   Minimal width of the srcset images.\n * @property {number}                [max_width]   Maximal width of the srcset images.\n * @property {number}                [max_images]  Number of srcset images to generate.\n * @property {object|string}         [transformation] The transformation to use in the srcset urls.\n * @property {boolean}               [sizes] Whether to calculate and add the sizes attribute.\n */ /**\n * Helper function. Generates a single srcset item url\n *\n * @private\n * @param {string} public_id  Public ID of the resource.\n * @param {number} width      Width in pixels of the srcset item.\n * @param {object|string} transformation\n * @param {object} options    Additional options.\n *\n * @return {string} Resulting URL of the item\n */ function scaledUrl(public_id, width, transformation) {\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                var configParams = extractUrlParams(options);\n                transformation = transformation || options;\n                configParams.raw_transformation = new src_transformation([\n                    merge_root_merge_default.a({}, transformation),\n                    {\n                        crop: \"scale\",\n                        width: width\n                    }\n                ]).toString();\n                return url_url(public_id, configParams);\n            }\n            /**\n * If cache is enabled, get the breakpoints from the cache. If the values were not found in the cache,\n * or cache is not enabled, generate the values.\n * @param {srcset} srcset The srcset configuration parameters\n * @param {string} public_id\n * @param {object} options\n * @return {*|Array}\n */ function getOrGenerateBreakpoints(public_id) {\n                var srcset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return generateBreakpoints(srcset);\n            }\n            /**\n * Helper function. Generates srcset attribute value of the HTML img tag\n * @private\n *\n * @param {string} public_id  Public ID of the resource\n * @param {number[]} breakpoints An array of breakpoints (in pixels)\n * @param {object} transformation The transformation\n * @param {object} options Includes html tag options, transformation options\n * @return {string} Resulting srcset attribute value\n */ function generateSrcsetAttribute(public_id, breakpoints, transformation, options) {\n                options = cloneDeep_root_cloneDeep_default.a(options);\n                patchFetchFormat(options);\n                return breakpoints.map(function(width) {\n                    return \"\".concat(scaledUrl(public_id, width, transformation, options), \" \").concat(width, \"w\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates sizes attribute value of the HTML img tag\n * @private\n * @param {number[]} breakpoints An array of breakpoints.\n * @return {string} Resulting sizes attribute value\n */ function generateSizesAttribute(breakpoints) {\n                if (breakpoints == null) {\n                    return \"\";\n                }\n                return breakpoints.map(function(width) {\n                    return \"(max-width: \".concat(width, \"px) \").concat(width, \"px\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates srcset and sizes attributes of the image tag\n *\n * Generated attributes are added to attributes argument\n *\n * @private\n * @param {string}    publicId  The public ID of the resource\n * @param {object}    attributes Existing HTML attributes.\n * @param {srcset}    srcsetData\n * @param {object}    options    Additional options.\n *\n * @return array The responsive attributes\n */ function generateImageResponsiveAttributes(publicId) {\n                var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var srcsetData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                // Create both srcset and sizes here to avoid fetching breakpoints twice\n                var responsiveAttributes = {};\n                if (srcsetUtils_isEmpty(srcsetData)) {\n                    return responsiveAttributes;\n                }\n                var generateSizes = !attributes.sizes && srcsetData.sizes === true;\n                var generateSrcset = !attributes.srcset;\n                if (generateSrcset || generateSizes) {\n                    var breakpoints = getOrGenerateBreakpoints(publicId, srcsetData, options);\n                    if (generateSrcset) {\n                        var transformation = srcsetData.transformation;\n                        var srcsetAttr = generateSrcsetAttribute(publicId, breakpoints, transformation, options);\n                        if (!srcsetUtils_isEmpty(srcsetAttr)) {\n                            responsiveAttributes.srcset = srcsetAttr;\n                        }\n                    }\n                    if (generateSizes) {\n                        var sizesAttr = generateSizesAttribute(breakpoints);\n                        if (!srcsetUtils_isEmpty(sizesAttr)) {\n                            responsiveAttributes.sizes = sizesAttr;\n                        }\n                    }\n                }\n                return responsiveAttributes;\n            }\n            /**\n * Generate a media query\n *\n * @private\n * @param {object} options configuration options\n * @param {number|string} options.min_width\n * @param {number|string} options.max_width\n * @return {string} a media query string\n */ function generateMediaAttr(options) {\n                var mediaQuery = [];\n                if (options != null) {\n                    if (options.min_width != null) {\n                        mediaQuery.push(\"(min-width: \".concat(options.min_width, \"px)\"));\n                    }\n                    if (options.max_width != null) {\n                        mediaQuery.push(\"(max-width: \".concat(options.max_width, \"px)\"));\n                    }\n                }\n                return mediaQuery.join(\" and \");\n            }\n            var srcsetUrl = scaledUrl;\n            // CONCATENATED MODULE: ./src/tags/imagetag.js\n            function imagetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return imagetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, imagetag_typeof(obj);\n            }\n            function imagetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function imagetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function imagetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) imagetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) imagetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function imagetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    imagetag_get = Reflect.get.bind();\n                } else {\n                    imagetag_get = function _get(target, property, receiver) {\n                        var base = imagetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return imagetag_get.apply(this, arguments);\n            }\n            function imagetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = imagetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function imagetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) imagetag_setPrototypeOf(subClass, superClass);\n            }\n            function imagetag_setPrototypeOf(o, p) {\n                imagetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return imagetag_setPrototypeOf(o, p);\n            }\n            function imagetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = imagetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = imagetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = imagetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return imagetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function imagetag_possibleConstructorReturn(self, call) {\n                if (call && (imagetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return imagetag_assertThisInitialized(self);\n            }\n            function imagetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function imagetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function imagetag_getPrototypeOf(o) {\n                imagetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return imagetag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor ImageTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var imagetag_ImageTag = /*#__PURE__*/ function(_HtmlTag) {\n                imagetag_inherits(ImageTag, _HtmlTag);\n                var _super = imagetag_createSuper(ImageTag);\n                function ImageTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    imagetag_classCallCheck(this, ImageTag);\n                    return _super.call(this, \"img\", publicId, options);\n                }\n                /** @override */ imagetag_createClass(ImageTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr, options, srcAttribute;\n                            attr = imagetag_get(imagetag_getPrototypeOf(ImageTag.prototype), \"attributes\", this).call(this) || {};\n                            options = this.getOptions();\n                            var attributes = this.getOption(\"attributes\") || {};\n                            var srcsetParam = this.getOption(\"srcset\") || attributes.srcset;\n                            var responsiveAttributes = {};\n                            if (isString_root_isString_default()(srcsetParam)) {\n                                responsiveAttributes.srcset = srcsetParam;\n                            } else {\n                                responsiveAttributes = generateImageResponsiveAttributes(this.publicId, attributes, srcsetParam, options);\n                            }\n                            if (!isEmpty(responsiveAttributes)) {\n                                delete attr.width;\n                                delete attr.height;\n                            }\n                            merge_root_merge_default()(attr, responsiveAttributes);\n                            srcAttribute = options.responsive && !options.client_hints ? \"data-src\" : \"src\";\n                            if (attr[srcAttribute] == null) {\n                                attr[srcAttribute] = url_url(this.publicId, this.getOptions());\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n                return ImageTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var imagetag = imagetag_ImageTag;\n            // CONCATENATED MODULE: ./src/tags/sourcetag.js\n            function sourcetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return sourcetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, sourcetag_typeof(obj);\n            }\n            function sourcetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function sourcetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function sourcetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) sourcetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) sourcetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function sourcetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    sourcetag_get = Reflect.get.bind();\n                } else {\n                    sourcetag_get = function _get(target, property, receiver) {\n                        var base = sourcetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return sourcetag_get.apply(this, arguments);\n            }\n            function sourcetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = sourcetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function sourcetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) sourcetag_setPrototypeOf(subClass, superClass);\n            }\n            function sourcetag_setPrototypeOf(o, p) {\n                sourcetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return sourcetag_setPrototypeOf(o, p);\n            }\n            function sourcetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = sourcetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = sourcetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = sourcetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return sourcetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function sourcetag_possibleConstructorReturn(self, call) {\n                if (call && (sourcetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return sourcetag_assertThisInitialized(self);\n            }\n            function sourcetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function sourcetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function sourcetag_getPrototypeOf(o) {\n                sourcetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return sourcetag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor SourceTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var sourcetag_SourceTag = /*#__PURE__*/ function(_HtmlTag) {\n                sourcetag_inherits(SourceTag, _HtmlTag);\n                var _super = sourcetag_createSuper(SourceTag);\n                function SourceTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    sourcetag_classCallCheck(this, SourceTag);\n                    return _super.call(this, \"source\", publicId, options);\n                }\n                /** @override */ sourcetag_createClass(SourceTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var srcsetParam = this.getOption(\"srcset\");\n                            var attr = sourcetag_get(sourcetag_getPrototypeOf(SourceTag.prototype), \"attributes\", this).call(this) || {};\n                            var options = this.getOptions();\n                            merge_root_merge_default()(attr, generateImageResponsiveAttributes(this.publicId, attr, srcsetParam, options));\n                            if (!attr.srcset) {\n                                attr.srcset = url_url(this.publicId, options);\n                            }\n                            if (!attr.media && options.media) {\n                                attr.media = generateMediaAttr(options.media);\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n                return SourceTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var sourcetag = sourcetag_SourceTag;\n            // CONCATENATED MODULE: ./src/tags/picturetag.js\n            function picturetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return picturetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, picturetag_typeof(obj);\n            }\n            function picturetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function picturetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function picturetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) picturetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) picturetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function picturetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    picturetag_get = Reflect.get.bind();\n                } else {\n                    picturetag_get = function _get(target, property, receiver) {\n                        var base = picturetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return picturetag_get.apply(this, arguments);\n            }\n            function picturetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = picturetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function picturetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) picturetag_setPrototypeOf(subClass, superClass);\n            }\n            function picturetag_setPrototypeOf(o, p) {\n                picturetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return picturetag_setPrototypeOf(o, p);\n            }\n            function picturetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = picturetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = picturetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = picturetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return picturetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function picturetag_possibleConstructorReturn(self, call) {\n                if (call && (picturetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return picturetag_assertThisInitialized(self);\n            }\n            function picturetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function picturetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function picturetag_getPrototypeOf(o) {\n                picturetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return picturetag_getPrototypeOf(o);\n            }\n            var picturetag_PictureTag = /*#__PURE__*/ function(_HtmlTag) {\n                picturetag_inherits(PictureTag, _HtmlTag);\n                var _super = picturetag_createSuper(PictureTag);\n                function PictureTag(publicId) {\n                    var _this;\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    var sources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n                    picturetag_classCallCheck(this, PictureTag);\n                    _this = _super.call(this, \"picture\", publicId, options);\n                    _this.widthList = sources;\n                    return _this;\n                }\n                /** @override */ picturetag_createClass(PictureTag, [\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this2 = this;\n                            return this.widthList.map(function(_ref) {\n                                var min_width = _ref.min_width, max_width = _ref.max_width, transformation = _ref.transformation;\n                                var options = _this2.getOptions();\n                                var sourceTransformation = new src_transformation(options);\n                                sourceTransformation.chain().fromOptions(typeof transformation === \"string\" ? {\n                                    raw_transformation: transformation\n                                } : transformation);\n                                options = extractUrlParams(options);\n                                options.media = {\n                                    min_width: min_width,\n                                    max_width: max_width\n                                };\n                                options.transformation = sourceTransformation;\n                                return new sourcetag(_this2.publicId, options).toHtml();\n                            }).join(\"\") + new imagetag(this.publicId, this.getOptions()).toHtml();\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr = picturetag_get(picturetag_getPrototypeOf(PictureTag.prototype), \"attributes\", this).call(this);\n                            delete attr.width;\n                            delete attr.height;\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\" + this.name + \">\";\n                        }\n                    }\n                ]);\n                return PictureTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var picturetag = picturetag_PictureTag;\n            // CONCATENATED MODULE: ./src/tags/videotag.js\n            function videotag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return videotag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, videotag_typeof(obj);\n            }\n            function videotag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function videotag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function videotag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) videotag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) videotag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function videotag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    videotag_get = Reflect.get.bind();\n                } else {\n                    videotag_get = function _get(target, property, receiver) {\n                        var base = videotag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return videotag_get.apply(this, arguments);\n            }\n            function videotag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = videotag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function videotag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) videotag_setPrototypeOf(subClass, superClass);\n            }\n            function videotag_setPrototypeOf(o, p) {\n                videotag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return videotag_setPrototypeOf(o, p);\n            }\n            function videotag_createSuper(Derived) {\n                var hasNativeReflectConstruct = videotag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = videotag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = videotag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return videotag_possibleConstructorReturn(this, result);\n                };\n            }\n            function videotag_possibleConstructorReturn(self, call) {\n                if (call && (videotag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return videotag_assertThisInitialized(self);\n            }\n            function videotag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function videotag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function videotag_getPrototypeOf(o) {\n                videotag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return videotag_getPrototypeOf(o);\n            }\n            /**\n * Video Tag\n * Depends on 'tags/htmltag', 'util', 'cloudinary'\n */ var VIDEO_TAG_PARAMS = [\n                \"source_types\",\n                \"source_transformation\",\n                \"fallback_content\",\n                \"poster\",\n                \"sources\"\n            ];\n            var videotag_DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var videotag_DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            /**\n * Creates an HTML (DOM) Video tag using Cloudinary as the source.\n * @constructor VideoTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var videotag_VideoTag = /*#__PURE__*/ function(_HtmlTag) {\n                videotag_inherits(VideoTag, _HtmlTag);\n                var _super = videotag_createSuper(VideoTag);\n                function VideoTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    videotag_classCallCheck(this, VideoTag);\n                    options = defaults({}, options, DEFAULT_VIDEO_PARAMS);\n                    return _super.call(this, \"video\", publicId.replace(/\\.(mp4|ogv|webm)$/, \"\"), options);\n                }\n                /**\n   * Set the transformation to apply on each source\n   * @function VideoTag#setSourceTransformation\n   * @param {Object} an object with pairs of source type and source transformation\n   * @returns {VideoTag} Returns this instance for chaining purposes.\n   */ videotag_createClass(VideoTag, [\n                    {\n                        key: \"setSourceTransformation\",\n                        value: function setSourceTransformation(value) {\n                            this.transformation().sourceTransformation(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setSourceTypes\",\n                        value: function setSourceTypes(value) {\n                            this.transformation().sourceTypes(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setPoster\",\n                        value: function setPoster(value) {\n                            this.transformation().poster(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setFallbackContent\",\n                        value: function setFallbackContent(value) {\n                            this.transformation().fallbackContent(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this = this;\n                            var sourceTypes = this.transformation().getValue(\"source_types\");\n                            var sourceTransformation = this.transformation().getValue(\"source_transformation\");\n                            var fallback = this.transformation().getValue(\"fallback_content\");\n                            var sources = this.getOption(\"sources\");\n                            var innerTags = [];\n                            if (isArray_root_isArray_default()(sources) && !isEmpty(sources)) {\n                                innerTags = sources.map(function(source) {\n                                    var src = url_url(_this.publicId, defaults({}, source.transformations || {}, {\n                                        resource_type: \"video\",\n                                        format: source.type\n                                    }), _this.getOptions());\n                                    return _this.createSourceTag(src, source.type, source.codecs);\n                                });\n                            } else {\n                                if (isEmpty(sourceTypes)) {\n                                    sourceTypes = videotag_DEFAULT_VIDEO_SOURCE_TYPES;\n                                }\n                                if (isArray_root_isArray_default()(sourceTypes)) {\n                                    innerTags = sourceTypes.map(function(srcType) {\n                                        var src = url_url(_this.publicId, defaults({}, sourceTransformation[srcType] || {}, {\n                                            resource_type: \"video\",\n                                            format: srcType\n                                        }), _this.getOptions());\n                                        return _this.createSourceTag(src, srcType);\n                                    });\n                                }\n                            }\n                            return innerTags.join(\"\") + fallback;\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var sourceTypes = this.getOption(\"source_types\");\n                            var poster = this.getOption(\"poster\");\n                            if (poster === undefined) {\n                                poster = {};\n                            }\n                            if (isPlainObject_root_isPlainObject_default()(poster)) {\n                                var defaultOptions = poster.public_id != null ? DEFAULT_IMAGE_PARAMS : videotag_DEFAULT_POSTER_OPTIONS;\n                                poster = url_url(poster.public_id || this.publicId, defaults({}, poster, defaultOptions, this.getOptions()));\n                            }\n                            var attr = videotag_get(videotag_getPrototypeOf(VideoTag.prototype), \"attributes\", this).call(this) || {};\n                            attr = omit(attr, VIDEO_TAG_PARAMS);\n                            var sources = this.getOption(\"sources\"); // In case of empty sourceTypes - fallback to default source types is used.\n                            var hasSourceTags = !isEmpty(sources) || isEmpty(sourceTypes) || isArray_root_isArray_default()(sourceTypes);\n                            if (!hasSourceTags) {\n                                attr[\"src\"] = url_url(this.publicId, this.getOptions(), {\n                                    resource_type: \"video\",\n                                    format: sourceTypes\n                                });\n                            }\n                            if (poster != null) {\n                                attr[\"poster\"] = poster;\n                            }\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"createSourceTag\",\n                        value: function createSourceTag(src, sourceType) {\n                            var codecs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n                            var mimeType = null;\n                            if (!isEmpty(sourceType)) {\n                                var videoType = sourceType === \"ogv\" ? \"ogg\" : sourceType;\n                                mimeType = \"video/\" + videoType;\n                                if (!isEmpty(codecs)) {\n                                    var codecsStr = isArray_root_isArray_default()(codecs) ? codecs.join(\", \") : codecs;\n                                    mimeType += \"; codecs=\" + codecsStr;\n                                }\n                            }\n                            return \"<source \" + this.htmlAttrs({\n                                src: src,\n                                type: mimeType\n                            }) + \">\";\n                        }\n                    }\n                ]);\n                return VideoTag;\n            }(htmltag);\n            /* harmony default export */ var videotag = videotag_VideoTag;\n            // CONCATENATED MODULE: ./src/tags/clienthintsmetatag.js\n            function clienthintsmetatag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return clienthintsmetatag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, clienthintsmetatag_typeof(obj);\n            }\n            function clienthintsmetatag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function clienthintsmetatag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function clienthintsmetatag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) clienthintsmetatag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) clienthintsmetatag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function clienthintsmetatag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) clienthintsmetatag_setPrototypeOf(subClass, superClass);\n            }\n            function clienthintsmetatag_setPrototypeOf(o, p) {\n                clienthintsmetatag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return clienthintsmetatag_setPrototypeOf(o, p);\n            }\n            function clienthintsmetatag_createSuper(Derived) {\n                var hasNativeReflectConstruct = clienthintsmetatag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = clienthintsmetatag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = clienthintsmetatag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return clienthintsmetatag_possibleConstructorReturn(this, result);\n                };\n            }\n            function clienthintsmetatag_possibleConstructorReturn(self, call) {\n                if (call && (clienthintsmetatag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return clienthintsmetatag_assertThisInitialized(self);\n            }\n            function clienthintsmetatag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function clienthintsmetatag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function clienthintsmetatag_getPrototypeOf(o) {\n                clienthintsmetatag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return clienthintsmetatag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Meta tag that enables Client-Hints for the HTML page. <br/>\n *  See\n *  <a href=\"https://cloudinary.com/documentation/responsive_images#automating_responsive_images_with_client_hints\"\n *  target=\"_new\">Automating responsive images with Client Hints</a> for more details.\n * @constructor ClientHintsMetaTag\n * @extends HtmlTag\n * @param {object} options\n * @example\n * tag = new ClientHintsMetaTag()\n * //returns: <meta http-equiv=\"Accept-CH\" content=\"DPR, Viewport-Width, Width\">\n */ var clienthintsmetatag_ClientHintsMetaTag = /*#__PURE__*/ function(_HtmlTag) {\n                clienthintsmetatag_inherits(ClientHintsMetaTag, _HtmlTag);\n                var _super = clienthintsmetatag_createSuper(ClientHintsMetaTag);\n                function ClientHintsMetaTag(options) {\n                    clienthintsmetatag_classCallCheck(this, ClientHintsMetaTag);\n                    return _super.call(this, \"meta\", void 0, assign_root_assign_default()({\n                        \"http-equiv\": \"Accept-CH\",\n                        content: \"DPR, Viewport-Width, Width\"\n                    }, options));\n                }\n                /** @override */ clienthintsmetatag_createClass(ClientHintsMetaTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    }\n                ]);\n                return ClientHintsMetaTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var clienthintsmetatag = clienthintsmetatag_ClientHintsMetaTag;\n            // CONCATENATED MODULE: ./src/util/parse/normalizeToArray.js\n            function normalizeToArray_toConsumableArray(arr) {\n                return normalizeToArray_arrayWithoutHoles(arr) || normalizeToArray_iterableToArray(arr) || normalizeToArray_unsupportedIterableToArray(arr) || normalizeToArray_nonIterableSpread();\n            }\n            function normalizeToArray_nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function normalizeToArray_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return normalizeToArray_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return normalizeToArray_arrayLikeToArray(o, minLen);\n            }\n            function normalizeToArray_iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function normalizeToArray_arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return normalizeToArray_arrayLikeToArray(arr);\n            }\n            function normalizeToArray_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            /**\n * @desc normalize elements, support a single element, array or nodelist, always outputs array\n * @param elements<HTMLElement[]>\n * @returns {[]}\n */ function normalizeToArray(elements) {\n                if (isArray_root_isArray_default()(elements)) {\n                    return elements;\n                } else if (elements.constructor.name === \"NodeList\") {\n                    return normalizeToArray_toConsumableArray(elements); // ensure an array is always returned, even if nodelist\n                } else if (isString_root_isString_default()(elements)) {\n                    return Array.prototype.slice.call(document.querySelectorAll(elements), 0);\n                } else {\n                    return [\n                        elements\n                    ];\n                }\n            }\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountCloudinaryVideoTag.js\n            /**\n * @param {HTMLElement} htmlElContainer\n * @param {object} clInstance cloudinary instance\n * @param {string} publicId\n * @param {object} options - TransformationOptions\n * @returns Promise<HTMLElement>\n */ function mountCloudinaryVideoTag(htmlElContainer, clInstance, publicId, options) {\n                return new Promise(function(resolve, reject) {\n                    htmlElContainer.innerHTML = clInstance.videoTag(publicId, options).toHtml(); // All videos under the html container must have a width of 100%, or they might overflow from the container\n                    var cloudinaryVideoElement = htmlElContainer.querySelector(\".cld-transparent-video\");\n                    cloudinaryVideoElement.style.width = \"100%\";\n                    resolve(htmlElContainer);\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountCloudinaryVideoTag = mountCloudinaryVideoTag;\n            // CONCATENATED MODULE: ./src/util/transformations/addFlag.js\n            /**\n * @description - Function will push a flag to incoming options\n * @param {{transformation} | {...transformation}} options - These options are the same options provided to all our SDK methods\n *                           We expect options to either be the transformation itself, or an object containing\n *                           an array of transformations\n *\n * @param {string} flag\n * @returns the mutated options object\n */ function addFlagToOptions(options, flag) {\n                // Do we have transformation\n                if (options.transformation) {\n                    options.transformation.push({\n                        flags: [\n                            flag\n                        ]\n                    });\n                } else {\n                    // no transformation\n                    // ensure the flags are extended\n                    if (!options.flags) {\n                        options.flags = [];\n                    }\n                    if (typeof options.flags === \"string\") {\n                        options.flags = [\n                            options.flags\n                        ];\n                    }\n                    options.flags.push(flag);\n                }\n            }\n            /* harmony default export */ var addFlag = addFlagToOptions;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/enforceOptionsForTransparentVideo.js\n            /**\n * @description - Enforce option structure, sets defaults and ensures alpha flag exists\n * @param options {TransformationOptions}\n */ function enforceOptionsForTransparentVideo(options) {\n                options.autoplay = true;\n                options.muted = true;\n                options.controls = false;\n                options.max_timeout_ms = options.max_timeout_ms || DEFAULT_TIMEOUT_MS;\n                options[\"class\"] = options[\"class\"] || \"\";\n                options[\"class\"] += \" cld-transparent-video\";\n                options.externalLibraries = options.externalLibraries || {};\n                if (!options.externalLibraries.seeThru) {\n                    options.externalLibraries.seeThru = DEFAULT_EXTERNAL_LIBRARIES.seeThru;\n                } // ensure there's an alpha transformation present\n                // this is a non documented internal flag\n                addFlag(options, \"alpha\");\n            }\n            /* harmony default export */ var transparentVideo_enforceOptionsForTransparentVideo = enforceOptionsForTransparentVideo;\n            // CONCATENATED MODULE: ./src/util/xhr/loadScript.js\n            /**\n * @description - Given a string URL, this function will load the script and resolve the promise.\n *                The function doesn't resolve any value,\n *                this is not a UMD loader where you can get your library name back.\n * @param scriptURL {string}\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param isAlreadyLoaded {boolean} if true, the loadScript resolves immediately\n *                                  this is used for multiple invocations - prevents the script from being loaded multiple times\n * @return {Promise<any | {status:string, message:string}>}\n */ function loadScript(scriptURL, max_timeout_ms, isAlreadyLoaded) {\n                return new Promise(function(resolve, reject) {\n                    if (isAlreadyLoaded) {\n                        resolve();\n                    } else {\n                        var scriptTag = document.createElement(\"script\");\n                        scriptTag.src = scriptURL;\n                        var timerID = setTimeout(function() {\n                            reject({\n                                status: \"error\",\n                                message: \"Timeout loading script \".concat(scriptURL)\n                            });\n                        }, max_timeout_ms); // 10 seconds for timeout\n                        scriptTag.onerror = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            reject({\n                                status: \"error\",\n                                message: \"Error loading \".concat(scriptURL)\n                            });\n                        };\n                        scriptTag.onload = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            resolve();\n                        };\n                        document.head.appendChild(scriptTag);\n                    }\n                });\n            }\n            /* harmony default export */ var xhr_loadScript = loadScript;\n            // CONCATENATED MODULE: ./src/util/xhr/getBlobFromURL.js\n            /**\n * Reject on timeout\n * @param maxTimeoutMS\n * @param reject\n * @returns {number} timerID\n */ function rejectOnTimeout(maxTimeoutMS, reject) {\n                return setTimeout(function() {\n                    reject({\n                        status: \"error\",\n                        message: \"Timeout loading Blob URL\"\n                    });\n                }, maxTimeoutMS);\n            }\n            /**\n * @description Converts a URL to a BLOB URL\n * @param {string} urlToLoad\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @return {Promise<{\n *   status: 'success' | 'error'\n *   message?: string,\n *    payload: {\n *      url: string\n *    }\n * }>}\n */ function getBlobFromURL(urlToLoad, maxTimeoutMS) {\n                return new Promise(function(resolve, reject) {\n                    var timerID = rejectOnTimeout(maxTimeoutMS, reject); // If fetch exists, use it to fetch blob, otherwise use XHR.\n                    // XHR causes issues on safari 14.1 so we prefer fetch\n                    var fetchBlob = typeof fetch !== \"undefined\" && fetch ? loadUrlUsingFetch : loadUrlUsingXhr;\n                    fetchBlob(urlToLoad).then(function(blob) {\n                        resolve({\n                            status: \"success\",\n                            payload: {\n                                blobURL: URL.createObjectURL(blob)\n                            }\n                        });\n                    })[\"catch\"](function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Error loading Blob URL\"\n                        });\n                    })[\"finally\"](function() {\n                        // Clear the timeout timer on fail or success.\n                        clearTimeout(timerID);\n                    });\n                });\n            }\n            /**\n * Use fetch function to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingFetch(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    fetch(urlToLoad).then(function(response) {\n                        response.blob().then(function(blob) {\n                            resolve(blob);\n                        });\n                    })[\"catch\"](function() {\n                        reject(\"error\");\n                    });\n                });\n            }\n            /**\n * Use XHR to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingXhr(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    var xhr = new XMLHttpRequest();\n                    xhr.responseType = \"blob\";\n                    xhr.onload = function(response) {\n                        resolve(xhr.response);\n                    };\n                    xhr.onerror = function() {\n                        reject(\"error\");\n                    };\n                    xhr.open(\"GET\", urlToLoad, true);\n                    xhr.send();\n                });\n            }\n            /* harmony default export */ var xhr_getBlobFromURL = getBlobFromURL;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/createHiddenVideoTag.js\n            /**\n * @description Creates a hidden HTMLVideoElement with the specified videoOptions\n * @param {{autoplay, playsinline, loop, muted, poster, blobURL, videoURL }} videoOptions\n * @param {boolean} videoOptions.autoplay - autoplays the video if true\n * @param {string} videoOptions.blobURL - the blobURL to set as video.src\n * @param {string} videoOptions.videoURL - the original videoURL the user created (with transformations)\n * @return {HTMLVideoElement}\n */ function createHiddenVideoTag(videoOptions) {\n                var autoplay = videoOptions.autoplay, playsinline = videoOptions.playsinline, loop = videoOptions.loop, muted = videoOptions.muted, poster = videoOptions.poster, blobURL = videoOptions.blobURL, videoURL = videoOptions.videoURL;\n                var el = document.createElement(\"video\");\n                el.style.visibility = \"hidden\";\n                el.position = \"absolute\";\n                el.x = 0;\n                el.y = 0;\n                el.src = blobURL;\n                el.setAttribute(\"data-video-url\", videoURL); // for debugging/testing\n                autoplay && el.setAttribute(\"autoplay\", autoplay);\n                playsinline && el.setAttribute(\"playsinline\", playsinline);\n                loop && el.setAttribute(\"loop\", loop);\n                muted && el.setAttribute(\"muted\", muted);\n                muted && (el.muted = muted); // this is also needed for autoplay, on top of setAttribute\n                poster && el.setAttribute(\"poster\", poster); // Free memory at the end of the file loading.\n                el.onload = function() {\n                    URL.revokeObjectURL(blobURL);\n                };\n                return el;\n            }\n            /* harmony default export */ var transparentVideo_createHiddenVideoTag = createHiddenVideoTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/instantiateSeeThru.js\n            /**\n * @description This function creates a new instanc eof seeThru (seeThru.create()) and returns a promise of the seeThru instance\n * @param {HTMLVideoElement} videoElement\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param {string} customClass - A classname to be added to the canvas element created by seeThru\n * @param {boolean} autoPlay\n * @return {Promise<any>} SeeThru instance or rejection error\n */ function instantiateSeeThru(videoElement, max_timeout_ms, customClass, autoPlay) {\n                var _window = window, seeThru = _window.seeThru, setTimeout1 = _window.setTimeout, clearTimeout1 = _window.clearTimeout;\n                return new Promise(function(resolve, reject) {\n                    var timerID = setTimeout1(function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Timeout instantiating seeThru instance\"\n                        });\n                    }, max_timeout_ms);\n                    if (seeThru) {\n                        var seeThruInstance = seeThru.create(videoElement).ready(function() {\n                            // clear timeout reject error\n                            clearTimeout1(timerID); // force container width, else the canvas can overflow out\n                            var canvasElement = seeThruInstance.getCanvas();\n                            canvasElement.style.width = \"100%\";\n                            canvasElement.className += \" \" + customClass; // start the video if autoplay is set\n                            if (autoPlay) {\n                                seeThruInstance.play();\n                            }\n                            resolve(seeThruInstance);\n                        });\n                    } else {\n                        reject({\n                            status: \"error\",\n                            message: \"Error instantiating seeThru instance\"\n                        });\n                    }\n                });\n            }\n            /* harmony default export */ var transparentVideo_instantiateSeeThru = instantiateSeeThru;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountSeeThruCanvasTag.js\n            /**\n *\n * @param {HTMLElement} htmlElContainer\n * @param {string} videoURL\n * @param {TransformationOptions} options\n * @return {Promise<any>}\n */ function mountSeeThruCanvasTag(htmlElContainer, videoURL, options) {\n                var poster = options.poster, autoplay = options.autoplay, playsinline = options.playsinline, loop = options.loop, muted = options.muted;\n                videoURL = videoURL + \".mp4\"; // seeThru always uses mp4\n                return new Promise(function(resolve, reject) {\n                    xhr_loadScript(options.externalLibraries.seeThru, options.max_timeout_ms, window.seeThru).then(function() {\n                        xhr_getBlobFromURL(videoURL, options.max_timeout_ms).then(function(_ref) {\n                            var payload = _ref.payload;\n                            var videoElement = transparentVideo_createHiddenVideoTag({\n                                blobURL: payload.blobURL,\n                                videoURL: videoURL,\n                                // for debugging/testing\n                                poster: poster,\n                                autoplay: autoplay,\n                                playsinline: playsinline,\n                                loop: loop,\n                                muted: muted\n                            });\n                            htmlElContainer.appendChild(videoElement);\n                            transparentVideo_instantiateSeeThru(videoElement, options.max_timeout_ms, options[\"class\"], options.autoplay).then(function() {\n                                resolve(htmlElContainer);\n                            })[\"catch\"](function(err) {\n                                reject(err);\n                            }); // catch for getBlobFromURL()\n                        })[\"catch\"](function(_ref2) {\n                            var status = _ref2.status, message = _ref2.message;\n                            reject({\n                                status: status,\n                                message: message\n                            });\n                        }); // catch for loadScript()\n                    })[\"catch\"](function(_ref3) {\n                        var status = _ref3.status, message = _ref3.message;\n                        reject({\n                            status: status,\n                            message: message\n                        });\n                    });\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountSeeThruCanvasTag = mountSeeThruCanvasTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/checkSupportForTransparency.js\n            /**\n * @return {Promise<boolean>} - Whether the browser supports transparent videos or not\n */ function checkSupportForTransparency() {\n                return new Promise(function(resolve, reject) {\n                    // Resolve early for safari.\n                    // Currently (29 December 2021) Safari can play webm/vp9,\n                    // but it does not support transparent video in the format we're outputting\n                    if (isSafari()) {\n                        resolve(false);\n                    }\n                    var video = document.createElement(\"video\");\n                    var canPlay = video.canPlayType && video.canPlayType('video/webm; codecs=\"vp9\"');\n                    resolve(canPlay === \"maybe\" || canPlay === \"probably\");\n                });\n            }\n            /* harmony default export */ var transparentVideo_checkSupportForTransparency = checkSupportForTransparency;\n            // CONCATENATED MODULE: ./src/cloudinary.js\n            function cloudinary_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function cloudinary_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function cloudinary_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) cloudinary_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) cloudinary_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            var applyBreakpoints, closestAbove, defaultBreakpoints, cloudinary_findContainerWidth, cloudinary_maxWidth, updateDpr;\n            //\n            defaultBreakpoints = function defaultBreakpoints(width) {\n                var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n                return steps * Math.ceil(width / steps);\n            };\n            closestAbove = function closestAbove(list, value) {\n                var i;\n                i = list.length - 2;\n                while(i >= 0 && list[i] >= value){\n                    i--;\n                }\n                return list[i + 1];\n            };\n            applyBreakpoints = function applyBreakpoints(tag, width, steps, options) {\n                var ref, ref1, ref2, responsive_use_breakpoints;\n                responsive_use_breakpoints = (ref = (ref1 = (ref2 = options[\"responsive_use_breakpoints\"]) != null ? ref2 : options[\"responsive_use_stoppoints\"]) != null ? ref1 : this.config(\"responsive_use_breakpoints\")) != null ? ref : this.config(\"responsive_use_stoppoints\");\n                if (!responsive_use_breakpoints || responsive_use_breakpoints === \"resize\" && !options.resizing) {\n                    return width;\n                } else {\n                    return this.calc_breakpoint(tag, width, steps);\n                }\n            };\n            cloudinary_findContainerWidth = function findContainerWidth(element) {\n                var containerWidth, style;\n                containerWidth = 0;\n                while((element = element != null ? element.parentNode : void 0) instanceof Element && !containerWidth){\n                    style = window.getComputedStyle(element);\n                    if (!/^inline/.test(style.display)) {\n                        containerWidth = lodash_width(element);\n                    }\n                }\n                return containerWidth;\n            };\n            updateDpr = function updateDpr(dataSrc, roundDpr) {\n                return dataSrc.replace(/\\bdpr_(1\\.0|auto)\\b/g, \"dpr_\" + this.device_pixel_ratio(roundDpr));\n            };\n            cloudinary_maxWidth = function maxWidth(requiredWidth, tag) {\n                var imageWidth;\n                imageWidth = lodash_getData(tag, \"width\") || 0;\n                if (requiredWidth > imageWidth) {\n                    imageWidth = requiredWidth;\n                    lodash_setData(tag, \"width\", requiredWidth);\n                }\n                return imageWidth;\n            };\n            var cloudinary_Cloudinary = /*#__PURE__*/ function() {\n                /**\n   * Creates a new Cloudinary instance.\n   * @class Cloudinary\n   * @classdesc Main class for accessing Cloudinary functionality.\n   * @param {Object} options - A {@link Configuration} object for globally configuring Cloudinary account settings.\n   * @example<br/>\n   *  var cl = new cloudinary.Cloudinary( { cloud_name: \"mycloud\"});<br/>\n   *  var imgTag = cl.image(\"myPicID\");\n   * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\" target=\"_blank\">\n   *  Available configuration options</a>\n   */ function Cloudinary(options) {\n                    cloudinary_classCallCheck(this, Cloudinary);\n                    var configuration;\n                    this.devicePixelRatioCache = {};\n                    this.responsiveConfig = {};\n                    this.responsiveResizeInitialized = false;\n                    configuration = new src_configuration(options); // Provided for backward compatibility\n                    this.config = function(newConfig, newValue) {\n                        return configuration.config(newConfig, newValue);\n                    };\n                    /**\n     * Use \\<meta\\> tags in the document to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromDocument = function() {\n                        configuration.fromDocument();\n                        return this;\n                    };\n                    /**\n     * Use environment variables to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromEnvironment = function() {\n                        configuration.fromEnvironment();\n                        return this;\n                    };\n                    /**\n     * Initializes the configuration of this `cloudinary` instance.\n     *  This is a convenience method that invokes both {@link Configuration#fromEnvironment|fromEnvironment()}\n     *  (Node.js environment only) and {@link Configuration#fromDocument|fromDocument()}.\n     *  It first tries to retrieve the configuration from the environment variable.\n     *  If not available, it tries from the document meta tags.\n     * @function Cloudinary#init\n     * @see Configuration#init\n     * @return This {Cloudinary} instance for chaining.\n     */ this.init = function() {\n                        configuration.init();\n                        return this;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Cloudinary}\n   * @example cl = cloudinary.Cloudinary.new( { cloud_name: \"mycloud\"})\n   */ cloudinary_createClass(Cloudinary, [\n                    {\n                        key: \"url\",\n                        value: /**\n     * Generates a URL for any asset in your Media library.\n     * @function Cloudinary#url\n     * @param {string} publicId - The public ID of the media asset.\n     * @param {Object} [options] - The {@link Transformation} parameters to include in the URL.\n     * @param {type} [options.type='upload'] - The asset's storage type.\n     *  For details on all fetch types, see\n     * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n     *  target=\"_blank\">Fetch types</a>.\n     * @param {resourceType} [options.resource_type='image'] - The type of asset. Possible values:<br/>\n     *  - `image`<br/>\n     *  - `video`<br/>\n     *  - `raw`\n     * @return {string} The media asset URL.\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n     *  Available image transformations</a>\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n     *  Available video transformations</a>\n     */ function url(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return url_url(publicId, options, this.config());\n                        }\n                    },\n                    {\n                        key: \"video_url\",\n                        value: function video_url(publicId, options) {\n                            options = assign_root_assign_default()({\n                                resource_type: \"video\"\n                            }, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail_url\",\n                        value: function video_thumbnail_url(publicId, options) {\n                            options = assign_root_assign_default()({}, DEFAULT_POSTER_OPTIONS, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"transformation_string\",\n                        value: function transformation_string(options) {\n                            return new src_transformation(options).serialize();\n                        }\n                    },\n                    {\n                        key: \"image\",\n                        value: function image(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            var client_hints, img, ref;\n                            img = this.imageTag(publicId, options);\n                            client_hints = (ref = options.client_hints != null ? options.client_hints : this.config(\"client_hints\")) != null ? ref : false;\n                            if (options.src == null && !client_hints) {\n                                // src must be removed before creating the DOM element to avoid loading the image\n                                img.setAttr(\"src\", \"\");\n                            }\n                            img = img.toDOM();\n                            if (!client_hints) {\n                                // cache the image src\n                                lodash_setData(img, \"src-cache\", this.url(publicId, options)); // set image src taking responsiveness in account\n                                this.cloudinary_update(img, options);\n                            }\n                            return img;\n                        }\n                    },\n                    {\n                        key: \"imageTag\",\n                        value: function imageTag(publicId, options) {\n                            var tag;\n                            tag = new imagetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"pictureTag\",\n                        value: function pictureTag(publicId, options, sources) {\n                            var tag;\n                            tag = new picturetag(publicId, this.config(), sources);\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"sourceTag\",\n                        value: function sourceTag(publicId, options) {\n                            var tag;\n                            tag = new sourcetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail\",\n                        value: function video_thumbnail(publicId, options) {\n                            return this.image(publicId, merge_root_merge_default()({}, DEFAULT_POSTER_OPTIONS, options));\n                        }\n                    },\n                    {\n                        key: \"facebook_profile_image\",\n                        value: function facebook_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"facebook\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_profile_image\",\n                        value: function twitter_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_name_profile_image\",\n                        value: function twitter_name_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter_name\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"gravatar_image\",\n                        value: function gravatar_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"gravatar\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"fetch_image\",\n                        value: function fetch_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"fetch\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"video\",\n                        value: function video(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return this.videoTag(publicId, options).toHtml();\n                        }\n                    },\n                    {\n                        key: \"videoTag\",\n                        value: function videoTag(publicId, options) {\n                            options = defaults({}, options, this.config());\n                            return new videotag(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"sprite_css\",\n                        value: function sprite_css(publicId, options) {\n                            options = assign_root_assign_default()({\n                                type: \"sprite\"\n                            }, options);\n                            if (!publicId.match(/.css$/)) {\n                                options.format = \"css\";\n                            }\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"responsive\",\n                        value: function responsive(options) {\n                            var _this = this;\n                            var bootstrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n                            var ref, ref1, ref2, responsiveClass, responsiveResize, timeout;\n                            this.responsiveConfig = merge_root_merge_default()(this.responsiveConfig || {}, options);\n                            responsiveClass = (ref = this.responsiveConfig.responsive_class) != null ? ref : this.config(\"responsive_class\");\n                            if (bootstrap) {\n                                this.cloudinary_update(\"img.\".concat(responsiveClass, \", img.cld-hidpi\"), this.responsiveConfig);\n                            }\n                            responsiveResize = (ref1 = (ref2 = this.responsiveConfig.responsive_resize) != null ? ref2 : this.config(\"responsive_resize\")) != null ? ref1 : true;\n                            if (responsiveResize && !this.responsiveResizeInitialized) {\n                                this.responsiveConfig.resizing = this.responsiveResizeInitialized = true;\n                                timeout = null;\n                                var makeResponsive = function makeResponsive() {\n                                    var debounce, ref3, ref4, reset, run, wait, waitFunc;\n                                    debounce = (ref3 = (ref4 = _this.responsiveConfig.responsive_debounce) != null ? ref4 : _this.config(\"responsive_debounce\")) != null ? ref3 : 100;\n                                    reset = function reset() {\n                                        if (timeout) {\n                                            clearTimeout(timeout);\n                                            timeout = null;\n                                        }\n                                    };\n                                    run = function run() {\n                                        return _this.cloudinary_update(\"img.\".concat(responsiveClass), _this.responsiveConfig);\n                                    };\n                                    waitFunc = function waitFunc() {\n                                        reset();\n                                        return run();\n                                    };\n                                    wait = function wait() {\n                                        reset();\n                                        timeout = setTimeout(waitFunc, debounce);\n                                    };\n                                    if (debounce) {\n                                        return wait();\n                                    } else {\n                                        return run();\n                                    }\n                                };\n                                window.addEventListener(\"resize\", makeResponsive);\n                                return function() {\n                                    return window.removeEventListener(\"resize\", makeResponsive);\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_breakpoint\",\n                        value: function calc_breakpoint(element, width, steps) {\n                            var breakpoints = lodash_getData(element, \"breakpoints\") || lodash_getData(element, \"stoppoints\") || this.config(\"breakpoints\") || this.config(\"stoppoints\") || defaultBreakpoints;\n                            if (isFunction_root_isFunction_default()(breakpoints)) {\n                                return breakpoints(width, steps);\n                            } else {\n                                if (isString_root_isString_default()(breakpoints)) {\n                                    breakpoints = breakpoints.split(\",\").map(function(point) {\n                                        return parseInt(point);\n                                    }).sort(function(a, b) {\n                                        return a - b;\n                                    });\n                                }\n                                return closestAbove(breakpoints, width);\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_stoppoint\",\n                        value: function calc_stoppoint(element, width, steps) {\n                            return this.calc_breakpoint(element, width, steps);\n                        }\n                    },\n                    {\n                        key: \"device_pixel_ratio\",\n                        value: function device_pixel_ratio(roundDpr) {\n                            roundDpr = roundDpr == null ? true : roundDpr;\n                            var dpr = ( false ? 0 : void 0) || 1;\n                            if (roundDpr) {\n                                dpr = Math.ceil(dpr);\n                            }\n                            if (dpr <= 0 || dpr === 0 / 0) {\n                                dpr = 1;\n                            }\n                            var dprString = dpr.toString();\n                            if (dprString.match(/^\\d+$/)) {\n                                dprString += \".0\";\n                            }\n                            return dprString;\n                        }\n                    },\n                    {\n                        key: \"processImageTags\",\n                        value: function processImageTags(nodes, options) {\n                            if (isEmpty(nodes)) {\n                                // similar to `$.fn.cloudinary`\n                                return this;\n                            }\n                            options = defaults({}, options || {}, this.config());\n                            var images = nodes.filter(function(node) {\n                                return /^img$/i.test(node.tagName);\n                            }).map(function(node) {\n                                var imgOptions = assign_root_assign_default()({\n                                    width: node.getAttribute(\"width\"),\n                                    height: node.getAttribute(\"height\"),\n                                    src: node.getAttribute(\"src\")\n                                }, options);\n                                var publicId = imgOptions[\"source\"] || imgOptions[\"src\"];\n                                delete imgOptions[\"source\"];\n                                delete imgOptions[\"src\"];\n                                var attr = new src_transformation(imgOptions).toHtmlAttributes();\n                                lodash_setData(node, \"src-cache\", url_url(publicId, imgOptions));\n                                node.setAttribute(\"width\", attr.width);\n                                node.setAttribute(\"height\", attr.height);\n                                return node;\n                            });\n                            this.cloudinary_update(images, options);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"cloudinary_update\",\n                        value: function cloudinary_update(elements, options) {\n                            var _this2 = this;\n                            var containerWidth, dataSrc, match, ref4, requiredWidth;\n                            if (elements === null) {\n                                return this;\n                            }\n                            if (options == null) {\n                                options = {};\n                            }\n                            var responsive = options.responsive != null ? options.responsive : this.config(\"responsive\");\n                            elements = normalizeToArray(elements);\n                            var responsiveClass;\n                            if (this.responsiveConfig && this.responsiveConfig.responsive_class != null) {\n                                responsiveClass = this.responsiveConfig.responsive_class;\n                            } else if (options.responsive_class != null) {\n                                responsiveClass = options.responsive_class;\n                            } else {\n                                responsiveClass = this.config(\"responsive_class\");\n                            }\n                            var roundDpr = options.round_dpr != null ? options.round_dpr : this.config(\"round_dpr\");\n                            elements.forEach(function(tag) {\n                                if (/img/i.test(tag.tagName)) {\n                                    var setUrl = true;\n                                    if (responsive) {\n                                        lodash_addClass(tag, responsiveClass);\n                                    }\n                                    dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                                    if (!isEmpty(dataSrc)) {\n                                        // Update dpr according to the device's devicePixelRatio\n                                        dataSrc = updateDpr.call(_this2, dataSrc, roundDpr);\n                                        if (htmltag.isResponsive(tag, responsiveClass)) {\n                                            containerWidth = cloudinary_findContainerWidth(tag);\n                                            if (containerWidth !== 0) {\n                                                if (/w_auto:breakpoints/.test(dataSrc)) {\n                                                    requiredWidth = cloudinary_maxWidth(containerWidth, tag);\n                                                    if (requiredWidth) {\n                                                        dataSrc = dataSrc.replace(/w_auto:breakpoints([_0-9]*)(:[0-9]+)?/, \"w_auto:breakpoints$1:\".concat(requiredWidth));\n                                                    } else {\n                                                        setUrl = false;\n                                                    }\n                                                } else {\n                                                    match = /w_auto(:(\\d+))?/.exec(dataSrc);\n                                                    if (match) {\n                                                        requiredWidth = applyBreakpoints.call(_this2, tag, containerWidth, match[2], options);\n                                                        requiredWidth = cloudinary_maxWidth(requiredWidth, tag);\n                                                        if (requiredWidth) {\n                                                            dataSrc = dataSrc.replace(/w_auto[^,\\/]*/g, \"w_\".concat(requiredWidth));\n                                                        } else {\n                                                            setUrl = false;\n                                                        }\n                                                    }\n                                                }\n                                                lodash_removeAttribute(tag, \"width\");\n                                                if (!options.responsive_preserve_height) {\n                                                    lodash_removeAttribute(tag, \"height\");\n                                                }\n                                            } else {\n                                                // Container doesn't know the size yet - usually because the image is hidden or outside the DOM.\n                                                setUrl = false;\n                                            }\n                                        }\n                                        var isLazyLoading = options.loading === \"lazy\" && !_this2.isNativeLazyLoadSupported() && _this2.isLazyLoadSupported() && !elements[0].getAttribute(\"src\");\n                                        if (setUrl || isLazyLoading) {\n                                            // If data-width exists, set width to be data-width\n                                            _this2.setAttributeIfExists(elements[0], \"width\", \"data-width\");\n                                        }\n                                        if (setUrl && !isLazyLoading) {\n                                            lodash_setAttribute(tag, \"src\", dataSrc);\n                                        }\n                                    }\n                                }\n                            });\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setAttributeIfExists\",\n                        value: function setAttributeIfExists(element, toAttribute, fromAttribute) {\n                            var attributeValue = element.getAttribute(fromAttribute);\n                            if (attributeValue != null) {\n                                lodash_setAttribute(element, toAttribute, attributeValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"isLazyLoadSupported\",\n                        value: function isLazyLoadSupported() {\n                            return window && \"IntersectionObserver\" in window;\n                        }\n                    },\n                    {\n                        key: \"isNativeLazyLoadSupported\",\n                        value: function isNativeLazyLoadSupported() {\n                            return \"loading\" in HTMLImageElement.prototype;\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(options) {\n                            return src_transformation[\"new\"](this.config()).fromOptions(options).setParent(this);\n                        }\n                    },\n                    {\n                        key: \"injectTransparentVideoElement\",\n                        value: function injectTransparentVideoElement(htmlElContainer, publicId) {\n                            var _this3 = this;\n                            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            return new Promise(function(resolve, reject) {\n                                if (!htmlElContainer) {\n                                    reject({\n                                        status: \"error\",\n                                        message: \"Expecting htmlElContainer to be HTMLElement\"\n                                    });\n                                }\n                                transparentVideo_enforceOptionsForTransparentVideo(options);\n                                var videoURL = _this3.video_url(publicId, options);\n                                transparentVideo_checkSupportForTransparency().then(function(isNativelyTransparent) {\n                                    var mountPromise;\n                                    if (isNativelyTransparent) {\n                                        mountPromise = transparentVideo_mountCloudinaryVideoTag(htmlElContainer, _this3, publicId, options);\n                                        resolve(htmlElContainer);\n                                    } else {\n                                        mountPromise = transparentVideo_mountSeeThruCanvasTag(htmlElContainer, videoURL, options);\n                                    }\n                                    mountPromise.then(function() {\n                                        resolve(htmlElContainer);\n                                    })[\"catch\"](function(_ref) {\n                                        var status = _ref.status, message = _ref.message;\n                                        reject({\n                                            status: status,\n                                            message: message\n                                        });\n                                    }); // catch for checkSupportForTransparency()\n                                })[\"catch\"](function(_ref2) {\n                                    var status = _ref2.status, message = _ref2.message;\n                                    reject({\n                                        status: status,\n                                        message: message\n                                    });\n                                });\n                            });\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new this(options);\n                        }\n                    }\n                ]);\n                return Cloudinary;\n            }();\n            assign_root_assign_default()(cloudinary_Cloudinary, constants_namespaceObject);\n            /* harmony default export */ var cloudinary = cloudinary_Cloudinary;\n            // CONCATENATED MODULE: ./src/namespace/cloudinary-core.js\n            /**\n * Creates the namespace for Cloudinary\n */ /* harmony default export */ var cloudinary_core = __nested_webpack_exports__[\"default\"] = {\n                ClientHintsMetaTag: clienthintsmetatag,\n                Cloudinary: cloudinary,\n                Condition: condition,\n                Configuration: src_configuration,\n                crc32: src_crc32,\n                Expression: expression,\n                FetchLayer: fetchlayer,\n                HtmlTag: htmltag,\n                ImageTag: imagetag,\n                Layer: layer_layer,\n                PictureTag: picturetag,\n                SubtitlesLayer: subtitleslayer,\n                TextLayer: textlayer,\n                Transformation: src_transformation,\n                utf8_encode: src_utf8_encode,\n                Util: lodash_namespaceObject,\n                VideoTag: videotag\n            };\n        /***/ },\n        /***/ \"lodash/assign\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_assign__;\n        /***/ },\n        /***/ \"lodash/cloneDeep\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__;\n        /***/ },\n        /***/ \"lodash/compact\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_compact__;\n        /***/ },\n        /***/ \"lodash/difference\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_difference__;\n        /***/ },\n        /***/ \"lodash/functions\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_functions__;\n        /***/ },\n        /***/ \"lodash/identity\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_identity__;\n        /***/ },\n        /***/ \"lodash/includes\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_includes__;\n        /***/ },\n        /***/ \"lodash/isArray\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isArray__;\n        /***/ },\n        /***/ \"lodash/isElement\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isElement__;\n        /***/ },\n        /***/ \"lodash/isFunction\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__;\n        /***/ },\n        /***/ \"lodash/isPlainObject\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__;\n        /***/ },\n        /***/ \"lodash/isString\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isString__;\n        /***/ },\n        /***/ \"lodash/merge\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_merge__;\n        /***/ },\n        /***/ \"lodash/trim\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_trim__;\n        /***/ }\n    });\n}); //# sourceMappingURL=cloudinary-core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbG91ZGluYXJ5LWNvcmUvY2xvdWRpbmFyeS1jb3JlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUcsR0FDRixVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdELFFBQVFHLG1CQUFPQSxDQUFDLG9DQUFlLEdBQUdBLG1CQUFPQSxDQUFDLDBDQUFrQixHQUFHQSxtQkFBT0EsQ0FBQyxzQ0FBZ0IsR0FBR0EsbUJBQU9BLENBQUMsNENBQW1CLEdBQUdBLG1CQUFPQSxDQUFDLDBDQUFrQixHQUFHQSxtQkFBT0EsQ0FBQyx3Q0FBaUIsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLHNDQUFnQixHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsNENBQW1CLEdBQUdBLG1CQUFPQSxDQUFDLGtEQUFzQixHQUFHQSxtQkFBT0EsQ0FBQyx3Q0FBaUIsR0FBR0EsbUJBQU9BLENBQUMsa0NBQWMsR0FBR0EsbUJBQU9BLENBQUMsZ0NBQWE7U0FDM1osRUFLNFY7QUFDbFcsR0FBRyxRQUFNLFNBQVNHLHlDQUF5QyxFQUFFQyw0Q0FBNEMsRUFBRUMsMENBQTBDLEVBQUVDLDZDQUE2QyxFQUFFQyw0Q0FBNEMsRUFBRUMsMkNBQTJDLEVBQUVDLDJDQUEyQyxFQUFFQywwQ0FBMEMsRUFBRUMsNENBQTRDLEVBQUVDLDZDQUE2QyxFQUFFQyxnREFBZ0QsRUFBRUMsMkNBQTJDLEVBQUVDLHdDQUF3QyxFQUFFQyx1Q0FBdUM7SUFDdm9CLE9BQWdCLE1BQUgsR0FBSSxTQUFTQyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQywrQkFB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TyxHQUFHaUI7UUFFakIsR0FBRyxHQUFHO1FBRU4sR0FBRyxHQUFHLGVBQ04sR0FBRyxHQUFJLFNBQVNoQixPQUFNLEVBQUVELFFBQU87WUFFL0JDLFFBQU9ELE9BQU8sR0FBR2tCO1FBRWpCLEdBQUcsR0FBRztJQUVHO0FBQ1QsSUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrYWh0aG9uX3plcm8vLi9ub2RlX21vZHVsZXMvY2xvdWRpbmFyeS1jb3JlL2Nsb3VkaW5hcnktY29yZS5qcz9mNzNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgKiBjbG91ZGluYXJ5LWNvcmUuanNcbiAgICogQ2xvdWRpbmFyeSdzIEphdmFTY3JpcHQgbGlicmFyeSAtIFZlcnNpb24gMi4xMy4wXG4gICAqIENvcHlyaWdodCBDbG91ZGluYXJ5XG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRpbmFyeS9jbG91ZGluYXJ5X2pzXG4gICAqXG4gICAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibG9kYXNoL2Fzc2lnblwiKSwgcmVxdWlyZShcImxvZGFzaC9jbG9uZURlZXBcIiksIHJlcXVpcmUoXCJsb2Rhc2gvY29tcGFjdFwiKSwgcmVxdWlyZShcImxvZGFzaC9kaWZmZXJlbmNlXCIpLCByZXF1aXJlKFwibG9kYXNoL2Z1bmN0aW9uc1wiKSwgcmVxdWlyZShcImxvZGFzaC9pZGVudGl0eVwiKSwgcmVxdWlyZShcImxvZGFzaC9pbmNsdWRlc1wiKSwgcmVxdWlyZShcImxvZGFzaC9pc0FycmF5XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzRWxlbWVudFwiKSwgcmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpLCByZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNTdHJpbmdcIiksIHJlcXVpcmUoXCJsb2Rhc2gvbWVyZ2VcIiksIHJlcXVpcmUoXCJsb2Rhc2gvdHJpbVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJsb2Rhc2gvYXNzaWduXCIsIFwibG9kYXNoL2Nsb25lRGVlcFwiLCBcImxvZGFzaC9jb21wYWN0XCIsIFwibG9kYXNoL2RpZmZlcmVuY2VcIiwgXCJsb2Rhc2gvZnVuY3Rpb25zXCIsIFwibG9kYXNoL2lkZW50aXR5XCIsIFwibG9kYXNoL2luY2x1ZGVzXCIsIFwibG9kYXNoL2lzQXJyYXlcIiwgXCJsb2Rhc2gvaXNFbGVtZW50XCIsIFwibG9kYXNoL2lzRnVuY3Rpb25cIiwgXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiLCBcImxvZGFzaC9pc1N0cmluZ1wiLCBcImxvZGFzaC9tZXJnZVwiLCBcImxvZGFzaC90cmltXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImNsb3VkaW5hcnlcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsb2Rhc2gvYXNzaWduXCIpLCByZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKSwgcmVxdWlyZShcImxvZGFzaC9jb21wYWN0XCIpLCByZXF1aXJlKFwibG9kYXNoL2RpZmZlcmVuY2VcIiksIHJlcXVpcmUoXCJsb2Rhc2gvZnVuY3Rpb25zXCIpLCByZXF1aXJlKFwibG9kYXNoL2lkZW50aXR5XCIpLCByZXF1aXJlKFwibG9kYXNoL2luY2x1ZGVzXCIpLCByZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNFbGVtZW50XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKSwgcmVxdWlyZShcImxvZGFzaC9pc1N0cmluZ1wiKSwgcmVxdWlyZShcImxvZGFzaC9tZXJnZVwiKSwgcmVxdWlyZShcImxvZGFzaC90cmltXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjbG91ZGluYXJ5XCJdID0gZmFjdG9yeShyb290W1wiX1wiXVtcImFzc2lnblwiXSwgcm9vdFtcIl9cIl1bXCJjbG9uZURlZXBcIl0sIHJvb3RbXCJfXCJdW1wiY29tcGFjdFwiXSwgcm9vdFtcIl9cIl1bXCJkaWZmZXJlbmNlXCJdLCByb290W1wiX1wiXVtcImZ1bmN0aW9uc1wiXSwgcm9vdFtcIl9cIl1bXCJpZGVudGl0eVwiXSwgcm9vdFtcIl9cIl1bXCJpbmNsdWRlc1wiXSwgcm9vdFtcIl9cIl1bXCJpc0FycmF5XCJdLCByb290W1wiX1wiXVtcImlzRWxlbWVudFwiXSwgcm9vdFtcIl9cIl1bXCJpc0Z1bmN0aW9uXCJdLCByb290W1wiX1wiXVtcImlzUGxhaW5PYmplY3RcIl0sIHJvb3RbXCJfXCJdW1wiaXNTdHJpbmdcIl0sIHJvb3RbXCJfXCJdW1wibWVyZ2VcIl0sIHJvb3RbXCJfXCJdW1widHJpbVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9hc3NpZ25fXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY2xvbmVEZWVwX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2NvbXBhY3RfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZGlmZmVyZW5jZV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9mdW5jdGlvbnNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaWRlbnRpdHlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaW5jbHVkZXNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0VsZW1lbnRfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNGdW5jdGlvbl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1BsYWluT2JqZWN0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzU3RyaW5nX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX21lcmdlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX3RyaW1fXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9uYW1lc3BhY2UvY2xvdWRpbmFyeS1jb3JlLmpzXCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIi4vc3JjL25hbWVzcGFjZS9jbG91ZGluYXJ5LWNvcmUuanNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ2xpZW50SGludHNNZXRhVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gY2xpZW50aGludHNtZXRhdGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNsb3VkaW5hcnlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBjbG91ZGluYXJ5OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNvbmRpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGNvbmRpdGlvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDb25maWd1cmF0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX2NvbmZpZ3VyYXRpb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3JjMzJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzcmNfY3JjMzI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRXhwcmVzc2lvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGV4cHJlc3Npb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRmV0Y2hMYXllclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGZldGNobGF5ZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiSHRtbFRhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGh0bWx0YWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiSW1hZ2VUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBpbWFnZXRhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMYXllclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGxheWVyX2xheWVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlBpY3R1cmVUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBwaWN0dXJldGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlN1YnRpdGxlc0xheWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3VidGl0bGVzbGF5ZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVGV4dExheWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gdGV4dGxheWVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRyYW5zZm9ybWF0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX3RyYW5zZm9ybWF0aW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInV0ZjhfZW5jb2RlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX3V0ZjhfZW5jb2RlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlV0aWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZpZGVvVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gdmlkZW90YWc7IH0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL3NyYy9jb25zdGFudHMuanNcbnZhciBjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJWRVJTSU9OXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVkVSU0lPTjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJDRl9TSEFSRURfQ0ROXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ0ZfU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJPTERfQUtBTUFJX1NIQVJFRF9DRE5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBPTERfQUtBTUFJX1NIQVJFRF9DRE47IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiQUtBTUFJX1NIQVJFRF9DRE5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBS0FNQUlfU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJTSEFSRURfQ0ROXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1RJTUVPVVRfTVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1RJTUVPVVRfTVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9QT1NURVJfT1BUSU9OU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfUE9TVEVSX09QVElPTlM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJTRU9fVFlQRVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTRU9fVFlQRVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9JTUFHRV9QQVJBTVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX0lNQUdFX1BBUkFNUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1ZJREVPX1BBUkFNU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfVklERU9fUEFSQU1TOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfVklERU9fU09VUkNFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfVklERU9fU09VUkNFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlBMQUNFSE9MREVSX0lNQUdFX01PREVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUExBQ0VIT0xERVJfSU1BR0VfTU9ERVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiQUNDRVNTSUJJTElUWV9NT0RFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFDQ0VTU0lCSUxJVFlfTU9ERVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiVVJMX0tFWVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBVUkxfS0VZUzsgfSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vc3JjL3V0aWwvbG9kYXNoLmpzXG52YXIgbG9kYXNoX25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldEFuYWx5dGljc09wdGlvbnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRBbmFseXRpY3NPcHRpb25zOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImFzc2lnblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY2xvbmVEZWVwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjb21wYWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImRpZmZlcmVuY2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZnVuY3Rpb25zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpZGVudGl0eVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImluY2x1ZGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNBcnJheVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc1BsYWluT2JqZWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzU3RyaW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwibWVyZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjb250YWluc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImRldGVjdEludGVyc2VjdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRldGVjdEludGVyc2VjdGlvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJvbWl0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb21pdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJhbGxTdHJpbmdzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmFzZXV0aWxfYWxsU3RyaW5nczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ3aXRob3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd2l0aG91dDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc051bWJlckxpa2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc051bWJlckxpa2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic21hcnRFc2NhcGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzbWFydEVzY2FwZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJkZWZhdWx0c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZmF1bHRzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm9iamVjdFByb3RvXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb2JqZWN0UHJvdG87IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwib2JqVG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvYmpUb1N0cmluZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc09iamVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzT2JqZWN0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImZ1bmNUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jVGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInJlV29yZHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZVdvcmRzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNhbWVsQ2FzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhbWVsQ2FzZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzbmFrZUNhc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzbmFrZUNhc2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY29udmVydEtleXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb252ZXJ0S2V5czsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ3aXRoQ2FtZWxDYXNlS2V5c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdpdGhDYW1lbENhc2VLZXlzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIndpdGhTbmFrZUNhc2VLZXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd2l0aFNuYWtlQ2FzZUtleXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYmFzZTY0RW5jb2RlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmFzZTY0RW5jb2RlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImJhc2U2NEVuY29kZVVSTFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJhc2U2NEVuY29kZVVSTDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJleHRyYWN0VXJsUGFyYW1zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXh0cmFjdFVybFBhcmFtczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJwYXRjaEZldGNoRm9ybWF0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGF0Y2hGZXRjaEZvcm1hdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJvcHRpb25Db25zdW1lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb3B0aW9uQ29uc3VtZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0VtcHR5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNFbXB0eTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0FuZHJvaWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0FuZHJvaWQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNFZGdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNFZGdlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzQ2hyb21lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNDaHJvbWU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNTYWZhcmlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1NhZmFyaTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0VsZW1lbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzRnVuY3Rpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwidHJpbVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRyaW1fcm9vdF90cmltX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXREYXRhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2dldERhdGE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic2V0RGF0YVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9zZXREYXRhOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldEF0dHJpYnV0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9nZXRBdHRyaWJ1dGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic2V0QXR0cmlidXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX3NldEF0dHJpYnV0ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJyZW1vdmVBdHRyaWJ1dGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNldEF0dHJpYnV0ZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXRBdHRyaWJ1dGVzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImhhc0NsYXNzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2hhc0NsYXNzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImFkZENsYXNzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2FkZENsYXNzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldFN0eWxlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFN0eWxlczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjc3NFeHBhbmRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjc3NFeHBhbmQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZG9tU3R5bGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkb21TdHlsZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjdXJDU1NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdXJDU1M7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY3NzVmFsdWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjc3NWYWx1ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJhdWdtZW50V2lkdGhPckhlaWdodFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGF1Z21lbnRXaWR0aE9ySGVpZ2h0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldFdpZHRoT3JIZWlnaHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIndpZHRoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX3dpZHRoOyB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRmOF9lbmNvZGUuanNcbi8qKlxuICogVVRGOCBlbmNvZGVyXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdXRmOF9lbmNvZGU7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfdXRmOF9lbmNvZGUgPSAodXRmOF9lbmNvZGUgPSBmdW5jdGlvbiB1dGY4X2VuY29kZShhcmdTdHJpbmcpIHtcbiAgdmFyIGMxLCBlbmMsIGVuZCwgbiwgc3RhcnQsIHN0cmluZywgc3RyaW5nbCwgdXRmdGV4dDsgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBXZWJ0b29sa2l0LmluZm8gKGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvLylcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBzb3diZXJyeVxuICAvLyArICAgIHR3ZWFrZWQgYnk6IEphY2tcbiAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBZdmVzIFN1Y2FldFxuICAvLyArICAgYnVnZml4ZWQgYnk6IE9ubm8gTWFyc21hblxuICAvLyArICAgYnVnZml4ZWQgYnk6IFVscmljaFxuICAvLyArICAgYnVnZml4ZWQgYnk6IFJhZmFsIEt1a2F3c2tpXG4gIC8vICsgICBpbXByb3ZlZCBieToga2lyaWxsb2lkXG4gIC8vICogICAgIGV4YW1wbGUgMTogdXRmOF9lbmNvZGUoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAnS2V2aW4gdmFuIFpvbm5ldmVsZCdcblxuICBpZiAoYXJnU3RyaW5nID09PSBudWxsIHx8IHR5cGVvZiBhcmdTdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3RyaW5nID0gYXJnU3RyaW5nICsgJyc7IC8vIC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxuXCIpO1xuXG4gIHV0ZnRleHQgPSAnJztcbiAgc3RhcnQgPSB2b2lkIDA7XG4gIGVuZCA9IHZvaWQgMDtcbiAgc3RyaW5nbCA9IDA7XG4gIHN0YXJ0ID0gZW5kID0gMDtcbiAgc3RyaW5nbCA9IHN0cmluZy5sZW5ndGg7XG4gIG4gPSAwO1xuXG4gIHdoaWxlIChuIDwgc3RyaW5nbCkge1xuICAgIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQobik7XG4gICAgZW5jID0gbnVsbDtcblxuICAgIGlmIChjMSA8IDEyOCkge1xuICAgICAgZW5kKys7XG4gICAgfSBlbHNlIGlmIChjMSA+IDEyNyAmJiBjMSA8IDIwNDgpIHtcbiAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYzEgPj4gNiB8IDE5MiwgYzEgJiA2MyB8IDEyOCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYzEgPj4gMTIgfCAyMjQsIGMxID4+IDYgJiA2MyB8IDEyOCwgYzEgJiA2MyB8IDEyOCk7XG4gICAgfVxuXG4gICAgaWYgKGVuYyAhPT0gbnVsbCkge1xuICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgIHV0ZnRleHQgKz0gc3RyaW5nLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICB1dGZ0ZXh0ICs9IGVuYztcbiAgICAgIHN0YXJ0ID0gZW5kID0gbiArIDE7XG4gICAgfVxuXG4gICAgbisrO1xuICB9XG5cbiAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgdXRmdGV4dCArPSBzdHJpbmcuc2xpY2Uoc3RhcnQsIHN0cmluZ2wpO1xuICB9XG5cbiAgcmV0dXJuIHV0ZnRleHQ7XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NyYzMyLmpzXG5cbi8qKlxuICogQ1JDMzIgY2FsY3VsYXRvclxuICogRGVwZW5kcyBvbiAndXRmOF9lbmNvZGUnXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gY2FsY3VsYXRlIHRoZSBDUkMzMiBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuZnVuY3Rpb24gY3JjMzIoc3RyKSB7XG4gIHZhciBjcmMsIGksIGlUb3AsIHRhYmxlLCB4LCB5OyAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IFdlYnRvb2xraXQuaW5mbyAoaHR0cDovL3d3dy53ZWJ0b29sa2l0LmluZm8vKVxuICAvLyArICAgaW1wcm92ZWQgYnk6IFQwYnNuXG4gIC8vICsgICBpbXByb3ZlZCBieTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjQ3OTM1L2phdmFzY3JpcHQtY3JjMzItZnVuY3Rpb24tYW5kLXBocC1jcmMzMi1ub3QtbWF0Y2hpbmdcbiAgLy8gLSAgICBkZXBlbmRzIG9uOiB1dGY4X2VuY29kZVxuICAvLyAqICAgICBleGFtcGxlIDE6IGNyYzMyKCdLZXZpbiB2YW4gWm9ubmV2ZWxkJyk7XG4gIC8vICogICAgIHJldHVybnMgMTogMTI0OTk5MTI0OVxuXG4gIHN0ciA9IHNyY191dGY4X2VuY29kZShzdHIpO1xuICB0YWJsZSA9ICcwMDAwMDAwMCA3NzA3MzA5NiBFRTBFNjEyQyA5OTA5NTFCQSAwNzZEQzQxOSA3MDZBRjQ4RiBFOTYzQTUzNSA5RTY0OTVBMyAwRURCODgzMiA3OURDQjhBNCBFMEQ1RTkxRSA5N0QyRDk4OCAwOUI2NEMyQiA3RUIxN0NCRCBFN0I4MkQwNyA5MEJGMUQ5MSAxREI3MTA2NCA2QUIwMjBGMiBGM0I5NzE0OCA4NEJFNDFERSAxQURBRDQ3RCA2RERERTRFQiBGNEQ0QjU1MSA4M0QzODVDNyAxMzZDOTg1NiA2NDZCQThDMCBGRDYyRjk3QSA4QTY1QzlFQyAxNDAxNUM0RiA2MzA2NkNEOSBGQTBGM0Q2MyA4RDA4MERGNSAzQjZFMjBDOCA0QzY5MTA1RSBENTYwNDFFNCBBMjY3NzE3MiAzQzAzRTREMSA0QjA0RDQ0NyBEMjBEODVGRCBBNTBBQjU2QiAzNUI1QThGQSA0MkIyOTg2QyBEQkJCQzlENiBBQ0JDRjk0MCAzMkQ4NkNFMyA0NURGNUM3NSBEQ0Q2MERDRiBBQkQxM0Q1OSAyNkQ5MzBBQyA1MURFMDAzQSBDOEQ3NTE4MCBCRkQwNjExNiAyMUI0RjRCNSA1NkIzQzQyMyBDRkJBOTU5OSBCOEJEQTUwRiAyODAyQjg5RSA1RjA1ODgwOCBDNjBDRDlCMiBCMTBCRTkyNCAyRjZGN0M4NyA1ODY4NEMxMSBDMTYxMURBQiBCNjY2MkQzRCA3NkRDNDE5MCAwMURCNzEwNiA5OEQyMjBCQyBFRkQ1MTAyQSA3MUIxODU4OSAwNkI2QjUxRiA5RkJGRTRBNSBFOEI4RDQzMyA3ODA3QzlBMiAwRjAwRjkzNCA5NjA5QTg4RSBFMTBFOTgxOCA3RjZBMERCQiAwODZEM0QyRCA5MTY0NkM5NyBFNjYzNUMwMSA2QjZCNTFGNCAxQzZDNjE2MiA4NTY1MzBEOCBGMjYyMDA0RSA2QzA2OTVFRCAxQjAxQTU3QiA4MjA4RjRDMSBGNTBGQzQ1NyA2NUIwRDlDNiAxMkI3RTk1MCA4QkJFQjhFQSBGQ0I5ODg3QyA2MkREMURERiAxNURBMkQ0OSA4Q0QzN0NGMyBGQkQ0NEM2NSA0REIyNjE1OCAzQUI1NTFDRSBBM0JDMDA3NCBENEJCMzBFMiA0QURGQTU0MSAzREQ4OTVENyBBNEQxQzQ2RCBEM0Q2RjRGQiA0MzY5RTk2QSAzNDZFRDlGQyBBRDY3ODg0NiBEQTYwQjhEMCA0NDA0MkQ3MyAzMzAzMURFNSBBQTBBNEM1RiBERDBEN0NDOSA1MDA1NzEzQyAyNzAyNDFBQSBCRTBCMTAxMCBDOTBDMjA4NiA1NzY4QjUyNSAyMDZGODVCMyBCOTY2RDQwOSBDRTYxRTQ5RiA1RURFRjkwRSAyOUQ5Qzk5OCBCMEQwOTgyMiBDN0Q3QThCNCA1OUIzM0QxNyAyRUI0MEQ4MSBCN0JENUMzQiBDMEJBNkNBRCBFREI4ODMyMCA5QUJGQjNCNiAwM0I2RTIwQyA3NEIxRDI5QSBFQUQ1NDczOSA5REQyNzdBRiAwNERCMjYxNSA3M0RDMTY4MyBFMzYzMEIxMiA5NDY0M0I4NCAwRDZENkEzRSA3QTZBNUFBOCBFNDBFQ0YwQiA5MzA5RkY5RCAwQTAwQUUyNyA3RDA3OUVCMSBGMDBGOTM0NCA4NzA4QTNEMiAxRTAxRjI2OCA2OTA2QzJGRSBGNzYyNTc1RCA4MDY1NjdDQiAxOTZDMzY3MSA2RTZCMDZFNyBGRUQ0MUI3NiA4OUQzMkJFMCAxMERBN0E1QSA2N0RENEFDQyBGOUI5REY2RiA4RUJFRUZGOSAxN0I3QkU0MyA2MEIwOEVENSBENkQ2QTNFOCBBMUQxOTM3RSAzOEQ4QzJDNCA0RkRGRjI1MiBEMUJCNjdGMSBBNkJDNTc2NyAzRkI1MDZERCA0OEIyMzY0QiBEODBEMkJEQSBBRjBBMUI0QyAzNjAzNEFGNiA0MTA0N0E2MCBERjYwRUZDMyBBODY3REY1NSAzMTZFOEVFRiA0NjY5QkU3OSBDQjYxQjM4QyBCQzY2ODMxQSAyNTZGRDJBMCA1MjY4RTIzNiBDQzBDNzc5NSBCQjBCNDcwMyAyMjAyMTZCOSA1NTA1MjYyRiBDNUJBM0JCRSBCMkJEMEIyOCAyQkI0NUE5MiA1Q0IzNkEwNCBDMkQ3RkZBNyBCNUQwQ0YzMSAyQ0Q5OUU4QiA1QkRFQUUxRCA5QjY0QzJCMCBFQzYzRjIyNiA3NTZBQTM5QyAwMjZEOTMwQSA5QzA5MDZBOSBFQjBFMzYzRiA3MjA3Njc4NSAwNTAwNTcxMyA5NUJGNEE4MiBFMkI4N0ExNCA3QkIxMkJBRSAwQ0I2MUIzOCA5MkQyOEU5QiBFNUQ1QkUwRCA3Q0RDRUZCNyAwQkRCREYyMSA4NkQzRDJENCBGMUQ0RTI0MiA2OEREQjNGOCAxRkRBODM2RSA4MUJFMTZDRCBGNkI5MjY1QiA2RkIwNzdFMSAxOEI3NDc3NyA4ODA4NUFFNiBGRjBGNkE3MCA2NjA2M0JDQSAxMTAxMEI1QyA4RjY1OUVGRiBGODYyQUU2OSA2MTZCRkZEMyAxNjZDQ0Y0NSBBMDBBRTI3OCBENzBERDJFRSA0RTA0ODM1NCAzOTAzQjNDMiBBNzY3MjY2MSBEMDYwMTZGNyA0OTY5NDc0RCAzRTZFNzdEQiBBRUQxNkE0QSBEOUQ2NUFEQyA0MERGMEI2NiAzN0Q4M0JGMCBBOUJDQUU1MyBERUJCOUVDNSA0N0IyQ0Y3RiAzMEI1RkZFOSBCREJERjIxQyBDQUJBQzI4QSA1M0IzOTMzMCAyNEI0QTNBNiBCQUQwMzYwNSBDREQ3MDY5MyA1NERFNTcyOSAyM0Q5NjdCRiBCMzY2N0EyRSBDNDYxNEFCOCA1RDY4MUIwMiAyQTZGMkI5NCBCNDBCQkUzNyBDMzBDOEVBMSA1QTA1REYxQiAyRDAyRUY4RCc7XG4gIGNyYyA9IDA7XG4gIHggPSAwO1xuICB5ID0gMDtcbiAgY3JjID0gY3JjIF4gLTE7XG4gIGkgPSAwO1xuICBpVG9wID0gc3RyLmxlbmd0aDtcblxuICB3aGlsZSAoaSA8IGlUb3ApIHtcbiAgICB5ID0gKGNyYyBeIHN0ci5jaGFyQ29kZUF0KGkpKSAmIDB4RkY7XG4gICAgeCA9ICcweCcgKyB0YWJsZS5zdWJzdHIoeSAqIDksIDgpO1xuICAgIGNyYyA9IGNyYyA+Pj4gOCBeIHg7XG4gICAgaSsrO1xuICB9XG5cbiAgY3JjID0gY3JjIF4gLTE7IC8vY29udmVydCB0byB1bnNpZ25lZCAzMi1iaXQgaW50IGlmIG5lZWRlZFxuXG4gIGlmIChjcmMgPCAwKSB7XG4gICAgY3JjICs9IDQyOTQ5NjcyOTY7XG4gIH1cblxuICByZXR1cm4gY3JjO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfY3JjMzIgPSAoY3JjMzIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL3N0cmluZ1BhZC5qc1xuZnVuY3Rpb24gc3RyaW5nUGFkKHZhbHVlLCB0YXJnZXRMZW5ndGgsIHBhZFN0cmluZykge1xuICB0YXJnZXRMZW5ndGggPSB0YXJnZXRMZW5ndGggPj4gMDsgLy90cnVuY2F0ZSBpZiBudW1iZXIgb3IgY29udmVydCBub24tbnVtYmVyIHRvIDA7XG5cbiAgcGFkU3RyaW5nID0gU3RyaW5nKHR5cGVvZiBwYWRTdHJpbmcgIT09ICd1bmRlZmluZWQnID8gcGFkU3RyaW5nIDogJyAnKTtcblxuICBpZiAodmFsdWUubGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TGVuZ3RoIC0gdmFsdWUubGVuZ3RoO1xuXG4gICAgaWYgKHRhcmdldExlbmd0aCA+IHBhZFN0cmluZy5sZW5ndGgpIHtcbiAgICAgIHBhZFN0cmluZyArPSByZXBlYXRTdHJpbmdOdW1UaW1lcyhwYWRTdHJpbmcsIHRhcmdldExlbmd0aCAvIHBhZFN0cmluZy5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYWRTdHJpbmcuc2xpY2UoMCwgdGFyZ2V0TGVuZ3RoKSArIFN0cmluZyh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwZWF0U3RyaW5nTnVtVGltZXMoc3RyaW5nLCB0aW1lcykge1xuICB2YXIgcmVwZWF0ZWRTdHJpbmcgPSBcIlwiO1xuXG4gIHdoaWxlICh0aW1lcyA+IDApIHtcbiAgICByZXBlYXRlZFN0cmluZyArPSBzdHJpbmc7XG4gICAgdGltZXMtLTtcbiAgfVxuXG4gIHJldHVybiByZXBlYXRlZFN0cmluZztcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9iYXNlNjRNYXAuanNcbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG52YXIgYmFzZTY0TWFwX251bSA9IDA7XG52YXIgbWFwID0ge307XG5cbl90b0NvbnN1bWFibGVBcnJheShjaGFycykuZm9yRWFjaChmdW5jdGlvbiAoX2NoYXIpIHtcbiAgdmFyIGtleSA9IGJhc2U2NE1hcF9udW0udG9TdHJpbmcoMik7XG4gIGtleSA9IHN0cmluZ1BhZChrZXksIDYsICcwJyk7XG4gIG1hcFtrZXldID0gX2NoYXI7XG4gIGJhc2U2NE1hcF9udW0rKztcbn0pO1xuLyoqXG4gKiBNYXAgb2Ygc2l4LWJpdCBiaW5hcnkgY29kZXMgdG8gQmFzZTY0IGNoYXJhY3RlcnNcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJhc2U2NE1hcCA9IChtYXApO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL3JldmVyc2VWZXJzaW9uLmpzXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEEgc2VtVmVyIGxpa2Ugc3RyaW5nLCB4LnkueiBvciB4LnkgaXMgYWxsb3dlZFxuICogICAgICAgICAgICAgIFJldmVyc2VzIHRoZSB2ZXJzaW9uIHBvc2l0aW9ucywgeC55LnogdHVybnMgdG8gei55LnhcbiAqICAgICAgICAgICAgICBQYWRzIGVhY2ggc2VnbWVudCB3aXRoICcwJyBzbyB0aGV5IGhhdmUgbGVuZ3RoIG9mIDJcbiAqICAgICAgICAgICAgICBFeGFtcGxlOiAxLjIuMyAtPiAwMy4wMi4wMVxuICogQHBhcmFtIHtzdHJpbmd9IHNlbVZlciBJbnB1dCBjYW4gYmUgZWl0aGVyIHgueS56IG9yIHgueVxuICogQHJldHVybiB7c3RyaW5nfSBpbiB0aGUgZm9ybSBvZiB6ei55eS54eCAoXG4gKi9cblxuZnVuY3Rpb24gcmV2ZXJzZVZlcnNpb24oc2VtVmVyKSB7XG4gIGlmIChzZW1WZXIuc3BsaXQoJy4nKS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNlbVZlciwgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBzZWdtZW50cycpO1xuICB9IC8vIFNwbGl0IGJ5ICcuJywgcmV2ZXJzZSwgY3JlYXRlIG5ldyBhcnJheSB3aXRoIHBhZGRlZCB2YWx1ZXMgYW5kIGNvbmNhdCBpdCB0b2dldGhlclxuXG5cbiAgcmV0dXJuIHNlbVZlci5zcGxpdCgnLicpLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICByZXR1cm4gc3RyaW5nUGFkKHNlZ21lbnQsIDIsICcwJyk7XG4gIH0pLmpvaW4oJy4nKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9lbmNvZGVWZXJzaW9uLmpzXG5cblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBFbmNvZGVzIGEgc2VtVmVyLWxpa2UgdmVyc2lvbiBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZW1WZXIgSW5wdXQgY2FuIGJlIGVpdGhlciB4LnkueiBvciB4LnlcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgYnVpbHQgZnJvbSAzIGNoYXJhY3RlcnMgb2YgdGhlIGJhc2U2NCB0YWJsZSB0aGF0IGVuY29kZSB0aGUgc2VtVmVyXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlVmVyc2lvbihzZW1WZXIpIHtcbiAgdmFyIHN0clJlc3VsdCA9ICcnOyAvLyBzdXBwb3J0IHgueSBvciB4LnkueiBieSB1c2luZyAncGFydHMnIGFzIGEgdmFyaWFibGVcblxuICB2YXIgcGFydHMgPSBzZW1WZXIuc3BsaXQoJy4nKS5sZW5ndGg7XG4gIHZhciBwYWRkZWRTdHJpbmdMZW5ndGggPSBwYXJ0cyAqIDY7IC8vIHdlIHBhZCB0byBlaXRoZXIgMTIgb3IgMTggY2hhcmFjdGVyc1xuICAvLyByZXZlcnNlIChidXQgZG9uJ3QgbWlycm9yKSB0aGUgdmVyc2lvbi4gMS41LjE1IC0+IDE1LjUuMVxuICAvLyBQYWQgdG8gdHdvIHNwYWNlcywgMTUuNS4xIC0+IDE1LjA1LjAxXG5cbiAgdmFyIHBhZGRlZFJldmVyc2VkU2VtdmVyID0gcmV2ZXJzZVZlcnNpb24oc2VtVmVyKTsgLy8gdHVybiAxNS4wNS4wMSB0byBhIHN0cmluZyAnMTUwNTAxJyB0aGVuIHRvIGEgbnVtYmVyIDE1MDUwMVxuXG4gIHZhciBudW0gPSBwYXJzZUludChwYWRkZWRSZXZlcnNlZFNlbXZlci5zcGxpdCgnLicpLmpvaW4oJycpKTsgLy8gUmVwcmVzZW50IGFzIGJpbmFyeSwgYWRkIGxlZnQgcGFkZGluZyB0byAxMiBvciAxOCBjaGFyYWN0ZXJzLlxuICAvLyAxNTAsNTAxIC0+IDEwMDEwMDEwMTExMTEwMDEwMVxuXG4gIHZhciBwYWRkZWRCaW5hcnkgPSBudW0udG9TdHJpbmcoMik7XG4gIHBhZGRlZEJpbmFyeSA9IHN0cmluZ1BhZChwYWRkZWRCaW5hcnksIHBhZGRlZFN0cmluZ0xlbmd0aCwgJzAnKTsgLy8gU3RvcCBpbiBjYXNlIGFuIGludmFsaWQgdmVyc2lvbiBudW1iZXIgd2FzIHByb3ZpZGVkXG4gIC8vIHBhZGRlZEJpbmFyeSBtdXN0IGJlIGJ1aWx0IGZyb20gc2VjdGlvbnMgb2YgNiBiaXRzXG5cbiAgaWYgKHBhZGRlZEJpbmFyeS5sZW5ndGggJSA2ICE9PSAwKSB7XG4gICAgdGhyb3cgJ1ZlcnNpb24gbXVzdCBiZSBzbWFsbGVyIHRoYW4gNDMuMjEuMjYpJztcbiAgfSAvLyB0dXJuIGV2ZXJ5IDYgYml0cyBpbnRvIGEgY2hhcmFjdGVyIHVzaW5nIHRoZSBiYXNlNjRNYXBcblxuXG4gIHBhZGRlZEJpbmFyeS5tYXRjaCgvLnsxLDZ9L2cpLmZvckVhY2goZnVuY3Rpb24gKGJpdFN0cmluZykge1xuICAgIC8vIGNvbnNvbGUubG9nKGJpdFN0cmluZyk7XG4gICAgc3RyUmVzdWx0ICs9IGJhc2U2NE1hcFtiaXRTdHJpbmddO1xuICB9KTtcbiAgcmV0dXJuIHN0clJlc3VsdDtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9nZXRTREtBbmFseXRpY3NTaWduYXR1cmUuanNcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0cyB0aGUgU0RLIHNpZ25hdHVyZSBieSBlbmNvZGluZyB0aGUgU0RLIHZlcnNpb24gYW5kIHRlY2ggdmVyc2lvblxuICogQHBhcmFtIHt7XG4gKiAgICBbdGVjaFZlcnNpb25dOnN0cmluZyxcbiAqICAgIFtzZGtTZW12ZXJdOiBzdHJpbmcsXG4gKiAgICBbc2RrQ29kZV06IHN0cmluZyxcbiAqICAgIFtmZWF0dXJlXTogc3RyaW5nXG4gKiB9fSBhbmFseXRpY3NPcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHNka0FuYWx5dGljc1NpZ25hdHVyZVxuICovXG5cbmZ1bmN0aW9uIGdldFNES0FuYWx5dGljc1NpZ25hdHVyZSgpIHtcbiAgdmFyIGFuYWx5dGljc09wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHRyeSB7XG4gICAgdmFyIHR3b1BhcnRWZXJzaW9uID0gcmVtb3ZlUGF0Y2hGcm9tU2VtdmVyKGFuYWx5dGljc09wdGlvbnMudGVjaFZlcnNpb24pO1xuICAgIHZhciBlbmNvZGVkU0RLVmVyc2lvbiA9IGVuY29kZVZlcnNpb24oYW5hbHl0aWNzT3B0aW9ucy5zZGtTZW12ZXIpO1xuICAgIHZhciBlbmNvZGVkVGVjaFZlcnNpb24gPSBlbmNvZGVWZXJzaW9uKHR3b1BhcnRWZXJzaW9uKTtcbiAgICB2YXIgZmVhdHVyZUNvZGUgPSBhbmFseXRpY3NPcHRpb25zLmZlYXR1cmU7XG4gICAgdmFyIFNES0NvZGUgPSBhbmFseXRpY3NPcHRpb25zLnNka0NvZGU7XG4gICAgdmFyIGFsZ29WZXJzaW9uID0gJ0EnOyAvLyBUaGUgYWxnbyB2ZXJzaW9uIGlzIGRldGVybWluZWQgaGVyZSwgaXQgc2hvdWxkIG5vdCBiZSBhbiBhcmd1bWVudFxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGFsZ29WZXJzaW9uKS5jb25jYXQoU0RLQ29kZSkuY29uY2F0KGVuY29kZWRTREtWZXJzaW9uKS5jb25jYXQoZW5jb2RlZFRlY2hWZXJzaW9uKS5jb25jYXQoZmVhdHVyZUNvZGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRWl0aGVyIFNESyBvciBOb2RlIHZlcnNpb25zIHdlcmUgdW5wYXJzYWJsZVxuICAgIHJldHVybiAnRSc7XG4gIH1cbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgcGF0Y2ggdmVyc2lvbiBmcm9tIHRoZSBzZW12ZXIgaWYgaXQgZXhpc3RzXG4gKiAgICAgICAgICAgICAgVHVybnMgeC55LnogT1IgeC55IGludG8geC55XG4gKiBAcGFyYW0geyd4LnkueicgfHwgJ3gueScgfHwgc3RyaW5nfSBzZW1WZXJTdHJcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVQYXRjaEZyb21TZW12ZXIoc2VtVmVyU3RyKSB7XG4gIHZhciBwYXJ0cyA9IHNlbVZlclN0ci5zcGxpdCgnLicpO1xuICByZXR1cm4gXCJcIi5jb25jYXQocGFydHNbMF0sIFwiLlwiKS5jb25jYXQocGFydHNbMV0pO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL2dldEFuYWx5dGljc09wdGlvbnMuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIEdldHMgdGhlIGFuYWx5dGljc09wdGlvbnMgZnJvbSBvcHRpb25zLSBzaG91bGQgaW5jbHVkZSBzZGtTZW12ZXIsIHRlY2hWZXJzaW9uLCBzZGtDb2RlLCBhbmQgZmVhdHVyZVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHt7c2RrU2VtdmVyOiAoc3RyaW5nKSwgc2RrQ29kZSwgZmVhdHVyZTogc3RyaW5nLCB0ZWNoVmVyc2lvbjogKHN0cmluZyl9IHx8IHt9fVxuICovXG5mdW5jdGlvbiBnZXRBbmFseXRpY3NPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIGFuYWx5dGljc09wdGlvbnMgPSB7XG4gICAgc2RrU2VtdmVyOiBvcHRpb25zLnNka1NlbXZlcixcbiAgICB0ZWNoVmVyc2lvbjogb3B0aW9ucy50ZWNoVmVyc2lvbixcbiAgICBzZGtDb2RlOiBvcHRpb25zLnNka0NvZGUsXG4gICAgZmVhdHVyZTogJzAnXG4gIH07XG5cbiAgaWYgKG9wdGlvbnMudXJsQW5hbHl0aWNzKSB7XG4gICAgaWYgKG9wdGlvbnMuYWNjZXNzaWJpbGl0eSkge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0QnO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0MnO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZSA9ICdBJztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wbGFjZWhvbGRlcikge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0InO1xuICAgIH1cblxuICAgIHJldHVybiBhbmFseXRpY3NPcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2Fzc2lnblwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvYXNzaWduXCIsXCJhbWRcIjpcImxvZGFzaC9hc3NpZ25cIixcInJvb3RcIjpbXCJfXCIsXCJhc3NpZ25cIl19XG52YXIgYXNzaWduX3Jvb3RfYXNzaWduXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvYXNzaWduXCIpO1xudmFyIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihhc3NpZ25fcm9vdF9hc3NpZ25fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2Nsb25lRGVlcFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvY2xvbmVEZWVwXCIsXCJhbWRcIjpcImxvZGFzaC9jbG9uZURlZXBcIixcInJvb3RcIjpbXCJfXCIsXCJjbG9uZURlZXBcIl19XG52YXIgY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvY2xvbmVEZWVwXCIpO1xudmFyIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2NvbXBhY3RcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2NvbXBhY3RcIixcImFtZFwiOlwibG9kYXNoL2NvbXBhY3RcIixcInJvb3RcIjpbXCJfXCIsXCJjb21wYWN0XCJdfVxudmFyIGNvbXBhY3Rfcm9vdF9jb21wYWN0XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvY29tcGFjdFwiKTtcbnZhciBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb21wYWN0X3Jvb3RfY29tcGFjdF8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvZGlmZmVyZW5jZVwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvZGlmZmVyZW5jZVwiLFwiYW1kXCI6XCJsb2Rhc2gvZGlmZmVyZW5jZVwiLFwicm9vdFwiOltcIl9cIixcImRpZmZlcmVuY2VcIl19XG52YXIgZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9kaWZmZXJlbmNlXCIpO1xudmFyIGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9mdW5jdGlvbnNcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2Z1bmN0aW9uc1wiLFwiYW1kXCI6XCJsb2Rhc2gvZnVuY3Rpb25zXCIsXCJyb290XCI6W1wiX1wiLFwiZnVuY3Rpb25zXCJdfVxudmFyIGZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2Z1bmN0aW9uc1wiKTtcbnZhciBmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pZGVudGl0eVwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaWRlbnRpdHlcIixcImFtZFwiOlwibG9kYXNoL2lkZW50aXR5XCIsXCJyb290XCI6W1wiX1wiLFwiaWRlbnRpdHlcIl19XG52YXIgaWRlbnRpdHlfcm9vdF9pZGVudGl0eV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lkZW50aXR5XCIpO1xudmFyIGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaWRlbnRpdHlfcm9vdF9pZGVudGl0eV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaW5jbHVkZXNcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2luY2x1ZGVzXCIsXCJhbWRcIjpcImxvZGFzaC9pbmNsdWRlc1wiLFwicm9vdFwiOltcIl9cIixcImluY2x1ZGVzXCJdfVxudmFyIGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pbmNsdWRlc1wiKTtcbnZhciBpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzQXJyYXlcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzQXJyYXlcIixcImFtZFwiOlwibG9kYXNoL2lzQXJyYXlcIixcInJvb3RcIjpbXCJfXCIsXCJpc0FycmF5XCJdfVxudmFyIGlzQXJyYXlfcm9vdF9pc0FycmF5XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNBcnJheVwiKTtcbnZhciBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc0FycmF5X3Jvb3RfaXNBcnJheV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiLFwiYW1kXCI6XCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiLFwicm9vdFwiOltcIl9cIixcImlzUGxhaW5PYmplY3RcIl19XG52YXIgaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIpO1xudmFyIGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0Xyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc1N0cmluZ1wiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaXNTdHJpbmdcIixcImFtZFwiOlwibG9kYXNoL2lzU3RyaW5nXCIsXCJyb290XCI6W1wiX1wiLFwiaXNTdHJpbmdcIl19XG52YXIgaXNTdHJpbmdfcm9vdF9pc1N0cmluZ18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzU3RyaW5nXCIpO1xudmFyIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNTdHJpbmdfcm9vdF9pc1N0cmluZ18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvbWVyZ2VcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL21lcmdlXCIsXCJhbWRcIjpcImxvZGFzaC9tZXJnZVwiLFwicm9vdFwiOltcIl9cIixcIm1lcmdlXCJdfVxudmFyIG1lcmdlX3Jvb3RfbWVyZ2VfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9tZXJnZVwiKTtcbnZhciBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKG1lcmdlX3Jvb3RfbWVyZ2VfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzRWxlbWVudFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaXNFbGVtZW50XCIsXCJhbWRcIjpcImxvZGFzaC9pc0VsZW1lbnRcIixcInJvb3RcIjpbXCJfXCIsXCJpc0VsZW1lbnRcIl19XG52YXIgaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNFbGVtZW50XCIpO1xudmFyIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzRnVuY3Rpb25cIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzRnVuY3Rpb25cIixcImFtZFwiOlwibG9kYXNoL2lzRnVuY3Rpb25cIixcInJvb3RcIjpbXCJfXCIsXCJpc0Z1bmN0aW9uXCJdfVxudmFyIGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNGdW5jdGlvblwiKTtcbnZhciBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvdHJpbVwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvdHJpbVwiLFwiYW1kXCI6XCJsb2Rhc2gvdHJpbVwiLFwicm9vdFwiOltcIl9cIixcInRyaW1cIl19XG52YXIgdHJpbV9yb290X3RyaW1fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC90cmltXCIpO1xudmFyIHRyaW1fcm9vdF90cmltX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHRyaW1fcm9vdF90cmltXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvbGF6eUxvYWQuanNcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuLypcbiAqIEluY2x1ZGVzIHV0aWxpdHkgbWV0aG9kcyBmb3IgbGF6eSBsb2FkaW5nIG1lZGlhXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBJbnRlcnNlY3Rpb25PYnNlcnZlciBpcyBzdXBwb3J0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyIGlzIGRlZmluZWRcbiAqL1xuZnVuY3Rpb24gaXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnRlZCgpIHtcbiAgLy8gQ2hlY2sgdGhhdCAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXInIHByb3BlcnR5IGlzIGRlZmluZWQgb24gd2luZG93XG4gIHJldHVybiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlcjtcbn1cbi8qKlxuICogQ2hlY2sgaWYgbmF0aXZlIGxhenkgbG9hZGluZyBpcyBzdXBwb3J0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgJ2xvYWRpbmcnIHByb3BlcnR5IGlzIGRlZmluZWQgZm9yIEhUTUxJbWFnZUVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkKCkge1xuICByZXR1cm4gKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoSFRNTEltYWdlRWxlbWVudCkpID09PSBcIm9iamVjdFwiICYmIEhUTUxJbWFnZUVsZW1lbnQucHJvdG90eXBlLmxvYWRpbmc7XG59XG4vKipcbiAqIENhbGxzIG9uSW50ZXJzZWN0KCkgd2hlbiBpbnRlcnNlY3Rpb24gaXMgZGV0ZWN0ZWQsIG9yIHdoZW5cbiAqIG5vIG5hdGl2ZSBsYXp5IGxvYWRpbmcgb3Igd2hlbiBJbnRlcnNlY3Rpb25PYnNlcnZlciBpc24ndCBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gdGhlIGVsZW1lbnQgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25JbnRlcnNlY3QgLSBjYWxsZWQgd2hlbiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBpbiB2aWV3XG4gKi9cblxuZnVuY3Rpb24gZGV0ZWN0SW50ZXJzZWN0aW9uKGVsLCBvbkludGVyc2VjdCkge1xuICB0cnkge1xuICAgIGlmIChpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkKCkgfHwgIWlzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgLy8gUmV0dXJuIGlmIHRoZXJlJ3Mgbm8gbmVlZCBvciBwb3NzaWJpbGl0eSB0byBkZXRlY3QgaW50ZXJzZWN0aW9uXG4gICAgICBvbkludGVyc2VjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGV0ZWN0IGludGVyc2VjdGlvbiB3aXRoIGdpdmVuIGVsZW1lbnQgdXNpbmcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcblxuXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgIG9uSW50ZXJzZWN0KCk7XG4gICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVudHJ5LnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIHRocmVzaG9sZDogWzAsIDAuMDFdXG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvbkludGVyc2VjdCgpO1xuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb25zdGFudHMuanNcbnZhciBWRVJTSU9OID0gXCIyLjUuMFwiO1xudmFyIENGX1NIQVJFRF9DRE4gPSBcImQzanBsOTFweGV2YmtoLmNsb3VkZnJvbnQubmV0XCI7XG52YXIgT0xEX0FLQU1BSV9TSEFSRURfQ0ROID0gXCJjbG91ZGluYXJ5LWEuYWthbWFpaGQubmV0XCI7XG52YXIgQUtBTUFJX1NIQVJFRF9DRE4gPSBcInJlcy5jbG91ZGluYXJ5LmNvbVwiO1xudmFyIFNIQVJFRF9DRE4gPSBBS0FNQUlfU0hBUkVEX0NETjtcbnZhciBERUZBVUxUX1RJTUVPVVRfTVMgPSAxMDAwMDtcbnZhciBERUZBVUxUX1BPU1RFUl9PUFRJT05TID0ge1xuICBmb3JtYXQ6ICdqcGcnLFxuICByZXNvdXJjZV90eXBlOiAndmlkZW8nXG59O1xudmFyIERFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTID0gWyd3ZWJtJywgJ21wNCcsICdvZ3YnXTtcbnZhciBTRU9fVFlQRVMgPSB7XG4gIFwiaW1hZ2UvdXBsb2FkXCI6IFwiaW1hZ2VzXCIsXG4gIFwiaW1hZ2UvcHJpdmF0ZVwiOiBcInByaXZhdGVfaW1hZ2VzXCIsXG4gIFwiaW1hZ2UvYXV0aGVudGljYXRlZFwiOiBcImF1dGhlbnRpY2F0ZWRfaW1hZ2VzXCIsXG4gIFwicmF3L3VwbG9hZFwiOiBcImZpbGVzXCIsXG4gIFwidmlkZW8vdXBsb2FkXCI6IFwidmlkZW9zXCJcbn07XG4vKipcbiogQGNvbnN0IHtPYmplY3R9IENsb3VkaW5hcnkuREVGQVVMVF9JTUFHRV9QQVJBTVNcbiogRGVmYXVsdHMgdmFsdWVzIGZvciBpbWFnZSBwYXJhbWV0ZXJzLlxuKlxuKiAoUHJldmlvdXNseSBkZWZpbmVkIHVzaW5nIG9wdGlvbl9jb25zdW1lKCkgKVxuICovXG5cbnZhciBERUZBVUxUX0lNQUdFX1BBUkFNUyA9IHtcbiAgcmVzb3VyY2VfdHlwZTogXCJpbWFnZVwiLFxuICB0cmFuc2Zvcm1hdGlvbjogW10sXG4gIHR5cGU6ICd1cGxvYWQnXG59O1xuLyoqXG4qIERlZmF1bHRzIHZhbHVlcyBmb3IgdmlkZW8gcGFyYW1ldGVycy5cbiogQGNvbnN0IHtPYmplY3R9IENsb3VkaW5hcnkuREVGQVVMVF9WSURFT19QQVJBTVNcbiogKFByZXZpb3VzbHkgZGVmaW5lZCB1c2luZyBvcHRpb25fY29uc3VtZSgpIClcbiAqL1xuXG52YXIgREVGQVVMVF9WSURFT19QQVJBTVMgPSB7XG4gIGZhbGxiYWNrX2NvbnRlbnQ6ICcnLFxuICByZXNvdXJjZV90eXBlOiBcInZpZGVvXCIsXG4gIHNvdXJjZV90cmFuc2Zvcm1hdGlvbjoge30sXG4gIHNvdXJjZV90eXBlczogREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMsXG4gIHRyYW5zZm9ybWF0aW9uOiBbXSxcbiAgdHlwZTogJ3VwbG9hZCdcbn07XG4vKipcbiAqIFJlY29tbWVuZGVkIHNvdXJjZXMgZm9yIHZpZGVvIHRhZ1xuICogQGNvbnN0IHtPYmplY3R9IENsb3VkaW5hcnkuREVGQVVMVF9WSURFT19TT1VSQ0VTXG4gKi9cblxudmFyIERFRkFVTFRfVklERU9fU09VUkNFUyA9IFt7XG4gIHR5cGU6IFwibXA0XCIsXG4gIGNvZGVjczogXCJoZXYxXCIsXG4gIHRyYW5zZm9ybWF0aW9uczoge1xuICAgIHZpZGVvX2NvZGVjOiBcImgyNjVcIlxuICB9XG59LCB7XG4gIHR5cGU6IFwid2VibVwiLFxuICBjb2RlY3M6IFwidnA5XCIsXG4gIHRyYW5zZm9ybWF0aW9uczoge1xuICAgIHZpZGVvX2NvZGVjOiBcInZwOVwiXG4gIH1cbn0sIHtcbiAgdHlwZTogXCJtcDRcIixcbiAgdHJhbnNmb3JtYXRpb25zOiB7XG4gICAgdmlkZW9fY29kZWM6IFwiYXV0b1wiXG4gIH1cbn0sIHtcbiAgdHlwZTogXCJ3ZWJtXCIsXG4gIHRyYW5zZm9ybWF0aW9uczoge1xuICAgIHZpZGVvX2NvZGVjOiBcImF1dG9cIlxuICB9XG59XTtcbnZhciBERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFUyA9IHtcbiAgc2VlVGhydTogJ2h0dHBzOi8vdW5wa2cuY29tL3NlZXRocnVANC9kaXN0L3NlZVRocnUubWluLmpzJ1xufTtcbi8qKlxuICogUHJlZGVmaW5lZCBwbGFjZWhvbGRlciB0cmFuc2Zvcm1hdGlvbnNcbiAqIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LlBMQUNFSE9MREVSX0lNQUdFX01PREVTXG4gKi9cblxudmFyIFBMQUNFSE9MREVSX0lNQUdFX01PREVTID0ge1xuICAnYmx1cic6IFt7XG4gICAgZWZmZWN0OiAnYmx1cjoyMDAwJyxcbiAgICBxdWFsaXR5OiAxLFxuICAgIGZldGNoX2Zvcm1hdDogJ2F1dG8nXG4gIH1dLFxuICAvLyBEZWZhdWx0XG4gICdwaXhlbGF0ZSc6IFt7XG4gICAgZWZmZWN0OiAncGl4ZWxhdGUnLFxuICAgIHF1YWxpdHk6IDEsXG4gICAgZmV0Y2hfZm9ybWF0OiAnYXV0bydcbiAgfV0sXG4gIC8vIEdlbmVyYXRlcyBhIHBpeGVsIHNpemUgaW1hZ2Ugd2hpY2ggY29sb3IgaXMgdGhlIHByZWRvbWluYW50IGNvbG9yIG9mIHRoZSBvcmlnaW5hbCBpbWFnZS5cbiAgJ3ByZWRvbWluYW50LWNvbG9yLXBpeGVsJzogW3tcbiAgICB3aWR0aDogJ2l3X2Rpdl8yJyxcbiAgICBhc3BlY3RfcmF0aW86IDEsXG4gICAgY3JvcDogJ3BhZCcsXG4gICAgYmFja2dyb3VuZDogJ2F1dG8nXG4gIH0sIHtcbiAgICBjcm9wOiAnY3JvcCcsXG4gICAgd2lkdGg6IDEsXG4gICAgaGVpZ2h0OiAxLFxuICAgIGdyYXZpdHk6ICdub3J0aF9lYXN0J1xuICB9LCB7XG4gICAgZmV0Y2hfZm9ybWF0OiAnYXV0bycsXG4gICAgcXVhbGl0eTogJ2F1dG8nXG4gIH1dLFxuICAvLyBHZW5lcmF0ZXMgYW4gaW1hZ2Ugd2hpY2ggY29sb3IgaXMgdGhlIHByZWRvbWluYW50IGNvbG9yIG9mIHRoZSBvcmlnaW5hbCBpbWFnZS5cbiAgJ3ByZWRvbWluYW50LWNvbG9yJzogW3tcbiAgICB2YXJpYWJsZXM6IFtbJyRjdXJyV2lkdGgnLCAndyddLCBbJyRjdXJySGVpZ2h0JywgJ2gnXV1cbiAgfSwge1xuICAgIHdpZHRoOiAnaXdfZGl2XzInLFxuICAgIGFzcGVjdF9yYXRpbzogMSxcbiAgICBjcm9wOiAncGFkJyxcbiAgICBiYWNrZ3JvdW5kOiAnYXV0bydcbiAgfSwge1xuICAgIGNyb3A6ICdjcm9wJyxcbiAgICB3aWR0aDogMTAsXG4gICAgaGVpZ2h0OiAxMCxcbiAgICBncmF2aXR5OiAnbm9ydGhfZWFzdCdcbiAgfSwge1xuICAgIHdpZHRoOiAnJGN1cnJXaWR0aCcsXG4gICAgaGVpZ2h0OiAnJGN1cnJIZWlnaHQnLFxuICAgIGNyb3A6ICdmaWxsJ1xuICB9LCB7XG4gICAgZmV0Y2hfZm9ybWF0OiAnYXV0bycsXG4gICAgcXVhbGl0eTogJ2F1dG8nXG4gIH1dLFxuICAndmVjdG9yaXplJzogW3tcbiAgICBlZmZlY3Q6ICd2ZWN0b3JpemU6MzowLjEnLFxuICAgIGZldGNoX2Zvcm1hdDogJ3N2ZydcbiAgfV1cbn07XG4vKipcbiAqIFByZWRlZmluZWQgYWNjZXNzaWJpbGl0eSB0cmFuc2Zvcm1hdGlvbnNcbiAqIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkFDQ0VTU0lCSUxJVFlfTU9ERVNcbiAqL1xuXG52YXIgQUNDRVNTSUJJTElUWV9NT0RFUyA9IHtcbiAgZGFya21vZGU6ICd0aW50Ojc1OmJsYWNrJyxcbiAgYnJpZ2h0bW9kZTogJ3RpbnQ6NTA6d2hpdGUnLFxuICBtb25vY2hyb21lOiAnZ3JheXNjYWxlJyxcbiAgY29sb3JibGluZDogJ2Fzc2lzdF9jb2xvcmJsaW5kJ1xufTtcbi8qKlxuICogQSBsaXN0IG9mIGtleXMgdXNlZCBieSB0aGUgdXJsKCkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBVUkxfS0VZUyA9IFsnYWNjZXNzaWJpbGl0eScsICdhcGlfc2VjcmV0JywgJ2F1dGhfdG9rZW4nLCAnY2RuX3N1YmRvbWFpbicsICdjbG91ZF9uYW1lJywgJ2NuYW1lJywgJ2Zvcm1hdCcsICdwbGFjZWhvbGRlcicsICdwcml2YXRlX2NkbicsICdyZXNvdXJjZV90eXBlJywgJ3NlY3VyZScsICdzZWN1cmVfY2RuX3N1YmRvbWFpbicsICdzZWN1cmVfZGlzdHJpYnV0aW9uJywgJ3Nob3J0ZW4nLCAnc2lnbl91cmwnLCAnc2lnbmF0dXJlJywgJ3NzbF9kZXRlY3RlZCcsICd0eXBlJywgJ3VybF9zdWZmaXgnLCAndXNlX3Jvb3RfcGF0aCcsICd2ZXJzaW9uJ107XG4vKipcbiAqIFRoZSByZXNvdXJjZSBzdG9yYWdlIHR5cGVcbiAqIEB0eXBlZGVmIHR5cGVcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICd1cGxvYWQnIEEgcmVzb3VyY2UgdXBsb2FkZWQgZGlyZWN0bHkgdG8gQ2xvdWRpbmFyeVxuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnZmV0Y2gnIEEgcmVzb3VyY2UgZmV0Y2hlZCBieSBDbG91ZGluYXJ5IGZyb20gYSAzcmQgcGFydHkgc3RvcmFnZVxuICogQHByb3BlcnR5ICB7c3RyaW5nfSAncHJpdmF0ZSdcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ2F1dGhlbnRpY2F0ZWQnXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICdzcHJpdGUnXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICdmYWNlYm9vaydcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3R3aXR0ZXInXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICd5b3V0dWJlJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAndmltZW8nXG4gKlxuICovXG5cbi8qKlxuICogVGhlIHJlc291cmNlIHR5cGVcbiAqIEB0eXBlZGVmIHJlc291cmNlVHlwZVxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAnaW1hZ2UnIEFuIGltYWdlIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAndmlkZW8nIEEgdmlkZW8gZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9ICdyYXcnICAgQSByYXcgZmlsZVxuICovXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2Jhc2V1dGlsLmpzXG5mdW5jdGlvbiBiYXNldXRpbF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGJhc2V1dGlsX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIGJhc2V1dGlsX3R5cGVvZihvYmopOyB9XG5cbi8qXG4gKiBJbmNsdWRlcyBjb21tb24gdXRpbGl0eSBtZXRob2RzIGFuZCBzaGltc1xuICovXG5cblxuZnVuY3Rpb24gb21pdChvYmosIGtleXMpIHtcbiAgb2JqID0gb2JqIHx8IHt9O1xuICB2YXIgc3JjS2V5cyA9IE9iamVjdC5rZXlzKG9iaikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIWluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKGtleXMsIGtleSk7XG4gIH0pO1xuICB2YXIgZmlsdGVyZWQgPSB7fTtcbiAgc3JjS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gZmlsdGVyZWRba2V5XSA9IG9ialtrZXldO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcmVkO1xufVxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBhbGwgaXRlbXMgaW4gbGlzdCBhcmUgc3RyaW5nc1xuICogQGZ1bmN0aW9uIFV0aWwuYWxsU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IC0gYW4gYXJyYXkgb2YgaXRlbXNcbiAqL1xuXG52YXIgYmFzZXV0aWxfYWxsU3RyaW5ncyA9IGZ1bmN0aW9uIGFsbFN0cmluZ3MobGlzdCkge1xuICByZXR1cm4gbGlzdC5sZW5ndGggJiYgbGlzdC5ldmVyeShpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQuYSk7XG59O1xuLyoqXG4qIENyZWF0ZXMgYSBuZXcgYXJyYXkgd2l0aG91dCB0aGUgZ2l2ZW4gaXRlbS5cbiogQGZ1bmN0aW9uIFV0aWwud2l0aG91dFxuKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIG9yaWdpbmFsIGFycmF5XG4qIEBwYXJhbSB7Kn0gaXRlbSAtIHRoZSBpdGVtIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgbmV3IGFycmF5XG4qIEByZXR1cm4ge0FycmF5fSBhIG5ldyBhcnJheSBtYWRlIG9mIHRoZSBvcmlnaW5hbCBhcnJheSdzIGl0ZW1zIGV4Y2VwdCBmb3IgYGl0ZW1gXG4gKi9cblxudmFyIHdpdGhvdXQgPSBmdW5jdGlvbiB3aXRob3V0KGFycmF5LCBpdGVtKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdiAhPT0gaXRlbTtcbiAgfSk7XG59O1xuLyoqXG4qIFJldHVybiB0cnVlIGlzIHZhbHVlIGlzIGEgbnVtYmVyIG9yIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbnVtYmVyLlxuKiBAZnVuY3Rpb24gVXRpbC5pc051bWJlckxpa2VcbiogQHBhcmFtIHsqfSB2YWx1ZVxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWx1ZSBpcyBhIG51bWJlclxuKiBAZXhhbXBsZVxuKiAgICBVdGlsLmlzTnVtYmVyKDApIC8vIHRydWVcbiogICAgVXRpbC5pc051bWJlcihcIjEuM1wiKSAvLyB0cnVlXG4qICAgIFV0aWwuaXNOdW1iZXIoXCJcIikgLy8gZmFsc2VcbiogICAgVXRpbC5pc051bWJlcih1bmRlZmluZWQpIC8vIGZhbHNlXG4gKi9cblxudmFyIGlzTnVtYmVyTGlrZSA9IGZ1bmN0aW9uIGlzTnVtYmVyTGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufTtcbi8qKlxuICogRXNjYXBlIGFsbCBjaGFyYWN0ZXJzIG1hdGNoaW5nIHVuc2FmZSBpbiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKiBAZnVuY3Rpb24gVXRpbC5zbWFydEVzY2FwZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIHNvdXJjZSBzdHJpbmcgdG8gZXNjYXBlXG4gKiBAcGFyYW0ge1JlZ0V4cH0gdW5zYWZlIC0gY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgZXNjYXBlZFxuICogQHJldHVybiB7c3RyaW5nfSBlc2NhcGVkIHN0cmluZ1xuICovXG5cbnZhciBzbWFydEVzY2FwZSA9IGZ1bmN0aW9uIHNtYXJ0RXNjYXBlKHN0cmluZykge1xuICB2YXIgdW5zYWZlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAvKFteYS16QS1aMC05Xy5cXC1cXC86XSspL2c7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSh1bnNhZmUsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBtYXRjaC5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBcIiVcIiArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9KTtcbn07XG4vKipcbiAqIEFzc2lnbiB2YWx1ZXMgZnJvbSBzb3VyY2VzIGlmIHRoZXkgYXJlIG5vdCBkZWZpbmVkIGluIHRoZSBkZXN0aW5hdGlvbi5cbiAqIE9uY2UgYSB2YWx1ZSBpcyBzZXQgaXQgZG9lcyBub3QgY2hhbmdlXG4gKiBAZnVuY3Rpb24gVXRpbC5kZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIC0gdGhlIG9iamVjdCB0byBhc3NpZ24gZGVmYXVsdHMgdG9cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2UgLSB0aGUgc291cmNlIG9iamVjdChzKSB0byBhc3NpZ24gZGVmYXVsdHMgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fSBkZXN0aW5hdGlvbiBhZnRlciBpdCB3YXMgbW9kaWZpZWRcbiAqL1xuXG52YXIgZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyhkZXN0aW5hdGlvbikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gc291cmNlcy5yZWR1Y2UoZnVuY3Rpb24gKGRlc3QsIHNvdXJjZSkge1xuICAgIHZhciBrZXksIHZhbHVlO1xuXG4gICAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgICB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAoZGVzdFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVzdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3Q7XG4gIH0sIGRlc3RpbmF0aW9uKTtcbn07XG4vKioqKioqKioqKiogbG9kYXNoIGZ1bmN0aW9ucyAqL1xuXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG5cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuI2lzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4jaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4jaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5cbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlOyAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cblxuICB0eXBlID0gYmFzZXV0aWxfdHlwZW9mKHZhbHVlKTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufTtcbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbi8qKlxuKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4qIEBmdW5jdGlvbiBVdGlsLmlzRnVuY3Rpb25cbiogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4qIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4qIEBleGFtcGxlXG4qXG4qIGZ1bmN0aW9uIEZvbygpe307XG4qIGlzRnVuY3Rpb24oRm9vKTtcbiogLy8gPT4gdHJ1ZVxuKlxuKiBpc0Z1bmN0aW9uKC9hYmMvKTtcbiogLy8gPT4gZmFsc2VcbiAqL1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gIC8vIGFuZCBTYWZhcmkgOCB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IGZ1bmNUYWc7XG59O1xuLyoqKioqKioqKioqIGxvZGFzaCBmdW5jdGlvbnMgKi9cblxuLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgdG8gY3JlYXRlIGNvbXBvdW5kIHdvcmRzLiAqL1xuXG52YXIgcmVXb3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvd2VyLCB1cHBlcjtcbiAgdXBwZXIgPSAnW0EtWl0nO1xuICBsb3dlciA9ICdbYS16XSsnO1xuICByZXR1cm4gUmVnRXhwKHVwcGVyICsgJysoPz0nICsgdXBwZXIgKyBsb3dlciArICcpfCcgKyB1cHBlciArICc/JyArIGxvd2VyICsgJ3wnICsgdXBwZXIgKyAnK3xbMC05XSsnLCAnZycpO1xufSgpO1xuLyoqXG4qIENvbnZlcnQgc3RyaW5nIHRvIGNhbWVsQ2FzZVxuKiBAZnVuY3Rpb24gVXRpbC5jYW1lbENhc2VcbiogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIHRoZSBzdHJpbmcgdG8gY29udmVydFxuKiBAcmV0dXJuIHtzdHJpbmd9IGluIGNhbWVsQ2FzZSBmb3JtYXRcbiAqL1xuXG52YXIgY2FtZWxDYXNlID0gZnVuY3Rpb24gY2FtZWxDYXNlKHNvdXJjZSkge1xuICB2YXIgd29yZHMgPSBzb3VyY2UubWF0Y2gocmVXb3Jkcyk7XG4gIHdvcmRzID0gd29yZHMubWFwKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQuY2hhckF0KDApLnRvTG9jYWxlVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gIH0pO1xuICB3b3Jkc1swXSA9IHdvcmRzWzBdLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gIHJldHVybiB3b3Jkcy5qb2luKCcnKTtcbn07XG4vKipcbiAqIENvbnZlcnQgc3RyaW5nIHRvIHNuYWtlX2Nhc2VcbiAqIEBmdW5jdGlvbiBVdGlsLnNuYWtlQ2FzZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIHRoZSBzdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybiB7c3RyaW5nfSBpbiBzbmFrZV9jYXNlIGZvcm1hdFxuICovXG5cbnZhciBzbmFrZUNhc2UgPSBmdW5jdGlvbiBzbmFrZUNhc2Uoc291cmNlKSB7XG4gIHZhciB3b3JkcyA9IHNvdXJjZS5tYXRjaChyZVdvcmRzKTtcbiAgd29yZHMgPSB3b3Jkcy5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICByZXR1cm4gd29yZC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICB9KTtcbiAgcmV0dXJuIHdvcmRzLmpvaW4oJ18nKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IGZyb20gc291cmNlLCB3aXRoIHRoZSBrZXlzIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBjb252ZXJ0ZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IGNvbnZlcnRlclxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG52YXIgY29udmVydEtleXMgPSBmdW5jdGlvbiBjb252ZXJ0S2V5cyhzb3VyY2UsIGNvbnZlcnRlcikge1xuICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgcmVzdWx0ID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICBrZXkgPSBjb252ZXJ0ZXIoa2V5KTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRW1wdHkoa2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ3JlYXRlIGEgY29weSBvZiB0aGUgc291cmNlIG9iamVjdCB3aXRoIGFsbCBrZXlzIGluIGNhbWVsQ2FzZVxuICogQGZ1bmN0aW9uIFV0aWwud2l0aENhbWVsQ2FzZUtleXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBvYmplY3QgdG8gY29weVxuICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3RcbiAqL1xuXG52YXIgd2l0aENhbWVsQ2FzZUtleXMgPSBmdW5jdGlvbiB3aXRoQ2FtZWxDYXNlS2V5cyhzb3VyY2UpIHtcbiAgcmV0dXJuIGNvbnZlcnRLZXlzKHNvdXJjZSwgY2FtZWxDYXNlKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHNvdXJjZSBvYmplY3Qgd2l0aCBhbGwga2V5cyBpbiBzbmFrZV9jYXNlXG4gKiBAZnVuY3Rpb24gVXRpbC53aXRoU25ha2VDYXNlS2V5c1xuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gdGhlIG9iamVjdCB0byBjb3B5XG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdFxuICovXG5cbnZhciB3aXRoU25ha2VDYXNlS2V5cyA9IGZ1bmN0aW9uIHdpdGhTbmFrZUNhc2VLZXlzKHNvdXJjZSkge1xuICByZXR1cm4gY29udmVydEtleXMoc291cmNlLCBzbmFrZUNhc2UpO1xufTsgLy8gQnJvd3NlclxuLy8gTm9kZS5qc1xuXG52YXIgYmFzZTY0RW5jb2RlID0gdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnICYmIGlzRnVuY3Rpb24oYnRvYSkgPyBidG9hIDogdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNGdW5jdGlvbihCdWZmZXIpID8gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGlmICghKGlucHV0IGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIGlucHV0ID0gbmV3IEJ1ZmZlci5mcm9tKFN0cmluZyhpbnB1dCksICdiaW5hcnknKTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dC50b1N0cmluZygnYmFzZTY0Jyk7XG59IDogZnVuY3Rpb24gKGlucHV0KSB7XG4gIHRocm93IG5ldyBFcnJvcihcIk5vIGJhc2U2NCBlbmNvZGluZyBmdW5jdGlvbiBmb3VuZFwiKTtcbn07XG4vKipcbiogUmV0dXJucyB0aGUgQmFzZTY0LWRlY29kZWQgdmVyc2lvbiBvZiB1cmwuPGJyPlxuKiBUaGlzIG1ldGhvZCBkZWxlZ2F0ZXMgdG8gYGJ0b2FgIGlmIHByZXNlbnQuIE90aGVyd2lzZSBpdCB0cmllcyBgQnVmZmVyYC5cbiogQGZ1bmN0aW9uIFV0aWwuYmFzZTY0RW5jb2RlVVJMXG4qIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSB0aGUgdXJsIHRvIGVuY29kZS4gdGhlIHZhbHVlIGlzIFVSSWRlY29kZWQgYW5kIHRoZW4gcmUtZW5jb2RlZCBiZWZvcmUgY29udmVydGluZyB0byBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiogQHJldHVybiB7c3RyaW5nfSB0aGUgYmFzZTY0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBVUkxcbiAqL1xuXG52YXIgYmFzZTY0RW5jb2RlVVJMID0gZnVuY3Rpb24gYmFzZTY0RW5jb2RlVVJMKHVybCkge1xuICB0cnkge1xuICAgIHVybCA9IGRlY29kZVVSSSh1cmwpO1xuICB9IGZpbmFsbHkge1xuICAgIHVybCA9IGVuY29kZVVSSSh1cmwpO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U2NEVuY29kZSh1cmwpO1xufTtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIG9ubHkgVVJMIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIG9ubHkgVVJMIHBhcmFtZXRlcnNcbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0VXJsUGFyYW1zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFVSTF9LRVlTLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICBpZiAob3B0aW9uc1trZXldICE9IG51bGwpIHtcbiAgICAgIG9ialtrZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn1cbi8qKlxuICogSGFuZGxlIHRoZSBmb3JtYXQgcGFyYW1ldGVyIGZvciBmZXRjaCB1cmxzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG9wdGlvbnMgdXJsIGFuZCB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zLiBUaGlzIGFyZ3VtZW50IG1heSBiZSBjaGFuZ2VkIGJ5IHRoZSBmdW5jdGlvbiFcbiAqL1xuXG5mdW5jdGlvbiBwYXRjaEZldGNoRm9ybWF0KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnR5cGUgPT09IFwiZmV0Y2hcIikge1xuICAgIGlmIChvcHRpb25zLmZldGNoX2Zvcm1hdCA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zLmZldGNoX2Zvcm1hdCA9IG9wdGlvbkNvbnN1bWUob3B0aW9ucywgXCJmb3JtYXRcIik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIERlbGV0ZXMgYG9wdGlvbl9uYW1lYCBmcm9tIGBvcHRpb25zYCBhbmQgcmV0dXJuIHRoZSB2YWx1ZSBpZiBwcmVzZW50LlxuICogSWYgYG9wdGlvbnNgIGRvZXNuJ3QgY29udGFpbiBgb3B0aW9uX25hbWVgIHRoZSBkZWZhdWx0IHZhbHVlIGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uX25hbWUgdGhlIG5hbWUgKGtleSkgb2YgdGhlIGRlc2lyZWQgdmFsdWVcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRfdmFsdWVdIHRoZSB2YWx1ZSB0byByZXR1cm4gaXMgb3B0aW9uX25hbWUgaXMgbWlzc2luZ1xuICovXG5cbmZ1bmN0aW9uIG9wdGlvbkNvbnN1bWUob3B0aW9ucywgb3B0aW9uX25hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9wdGlvbnNbb3B0aW9uX25hbWVdO1xuICBkZWxldGUgb3B0aW9uc1tvcHRpb25fbmFtZV07XG5cbiAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdF92YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgZW1wdHk6XG4gKiA8dWw+XG4gKiAgIDxsaT52YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZDwvbGk+XG4gKiAgIDxsaT52YWx1ZSBpcyBhbiBhcnJheSBvciBzdHJpbmcgb2YgbGVuZ3RoIDA8L2xpPlxuICogICA8bGk+dmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggbm8ga2V5czwvbGk+XG4gKiA8L3VsPlxuICogQGZ1bmN0aW9uIFV0aWwuaXNFbXB0eVxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWx1ZSBpcyBlbXB0eVxuICovXG5cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUubGVuZ3RoID09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZS5zaXplID09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdmFsdWUuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIGlmIChiYXNldXRpbF90eXBlb2YodmFsdWUpID09IFwib2JqZWN0XCIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9icm93c2VyLmpzXG4vKipcbiAqIEJhc2VkIG9uIHZpZGVvLmpzIGltcGxlbWVudGF0aW9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvYmxvYi80MjM4ZjVjMWQ4ODg5MDU0NzE1M2U3ZTFkZTdiZDBkMWQ4ZTBiMjM2L3NyYy9qcy91dGlscy9icm93c2VyLmpzXG4gKi9cblxuLyoqXG4qIFJldHJpZXZlIGZyb20gdGhlIG5hdmlnYXRvciB0aGUgdXNlciBhZ2VudCBwcm9wZXJ0eS5cbiogQHJldHVybnMgdXNlciBhZ2VudCBwcm9wZXJ0eS5cbiovXG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbn1cbi8qKlxuICogRGV0ZWN0IGlmIGN1cnJlbnQgYnJvd3NlciBpcyBhbnkgQW5kcm9pZFxuICogQHJldHVybnMgdHJ1ZSBpZiBjdXJyZW50IGJyb3dzZXIgaXMgQW5kcm9pZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIHJldHVybiAvQW5kcm9pZC9pLnRlc3QodXNlckFnZW50KTtcbn1cbi8qKlxuICogRGV0ZWN0IGlmIGN1cnJlbnQgYnJvd3NlciBpcyBhbnkgRWRnZVxuICogQHJldHVybnMgdHJ1ZSBpZiBjdXJyZW50IGJyb3dzZXIgaXMgRWRnZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzRWRnZSgpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICByZXR1cm4gL0VkZy9pLnRlc3QodXNlckFnZW50KTtcbn1cbi8qKlxuICogRGV0ZWN0IGlmIGN1cnJlbnQgYnJvd3NlciBpcyBjaHJvbWUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgYnJvd3NlciBpcyBDaHJvbWUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICByZXR1cm4gIWlzRWRnZSgpICYmICgvQ2hyb21lL2kudGVzdCh1c2VyQWdlbnQpIHx8IC9DcmlPUy9pLnRlc3QodXNlckFnZW50KSk7XG59XG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgU2FmYXJpLlxuICogQHJldHVybnMgdHJ1ZSBpZiBjdXJyZW50IGJyb3dzZXIgaXMgU2FmYXJpLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIC8vIFVzZXIgYWdlbnRzIGZvciBvdGhlciBicm93c2VycyBtaWdodCBpbmNsdWRlIFwiU2FmYXJpXCIgc28gd2UgbXVzdCBleGNsdWRlIHRoZW0uXG4gIC8vIEZvciBleGFtcGxlIC0gdGhpcyBpcyB0aGUgY2hyb21lIHVzZXIgYWdlbnQgb24gd2luZG93cyAxMDpcbiAgLy8gTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzk2LjAuNDY2NC4xMTAgU2FmYXJpLzUzNy4zNlxuICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIHJldHVybiAvU2FmYXJpL2kudGVzdCh1c2VyQWdlbnQpICYmICFpc0Nocm9tZSgpICYmICFpc0FuZHJvaWQoKSAmJiAhaXNFZGdlKCk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2xvZGFzaC5qc1xudmFyIG5vZGVDb250YWlucztcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIEluY2x1ZGVzIHV0aWxpdHkgbWV0aG9kcyBhbmQgbG9kYXNoIC8galF1ZXJ5IHNoaW1zXG4gKi9cblxuLyoqXG4gKiBHZXQgZGF0YSBmcm9tIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHVzZSBqUXVlcnkncyBgZGF0YSgpYCBtZXRob2QgaWYgaXQgaXMgYXZhaWxhYmxlLCBvdGhlcndpc2UgaXQgd2lsbCBnZXQgdGhlIGBkYXRhLWAgYXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBnZXQgdGhlIGRhdGEgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZGF0YSBpdGVtXG4gKiBAcmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBgbmFtZWBcbiAqIEBmdW5jdGlvbiBVdGlsLmdldERhdGFcbiAqL1xuXG52YXIgbG9kYXNoX2dldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhKGVsZW1lbnQsIG5hbWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmdldEF0dHJpYnV0ZSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLVwiLmNvbmNhdChuYW1lKSk7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5nZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHIoXCJkYXRhLVwiLmNvbmNhdChuYW1lKSk7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5kYXRhKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmRhdGEobmFtZSk7XG5cbiAgICBjYXNlICEoaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmZuICYmIGpRdWVyeS5mbi5kYXRhKSAmJiBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdCgpKGVsZW1lbnQpKTpcbiAgICAgIHJldHVybiBqUXVlcnkoZWxlbWVudCkuZGF0YShuYW1lKTtcbiAgfVxufTtcbi8qKlxuICogU2V0IGRhdGEgaW4gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIHdpbGwgdXNlIGpRdWVyeSdzIGBkYXRhKClgIG1ldGhvZCBpZiBpdCBpcyBhdmFpbGFibGUsIG90aGVyd2lzZSBpdCB3aWxsIHNldCB0aGUgYGRhdGEtYCBhdHRyaWJ1dGVcbiAqIEBmdW5jdGlvbiBVdGlsLnNldERhdGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIHNldCB0aGUgZGF0YSBpblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZGF0YSBpdGVtXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGJlIHNldFxuICpcbiAqL1xuXG52YXIgbG9kYXNoX3NldERhdGEgPSBmdW5jdGlvbiBzZXREYXRhKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQobmFtZSksIHZhbHVlKTtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnNldEF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuc2V0QXR0cihcImRhdGEtXCIuY29uY2F0KG5hbWUpLCB2YWx1ZSk7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5kYXRhKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmRhdGEobmFtZSwgdmFsdWUpO1xuXG4gICAgY2FzZSAhKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5mbiAmJiBqUXVlcnkuZm4uZGF0YSkgJiYgaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQoKShlbGVtZW50KSk6XG4gICAgICByZXR1cm4galF1ZXJ5KGVsZW1lbnQpLmRhdGEobmFtZSwgdmFsdWUpO1xuICB9XG59O1xuLyoqXG4gKiBHZXQgYXR0cmlidXRlIGZyb20gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIEBmdW5jdGlvbiBVdGlsLmdldEF0dHJpYnV0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgZm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHsqfSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICpcbiAqL1xuXG52YXIgbG9kYXNoX2dldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5nZXRBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuYXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5hdHRyKG5hbWUpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyKG5hbWUpO1xuICB9XG59O1xuLyoqXG4gKiBTZXQgYXR0cmlidXRlIGluIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBAZnVuY3Rpb24gVXRpbC5zZXRBdHRyaWJ1dGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIHNldCB0aGUgYXR0cmlidXRlIGZvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGJlIHNldFxuICovXG5cbnZhciBsb2Rhc2hfc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYXR0cihuYW1lLCB2YWx1ZSk7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHIobmFtZSwgdmFsdWUpO1xuICB9XG59O1xuLyoqXG4gKiBSZW1vdmUgYW4gYXR0cmlidXRlIGluIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBAZnVuY3Rpb24gVXRpbC5yZW1vdmVBdHRyaWJ1dGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIHNldCB0aGUgYXR0cmlidXRlIGZvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gKi9cblxudmFyIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbG9kYXNoX3NldEF0dHJpYnV0ZShlbGVtZW50LCB2b2lkIDApO1xuICB9XG59O1xuLyoqXG4gKiBTZXQgYSBncm91cCBvZiBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50XG4gKiBAZnVuY3Rpb24gVXRpbC5zZXRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZXMgZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIGEgaGFzaCBvZiBhdHRyaWJ1dGUgbmFtZXMgYW5kIHZhbHVlc1xuICovXG5cbnZhciBzZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBuYW1lLCByZXN1bHRzLCB2YWx1ZTtcbiAgcmVzdWx0cyA9IFtdO1xuXG4gIGZvciAobmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdHMucHVzaChsb2Rhc2hfc2V0QXR0cmlidXRlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMucHVzaChsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIG5hbWUpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn07XG4vKipcbiAqIENoZWNrcyBpZiBlbGVtZW50IGhhcyBhIGNzcyBjbGFzc1xuICogQGZ1bmN0aW9uIFV0aWwuaGFzQ2xhc3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBjbGFzcyBuYW1lXG4gQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGVsZW1lbnQgaGFzIHRoZSBjbGFzc1xuICovXG5cbnZhciBsb2Rhc2hfaGFzQ2xhc3MgPSBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gIGlmIChpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdCgpKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoXCJcXFxcYlwiLmNvbmNhdChuYW1lLCBcIlxcXFxiXCIpKSk7XG4gIH1cbn07XG4vKipcbiAqIEFkZCBjbGFzcyB0byB0aGUgZWxlbWVudFxuICogQGZ1bmN0aW9uIFV0aWwuYWRkQ2xhc3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBjbGFzcyBuYW1lIHRvIGFkZFxuICovXG5cbnZhciBsb2Rhc2hfYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gIGlmICghZWxlbWVudC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cChcIlxcXFxiXCIuY29uY2F0KG5hbWUsIFwiXFxcXGJcIikpKSkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTmFtZSA9IHRyaW1fcm9vdF90cmltX2RlZmF1bHQoKShcIlwiLmNvbmNhdChlbGVtZW50LmNsYXNzTmFtZSwgXCIgXCIpLmNvbmNhdChuYW1lKSk7XG4gIH1cbn07IC8vIFRoZSBmb2xsb3dpbmcgY29kZSBpcyB0YWtlbiBmcm9tIGpRdWVyeVxuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24gZ2V0U3R5bGVzKGVsZW0pIHtcbiAgLy8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcbiAgLy8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG4gIC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuICBpZiAoZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lm9wZW5lcikge1xuICAgIHJldHVybiBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcbiAgfVxuXG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcbn07XG52YXIgY3NzRXhwYW5kID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdO1xuXG5ub2RlQ29udGFpbnMgPSBmdW5jdGlvbiBub2RlQ29udGFpbnMoYSwgYikge1xuICB2YXIgYWRvd24sIGJ1cDtcbiAgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhO1xuICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcbiAgcmV0dXJuIGEgPT09IGJ1cCB8fCAhIShidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIGFkb3duLmNvbnRhaW5zKGJ1cCkpO1xufTsgLy8gVHJ1bmNhdGVkIHZlcnNpb24gb2YgalF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUpXG5cblxudmFyIGRvbVN0eWxlID0gZnVuY3Rpb24gZG9tU3R5bGUoZWxlbSwgbmFtZSkge1xuICBpZiAoISghZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUpKSB7XG4gICAgcmV0dXJuIGVsZW0uc3R5bGVbbmFtZV07XG4gIH1cbn07XG52YXIgY3VyQ1NTID0gZnVuY3Rpb24gY3VyQ1NTKGVsZW0sIG5hbWUsIGNvbXB1dGVkKSB7XG4gIHZhciBtYXhXaWR0aCwgbWluV2lkdGgsIHJldCwgcm1hcmdpbiwgc3R5bGUsIHdpZHRoO1xuICBybWFyZ2luID0gL15tYXJnaW4vO1xuICB3aWR0aCA9IHZvaWQgMDtcbiAgbWluV2lkdGggPSB2b2lkIDA7XG4gIG1heFdpZHRoID0gdm9pZCAwO1xuICByZXQgPSB2b2lkIDA7XG4gIHN0eWxlID0gZWxlbS5zdHlsZTtcbiAgY29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoZWxlbSk7XG5cbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgLy8gU3VwcG9ydDogSUU5XG4gICAgLy8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgKCMxMjUzNylcbiAgICByZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIHx8IGNvbXB1dGVkW25hbWVdO1xuICB9XG5cbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgaWYgKHJldCA9PT0gXCJcIiAmJiAhbm9kZUNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSkpIHtcbiAgICAgIHJldCA9IGRvbVN0eWxlKGVsZW0sIG5hbWUpO1xuICAgIH0gLy8gU3VwcG9ydDogaU9TIDwgNlxuICAgIC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcbiAgICAvLyBpT1MgPCA2IChhdCBsZWFzdCkgcmV0dXJucyBwZXJjZW50YWdlIGZvciBhIGxhcmdlciBzZXQgb2YgdmFsdWVzLCBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzXG4gICAgLy8gdGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cblxuICAgIGlmIChybnVtbm9ucHgudGVzdChyZXQpICYmIHJtYXJnaW4udGVzdChuYW1lKSkge1xuICAgICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgIG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG4gICAgICBtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoOyAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cbiAgICAgIHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcbiAgICAgIHJldCA9IGNvbXB1dGVkLndpZHRoOyAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cbiAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICBzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgICAgc3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB9XG4gIH0gLy8gU3VwcG9ydDogSUVcbiAgLy8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblxuXG4gIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXQgKyBcIlwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn07XG52YXIgY3NzVmFsdWUgPSBmdW5jdGlvbiBjc3NWYWx1ZShlbGVtLCBuYW1lLCBjb252ZXJ0LCBzdHlsZXMpIHtcbiAgdmFyIHZhbDtcbiAgdmFsID0gY3VyQ1NTKGVsZW0sIG5hbWUsIHN0eWxlcyk7XG5cbiAgaWYgKGNvbnZlcnQpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbn07XG52YXIgYXVnbWVudFdpZHRoT3JIZWlnaHQgPSBmdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcykge1xuICB2YXIgaSwgbGVuLCBzaWRlLCBzaWRlcywgdmFsOyAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cbiAgLy8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXG4gIGlmIChleHRyYSA9PT0gKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHNpZGVzID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gW1wiUmlnaHRcIiwgXCJMZWZ0XCJdIDogW1wiVG9wXCIsIFwiQm90dG9tXCJdO1xuICAgIHZhbCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzaWRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2lkZSA9IHNpZGVzW2ldO1xuXG4gICAgICBpZiAoZXh0cmEgPT09IFwibWFyZ2luXCIpIHtcbiAgICAgICAgLy8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuICAgICAgICB2YWwgKz0gY3NzVmFsdWUoZWxlbSwgZXh0cmEgKyBzaWRlLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgaWYgKGV4dHJhID09PSBcImNvbnRlbnRcIikge1xuICAgICAgICAgIC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuICAgICAgICAgIHZhbCAtPSBjc3NWYWx1ZShlbGVtLCBcInBhZGRpbmdcIi5jb25jYXQoc2lkZSksIHRydWUsIHN0eWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEgIT09IFwibWFyZ2luXCIpIHtcbiAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuICAgICAgICAgIHZhbCAtPSBjc3NWYWx1ZShlbGVtLCBcImJvcmRlclwiLmNvbmNhdChzaWRlLCBcIldpZHRoXCIpLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuICAgICAgICB2YWwgKz0gY3NzVmFsdWUoZWxlbSwgXCJwYWRkaW5nXCIuY29uY2F0KHNpZGUpLCB0cnVlLCBzdHlsZXMpO1xuXG4gICAgICAgIGlmIChleHRyYSAhPT0gXCJwYWRkaW5nXCIpIHtcbiAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG4gICAgICAgICAgdmFsICs9IGNzc1ZhbHVlKGVsZW0sIFwiYm9yZGVyXCIuY29uY2F0KHNpZGUsIFwiV2lkdGhcIiksIHRydWUsIHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG59O1xudmFyIHBudW0gPSAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2U7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpO1xudmFyIGdldFdpZHRoT3JIZWlnaHQgPSBmdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhKSB7XG4gIHZhciBpc0JvcmRlckJveCwgc3R5bGVzLCB2YWwsIHZhbHVlSXNCb3JkZXJCb3g7IC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cbiAgdmFsdWVJc0JvcmRlckJveCA9IHRydWU7XG4gIHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodDtcbiAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pO1xuICBpc0JvcmRlckJveCA9IGNzc1ZhbHVlKGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImJvcmRlci1ib3hcIjsgLy8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG4gIC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuICAvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2NjhcblxuICBpZiAodmFsIDw9IDAgfHwgdmFsID09IG51bGwpIHtcbiAgICAvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3NhcnlcbiAgICB2YWwgPSBjdXJDU1MoZWxlbSwgbmFtZSwgc3R5bGVzKTtcblxuICAgIGlmICh2YWwgPCAwIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgICB2YWwgPSBlbGVtLnN0eWxlW25hbWVdO1xuICAgIH1cblxuICAgIGlmIChybnVtbm9ucHgudGVzdCh2YWwpKSB7XG4gICAgICAvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG4gICAgLy8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuICAgIC8vICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCBhbmQgKHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSBvciB2YWwgaXMgZWxlbS5zdHlsZVtuYW1lXSlcblxuXG4gICAgdmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmIHZhbCA9PT0gZWxlbS5zdHlsZVtuYW1lXTsgLy8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXG4gICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpIHx8IDA7XG4gIH0gLy8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblxuXG4gIHJldHVybiB2YWwgKyBhdWdtZW50V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSB8fCAoaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpLCB2YWx1ZUlzQm9yZGVyQm94LCBzdHlsZXMpO1xufTtcbnZhciBsb2Rhc2hfd2lkdGggPSBmdW5jdGlvbiB3aWR0aChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW1lbnQsIFwid2lkdGhcIiwgXCJjb250ZW50XCIpO1xufTtcbi8qKlxuICogQGNsYXNzIFV0aWxcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBpdGVtIGlzIGEgc3RyaW5nXG4gKiBAZnVuY3Rpb24gVXRpbC5pc1N0cmluZ1xuICogQHBhcmFtIGl0ZW1cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGl0ZW0gaXMgYSBzdHJpbmdcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBpdGVtIGlzIGVtcHR5OlxuICogPHVsPlxuICogICA8bGk+aXRlbSBpcyBudWxsIG9yIHVuZGVmaW5lZDwvbGk+XG4gKiAgIDxsaT5pdGVtIGlzIGFuIGFycmF5IG9yIHN0cmluZyBvZiBsZW5ndGggMDwvbGk+XG4gKiAgIDxsaT5pdGVtIGlzIGFuIG9iamVjdCB3aXRoIG5vIGtleXM8L2xpPlxuICogPC91bD5cbiAqIEBmdW5jdGlvbiBVdGlsLmlzRW1wdHlcbiAqIEBwYXJhbSBpdGVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdGVtIGlzIGVtcHR5XG4gKi9cblxuLyoqXG4gKiBBc3NpZ24gc291cmNlIHByb3BlcnRpZXMgdG8gZGVzdGluYXRpb24uXG4gKiBJZiB0aGUgcHJvcGVydHkgaXMgYW4gb2JqZWN0IGl0IGlzIGFzc2lnbmVkIGFzIGEgd2hvbGUsIG92ZXJyaWRpbmcgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBmdW5jdGlvbiBVdGlsLmFzc2lnblxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIC0gdGhlIG9iamVjdCB0byBhc3NpZ24gdG9cbiAqL1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGFzc2lnbiBzb3VyY2UgcHJvcGVydGllcyB0byBkZXN0aW5hdGlvblxuICogQGZ1bmN0aW9uIFV0aWwubWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiAtIHRoZSBvYmplY3QgdG8gYXNzaWduIHRvXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjb3B5IG9mIHRoZSBnaXZlbiBvYmplY3QsIGluY2x1ZGluZyBhbGwgaW50ZXJuYWwgb2JqZWN0cy5cbiAqIEBmdW5jdGlvbiBVdGlsLmNsb25lRGVlcFxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gdGhlIG9iamVjdCB0byBjbG9uZVxuICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBkZWVwIGNvcHkgb2YgdGhlIG9iamVjdFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSBmcm9tIHRoZSBwYXJhbWV0ZXIgd2l0aCBcImZhbHNleVwiIHZhbHVlcyByZW1vdmVkXG4gKiBAZnVuY3Rpb24gVXRpbC5jb21wYWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIHRoZSBhcnJheSB0byByZW1vdmUgdmFsdWVzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyBhcnJheSB3aXRob3V0IGZhbHNleSB2YWx1ZXNcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gaXRlbSBpcyBpbmNsdWRlZCBpbiB0aGUgZ2l2ZW4gYXJyYXlcbiAqIEBmdW5jdGlvbiBVdGlsLmNvbnRhaW5zXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIHRoZSBhcnJheSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSB7Kn0gaXRlbSAtIHRoZSBpdGVtIHRvIHNlYXJjaCBmb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGl0ZW0gaXMgaW5jbHVkZWQgaW4gdGhlIGFycmF5XG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHZhbHVlcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhhdCBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlciBhcnJheVxuICogQGZ1bmN0aW9uIFV0aWwuZGlmZmVyZW5jZVxuICogQHBhcmFtIHtBcnJheX0gYXJyIC0gdGhlIGFycmF5IHRvIHNlbGVjdCBmcm9tXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgLSB2YWx1ZXMgdG8gZmlsdGVyIGZyb20gYXJyXG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIGZpbHRlcmVkIHZhbHVlc1xuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBmdW5jdGlvbiBuYW1lcyBpbiBvYmpcbiAqIEBmdW5jdGlvbiBVdGlsLmZ1bmN0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIHRoZSBvYmplY3QgdG8gaW5zcGVjdFxuICogQHJldHVybiB7QXJyYXl9IGEgbGlzdCBvZiBmdW5jdGlvbnMgb2Ygb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm92aWRlZCB2YWx1ZS4gVGhpcyBmdW5jdGlvbnMgaXMgdXNlZCBhcyBhIGRlZmF1bHQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uIFV0aWwuaWRlbnRpdHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp9IHRoZSBwcm92aWRlZCB2YWx1ZVxuICovXG5cbi8qKlxuICogUmVtb3ZlIGxlYWRpbmcgb3IgdHJhaWxpbmcgc3BhY2VzIGZyb20gdGV4dFxuICogQGZ1bmN0aW9uIFV0aWwudHJpbVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGB0ZXh0YCB3aXRob3V0IGxlYWRpbmcgb3IgdHJhaWxpbmcgc3BhY2VzXG4gKi9cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2V4cHJlc3Npb24uanNcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNmb3JtYXRpb24gZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uU3RyIC0gQW4gZXhwcmVzc2lvbiBpbiBzdHJpbmcgZm9ybWF0LlxuICogQGNsYXNzIEV4cHJlc3Npb25cbiAqIE5vcm1hbGx5IHRoaXMgY2xhc3MgaXMgbm90IGluc3RhbnRpYXRlZCBkaXJlY3RseVxuICovXG52YXIgRXhwcmVzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cHJlc3Npb24oZXhwcmVzc2lvblN0cikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHByZXNzaW9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAaW5uZXIgRXhwcmVzc2lvbi1leHByZXNzaW9uc1xuICAgICAqL1xuICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBbXTtcblxuICAgIGlmIChleHByZXNzaW9uU3RyICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChFeHByZXNzaW9uLm5vcm1hbGl6ZShleHByZXNzaW9uU3RyKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBjb25zdHJ1Y3RvciBtZXRob2RcbiAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24ubmV3XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEV4cHJlc3Npb24sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgZXhwcmVzc2lvblxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGV4cHJlc3Npb24gYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4gRXhwcmVzc2lvbi5ub3JtYWxpemUodGhpcy5leHByZXNzaW9ucy5qb2luKFwiX1wiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyZW50IHRyYW5zZm9ybWF0aW9uIG9mIHRoaXMgZXhwcmVzc2lvblxuICAgICAqIEByZXR1cm4gVHJhbnNmb3JtYXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGFyZW50IHRyYW5zZm9ybWF0aW9uIG9mIHRoaXMgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7VHJhbnNmb3JtYXRpb259IHRoZSBwYXJlbnQgdHJhbnNmb3JtYXRpb25cbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBleHByZXNzaW9uXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jcHJlZGljYXRlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmVkaWNhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlZGljYXRlKG5hbWUsIG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgaWYgKEV4cHJlc3Npb24uT1BFUkFUT1JTW29wZXJhdG9yXSAhPSBudWxsKSB7XG4gICAgICAgIG9wZXJhdG9yID0gRXhwcmVzc2lvbi5PUEVSQVRPUlNbb3BlcmF0b3JdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goXCJcIi5jb25jYXQobmFtZSwgXCJfXCIpLmNvbmNhdChvcGVyYXRvciwgXCJfXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI2FuZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuZCgpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChcImFuZFwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3IoKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goXCJvclwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25jbHVkZSBleHByZXNzaW9uXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jdGhlblxuICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybWF0aW9ufSB0aGUgdHJhbnNmb3JtYXRpb24gdGhpcyBleHByZXNzaW9uIGlzIGRlZmluZWQgZm9yXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0aGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRoZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnQoKVtcImlmXCJdKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI2hlaWdodFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoaXMgZXhwcmVzc2lvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlaWdodChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImhcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jd2lkdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwid1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNhc3BlY3RSYXRpb1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoaXMgZXhwcmVzc2lvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXNwZWN0UmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNwZWN0UmF0aW8ob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJhclwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNwYWdlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoaXMgZXhwcmVzc2lvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VDb3VudChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcInBjXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI2ZhY2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmYWNlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZUNvdW50KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiZmNcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoX3ZhbHVlKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goX3ZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6IFwibmV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXcoZXhwcmVzc2lvblN0cikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKGV4cHJlc3Npb25TdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgYSBzdHJpbmcgZXhwcmVzc2lvblxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I25vcm1hbGl6ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIGEgZXhwcmVzc2lvbiwgZS5nLiBcIncgZ3QgMTAwXCIsIFwid2lkdGhfZ3RfMTAwXCIsIFwid2lkdGggPiAxMDBcIlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIG5vcm1hbGl6ZWQgZm9ybSBvZiB0aGUgdmFsdWUgZXhwcmVzc2lvbiwgZS5nLiBcIndfZ3RfMTAwXCJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5vcm1hbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemUoZXhwcmVzc2lvbikge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgIH1cblxuICAgICAgZXhwcmVzc2lvbiA9IFN0cmluZyhleHByZXNzaW9uKTtcbiAgICAgIHZhciBvcGVyYXRvcnMgPSBcIlxcXFx8XFxcXHx8Pj18PD18JiZ8IT18Pnw9fDx8L3wtfFxcXFwrfFxcXFwqfFxcXFxeXCI7IC8vIG9wZXJhdG9yc1xuXG4gICAgICB2YXIgb3BlcmF0b3JzUGF0dGVybiA9IFwiKChcIiArIG9wZXJhdG9ycyArIFwiKSg/PVsgX10pKVwiO1xuICAgICAgdmFyIG9wZXJhdG9yc1JlcGxhY2VSRSA9IG5ldyBSZWdFeHAob3BlcmF0b3JzUGF0dGVybiwgXCJnXCIpO1xuICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVwbGFjZShvcGVyYXRvcnNSZXBsYWNlUkUsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gRXhwcmVzc2lvbi5PUEVSQVRPUlNbbWF0Y2hdO1xuICAgICAgfSk7IC8vIHByZWRlZmluZWQgdmFyaWFibGVzXG4gICAgICAvLyBUaGUgOiR7dn0gcGFydCBpcyB0byBwcmV2ZW50IG5vcm1hbGl6YXRpb24gb2YgdmFycyB3aXRoIGEgcHJlY2VkaW5nIGNvbG9uIChzdWNoIGFzIDpkdXJhdGlvbiksXG4gICAgICAvLyBJdCB3b24ndCBiZSBmb3VuZCBpbiBQUkVERUZJTkVEX1ZBUlMgYW5kIHNvIHdvbid0IGJlIG5vcm1hbGl6ZWQuXG4gICAgICAvLyBJdCBpcyBkb25lIGxpa2UgdGhpcyBiZWNhdXNlIGllMTEgZG9lcyBub3Qgc3VwcG9ydCByZWdleCBsb29rYmVoaW5kXG5cbiAgICAgIHZhciBwcmVkZWZpbmVkVmFyc1BhdHRlcm4gPSBcIihcIiArIE9iamVjdC5rZXlzKEV4cHJlc3Npb24uUFJFREVGSU5FRF9WQVJTKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIFwiOlwiLmNvbmNhdCh2LCBcInxcIikuY29uY2F0KHYpO1xuICAgICAgfSkuam9pbihcInxcIikgKyBcIilcIjtcbiAgICAgIHZhciB1c2VyVmFyaWFibGVQYXR0ZXJuID0gJyhcXFxcJF8qW15fIF0rKSc7XG4gICAgICB2YXIgdmFyaWFibGVzUmVwbGFjZVJFID0gbmV3IFJlZ0V4cChcIlwiLmNvbmNhdCh1c2VyVmFyaWFibGVQYXR0ZXJuLCBcInxcIikuY29uY2F0KHByZWRlZmluZWRWYXJzUGF0dGVybiksIFwiZ1wiKTtcbiAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2UodmFyaWFibGVzUmVwbGFjZVJFLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIEV4cHJlc3Npb24uUFJFREVGSU5FRF9WQVJTW21hdGNoXSB8fCBtYXRjaDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb24ucmVwbGFjZSgvWyBfXSsvZywgJ18nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFyaWFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhuYW1lKS52YWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwid2lkdGhcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLndpZHRoXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcIndpZHRoXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImhlaWdodFwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24uaGVpZ2h0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiaGVpZ2h0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImluaXRpYWxXaWR0aFwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24uaW5pdGlhbFdpZHRoXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbFdpZHRoKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiaW5pdGlhbFdpZHRoXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImluaXRpYWxIZWlnaHRcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmluaXRpYWxIZWlnaHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbEhlaWdodCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImluaXRpYWxIZWlnaHRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiYXNwZWN0UmF0aW9cIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmFzcGVjdFJhdGlvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbygpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImFzcGVjdFJhdGlvXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImluaXRpYWxBc3BlY3RSYXRpb1wiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24uaW5pdGlhbEFzcGVjdFJhdGlvXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsQXNwZWN0UmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbEFzcGVjdFJhdGlvKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiaW5pdGlhbEFzcGVjdFJhdGlvXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInBhZ2VDb3VudFwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24ucGFnZUNvdW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYWdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZUNvdW50KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwicGFnZUNvdW50XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJmYWNlQ291bnRcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmZhY2VDb3VudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFjZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY2VDb3VudCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImZhY2VDb3VudFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJjdXJyZW50UGFnZVwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24uY3VycmVudFBhZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImN1cnJlbnRQYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnJlbnRQYWdlKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiY3VycmVudFBhZ2VcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwidGFnc1wiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24udGFnc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidGFnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0YWdzKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwidGFnc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJwYWdlWFwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24ucGFnZVhcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VYKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwicGFnZVhcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwicGFnZVlcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnBhZ2VZXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYWdlWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlWSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcInBhZ2VZXCIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFeHByZXNzaW9uO1xufSgpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbkV4cHJlc3Npb24uT1BFUkFUT1JTID0ge1xuICBcIj1cIjogJ2VxJyxcbiAgXCIhPVwiOiAnbmUnLFxuICBcIjxcIjogJ2x0JyxcbiAgXCI+XCI6ICdndCcsXG4gIFwiPD1cIjogJ2x0ZScsXG4gIFwiPj1cIjogJ2d0ZScsXG4gIFwiJiZcIjogJ2FuZCcsXG4gIFwifHxcIjogJ29yJyxcbiAgXCIqXCI6IFwibXVsXCIsXG4gIFwiL1wiOiBcImRpdlwiLFxuICBcIitcIjogXCJhZGRcIixcbiAgXCItXCI6IFwic3ViXCIsXG4gIFwiXlwiOiBcInBvd1wiXG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5FeHByZXNzaW9uLlBSRURFRklORURfVkFSUyA9IHtcbiAgXCJhc3BlY3RfcmF0aW9cIjogXCJhclwiLFxuICBcImFzcGVjdFJhdGlvXCI6IFwiYXJcIixcbiAgXCJjdXJyZW50X3BhZ2VcIjogXCJjcFwiLFxuICBcImN1cnJlbnRQYWdlXCI6IFwiY3BcIixcbiAgXCJkdXJhdGlvblwiOiBcImR1XCIsXG4gIFwiZmFjZV9jb3VudFwiOiBcImZjXCIsXG4gIFwiZmFjZUNvdW50XCI6IFwiZmNcIixcbiAgXCJoZWlnaHRcIjogXCJoXCIsXG4gIFwiaW5pdGlhbF9hc3BlY3RfcmF0aW9cIjogXCJpYXJcIixcbiAgXCJpbml0aWFsX2R1cmF0aW9uXCI6IFwiaWR1XCIsXG4gIFwiaW5pdGlhbF9oZWlnaHRcIjogXCJpaFwiLFxuICBcImluaXRpYWxfd2lkdGhcIjogXCJpd1wiLFxuICBcImluaXRpYWxBc3BlY3RSYXRpb1wiOiBcImlhclwiLFxuICBcImluaXRpYWxEdXJhdGlvblwiOiBcImlkdVwiLFxuICBcImluaXRpYWxIZWlnaHRcIjogXCJpaFwiLFxuICBcImluaXRpYWxXaWR0aFwiOiBcIml3XCIsXG4gIFwicGFnZV9jb3VudFwiOiBcInBjXCIsXG4gIFwicGFnZV94XCI6IFwicHhcIixcbiAgXCJwYWdlX3lcIjogXCJweVwiLFxuICBcInBhZ2VDb3VudFwiOiBcInBjXCIsXG4gIFwicGFnZVhcIjogXCJweFwiLFxuICBcInBhZ2VZXCI6IFwicHlcIixcbiAgXCJ0YWdzXCI6IFwidGFnc1wiLFxuICBcIndpZHRoXCI6IFwid1wiXG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5FeHByZXNzaW9uLkJPVU5EUlkgPSBcIlsgX10rXCI7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBleHByZXNzaW9uID0gKEV4cHJlc3Npb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29uZGl0aW9uLmpzXG5mdW5jdGlvbiBjb25kaXRpb25fdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBjb25kaXRpb25fdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgY29uZGl0aW9uX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGNvbmRpdGlvbl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGNvbmRpdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gY29uZGl0aW9uX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgY29uZGl0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBjb25kaXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoY29uZGl0aW9uX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSB0cmFuc2Zvcm1hdGlvbiBjb25kaXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZGl0aW9uU3RyIC0gYSBjb25kaXRpb24gaW4gc3RyaW5nIGZvcm1hdFxuICogQGNsYXNzIENvbmRpdGlvblxuICogQGV4YW1wbGVcbiAqIC8vIG5vcm1hbGx5IHRoaXMgY2xhc3MgaXMgbm90IGluc3RhbnRpYXRlZCBkaXJlY3RseVxuICogdmFyIHRyID0gY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbi5uZXcoKVxuICogICAgLmlmKCkud2lkdGgoIFwiPlwiLCAxMDAwKS5hbmQoKS5hc3BlY3RSYXRpbyhcIjxcIiwgXCIzOjRcIikudGhlbigpXG4gKiAgICAgIC53aWR0aCgxMDAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKiAgICAuZWxzZSgpXG4gKiAgICAgIC53aWR0aCg1MDApXG4gKiAgICAgIC5jcm9wKFwic2NhbGVcIilcbiAqXG4gKiB2YXIgdHIgPSBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uLm5ldygpXG4gKiAgICAuaWYoXCJ3ID4gMTAwMCBhbmQgYXNwZWN0UmF0aW8gPCAzOjRcIilcbiAqICAgICAgLndpZHRoKDEwMDApXG4gKiAgICAgIC5jcm9wKFwic2NhbGVcIilcbiAqICAgIC5lbHNlKClcbiAqICAgICAgLndpZHRoKDUwMClcbiAqICAgICAgLmNyb3AoXCJzY2FsZVwiKVxuICpcbiAqL1xuXG52YXIgQ29uZGl0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXhwcmVzc2lvbikge1xuICBfaW5oZXJpdHMoQ29uZGl0aW9uLCBfRXhwcmVzc2lvbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDb25kaXRpb24pO1xuXG4gIGZ1bmN0aW9uIENvbmRpdGlvbihjb25kaXRpb25TdHIpIHtcbiAgICBjb25kaXRpb25fY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZGl0aW9uKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb25kaXRpb25TdHIpO1xuICB9XG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2hlaWdodFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICovXG5cblxuICBjb25kaXRpb25fY3JlYXRlQ2xhc3MoQ29uZGl0aW9uLCBbe1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiaFwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI3dpZHRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJ3XCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jYXNwZWN0UmF0aW9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbyhvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImFyXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jcGFnZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYWdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZUNvdW50KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwicGNcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNmYWNlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZhY2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWNlQ291bnQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJmY1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2R1cmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24ob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJkdVwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2luaXRpYWxEdXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxEdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsRHVyYXRpb24ob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJpZHVcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29uZGl0aW9uO1xufShleHByZXNzaW9uKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29uZGl0aW9uID0gKENvbmRpdGlvbik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb25maWd1cmF0aW9uLmpzXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IGNvbmZpZ3VyYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gY29uZmlndXJhdGlvbl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gY29uZmlndXJhdGlvbl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBjb25maWd1cmF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBjb25maWd1cmF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogQ2xhc3MgZm9yIGRlZmluaW5nIGFjY291bnQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogRGVwZW5kcyBvbiAndXRpbHMnXG4gKi9cblxuLyoqXG4gKiBDbGFzcyBmb3IgZGVmaW5pbmcgYWNjb3VudCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKiBAY29uc3RydWN0b3IgQ29uZmlndXJhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgYWNjb3VudCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdG8gc2V0LlxuICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gKiAgdGFyZ2V0PVwiX25ld1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gKi9cblxudmFyIGNvbmZpZ3VyYXRpb25fQ29uZmlndXJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24ob3B0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25fY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlndXJhdGlvbik7XG5cbiAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBvcHRpb25zID09IG51bGwgPyB7fSA6IGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkob3B0aW9ucyk7XG4gICAgZGVmYXVsdHModGhpcy5jb25maWd1cmF0aW9uLCBERUZBVUxUX0NPTkZJR1VSQVRJT05fUEFSQU1TKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbmZpZ3VyYXRpb24uIFRoaXMgbWV0aG9kIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgaW52b2tlcyBib3RoXG4gICAqICB7QGxpbmsgQ29uZmlndXJhdGlvbiNmcm9tRW52aXJvbm1lbnR8ZnJvbUVudmlyb25tZW50KCl9IChOb2RlLmpzIGVudmlyb25tZW50IG9ubHkpXG4gICAqICBhbmQge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbURvY3VtZW50fGZyb21Eb2N1bWVudCgpfS5cbiAgICogIEl0IGZpcnN0IHRyaWVzIHRvIHJldHJpZXZlIHRoZSBjb25maWd1cmF0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgKiAgSWYgbm90IGF2YWlsYWJsZSwgaXQgdHJpZXMgZnJvbSB0aGUgZG9jdW1lbnQgbWV0YSB0YWdzLlxuICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNpbml0XG4gICAqIEByZXR1cm4ge0NvbmZpZ3VyYXRpb259IHJldHVybnMgYHRoaXNgIGZvciBjaGFpbmluZ1xuICAgKiBAc2VlIGZyb21Eb2N1bWVudFxuICAgKiBAc2VlIGZyb21FbnZpcm9ubWVudFxuICAgKi9cblxuXG4gIGNvbmZpZ3VyYXRpb25fY3JlYXRlQ2xhc3MoQ29uZmlndXJhdGlvbiwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5mcm9tRW52aXJvbm1lbnQoKTtcbiAgICAgIHRoaXMuZnJvbURvY3VtZW50KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgbmV3IGNvbmZpZ3VyYXRpb24gaXRlbVxuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI3NldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGl0ZW0gdG8gc2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBiZSBzZXRcbiAgICAgKiBAcmV0dXJuIHtDb25maWd1cmF0aW9ufVxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bbmFtZV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgY29uZmlndXJhdGlvbiBpdGVtXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jZ2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaXRlbSB0byBzZXRcbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgY29uZmlndXJhdGlvbiBpdGVtXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb25bbmFtZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKGNvbmZpZykge1xuICAgICAgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh0aGlzLmNvbmZpZ3VyYXRpb24sIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkoY29uZmlnKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBDbG91ZGluYXJ5IGZyb20gSFRNTCBtZXRhIHRhZ3MuXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jZnJvbURvY3VtZW50XG4gICAgICogQHJldHVybiB7Q29uZmlndXJhdGlvbn1cbiAgICAgKiBAZXhhbXBsZSA8bWV0YSBuYW1lPVwiY2xvdWRpbmFyeV9jbG91ZF9uYW1lXCIgY29udGVudD1cIm15Y2xvdWRcIj5cbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbURvY3VtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Eb2N1bWVudCgpIHtcbiAgICAgIHZhciBlbCwgaSwgbGVuLCBtZXRhX2VsZW1lbnRzO1xuICAgICAgbWV0YV9lbGVtZW50cyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudCAhPT0gbnVsbCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ21ldGFbbmFtZV49XCJjbG91ZGluYXJ5X1wiXScpIDogdm9pZCAwO1xuXG4gICAgICBpZiAobWV0YV9lbGVtZW50cykge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBtZXRhX2VsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZWwgPSBtZXRhX2VsZW1lbnRzW2ldO1xuICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbltlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKS5yZXBsYWNlKCdjbG91ZGluYXJ5XycsICcnKV0gPSBlbC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBDbG91ZGluYXJ5IGZyb20gdGhlIGBDTE9VRElOQVJZX1VSTGAgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgb25seSBydW4gdW5kZXIgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNmcm9tRW52aXJvbm1lbnRcbiAgICAgKiBAcmVxdWlyZXMgTm9kZS5qc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUVudmlyb25tZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FbnZpcm9ubWVudCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBjbG91ZGluYXJ5X3VybCwgcXVlcnksIHVyaSwgdXJpUmVnZXg7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzICE9PSBudWxsICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LkNMT1VESU5BUllfVVJMKSB7XG4gICAgICAgIGNsb3VkaW5hcnlfdXJsID0gcHJvY2Vzcy5lbnYuQ0xPVURJTkFSWV9VUkw7XG4gICAgICAgIHVyaVJlZ2V4ID0gL2Nsb3VkaW5hcnk6XFwvXFwvKD86KFxcdyspKD86XFw6KFtcXHctXSspKT9AKT8oW1xcd1xcLi1dKykoPzpcXC8oW14/XSopKT8oPzpcXD8oLispKT8vO1xuICAgICAgICB1cmkgPSB1cmlSZWdleC5leGVjKGNsb3VkaW5hcnlfdXJsKTtcblxuICAgICAgICBpZiAodXJpKSB7XG4gICAgICAgICAgaWYgKHVyaVszXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ2Nsb3VkX25hbWUnXSA9IHVyaVszXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXJpWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnYXBpX2tleSddID0gdXJpWzFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1cmlbMl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uWydhcGlfc2VjcmV0J10gPSB1cmlbMl07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVyaVs0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ3ByaXZhdGVfY2RuJ10gPSB1cmlbNF0gIT0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXJpWzRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnc2VjdXJlX2Rpc3RyaWJ1dGlvbiddID0gdXJpWzRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHF1ZXJ5ID0gdXJpWzVdO1xuXG4gICAgICAgICAgaWYgKHF1ZXJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIF92YWx1ZSRzcGxpdCA9IHZhbHVlLnNwbGl0KCc9JyksXG4gICAgICAgICAgICAgICAgICBfdmFsdWUkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3ZhbHVlJHNwbGl0LCAyKSxcbiAgICAgICAgICAgICAgICAgIGsgPSBfdmFsdWUkc3BsaXQyWzBdLFxuICAgICAgICAgICAgICAgICAgdiA9IF92YWx1ZSRzcGxpdDJbMV07XG5cbiAgICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHYgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3RoaXMuY29uZmlndXJhdGlvbltrXSA9IHY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBvciBtb2RpZnkgdGhlIENsb3VkaW5hcnkgY2xpZW50IGNvbmZpZ3VyYXRpb25cbiAgICAgKlxuICAgICAqIFdhcm5pbmc6IGBjb25maWcoKWAgcmV0dXJucyB0aGUgYWN0dWFsIGludGVybmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBtb2RpZnlpbmcgaXQgd2lsbCBjaGFuZ2UgdGhlIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBtZXRob2QuIEZvciBuZXcgY29kZSwgdXNlIGdldCgpLCBtZXJnZSgpIGV0Yy5cbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNjb25maWdcbiAgICAgKiBAcGFyYW0ge2hhc2h8c3RyaW5nfGJvb2xlYW59IG5ld19jb25maWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3X3ZhbHVlXG4gICAgICogQHJldHVybnMgeyp9IGNvbmZpZ3VyYXRpb24sIG9yIHZhbHVlXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRW52aXJvbm1lbnR9IGZvciBpbml0aWFsaXphdGlvbiB1c2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRG9jdW1lbnR9IGZvciBpbml0aWFsaXphdGlvbiB1c2luZyBIVE1MIG1ldGEgdGFnc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmZpZyhuZXdfY29uZmlnLCBuZXdfdmFsdWUpIHtcbiAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgY2FzZSBuZXdfdmFsdWUgPT09IHZvaWQgMDpcbiAgICAgICAgICB0aGlzLnNldChuZXdfY29uZmlnLCBuZXdfdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb247XG5cbiAgICAgICAgY2FzZSAhaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkobmV3X2NvbmZpZyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5ld19jb25maWcpO1xuXG4gICAgICAgIGNhc2UgIWlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShuZXdfY29uZmlnKTpcbiAgICAgICAgICB0aGlzLm1lcmdlKG5ld19jb25maWcpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb247XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IC0gcmV0dXJuIHRoZSBpbnRlcm5hbCBvYmplY3RcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jdG9PcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdH0gYSBrZXk6dmFsdWUgY29sbGVjdGlvbiBvZiB0aGUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b09wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9PcHRpb25zKCkge1xuICAgICAgcmV0dXJuIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkodGhpcy5jb25maWd1cmF0aW9uKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29uZmlndXJhdGlvbjtcbn0oKTtcblxudmFyIERFRkFVTFRfQ09ORklHVVJBVElPTl9QQVJBTVMgPSB7XG4gIHJlc3BvbnNpdmVfY2xhc3M6ICdjbGQtcmVzcG9uc2l2ZScsXG4gIHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzOiB0cnVlLFxuICByb3VuZF9kcHI6IHRydWUsXG4gIHNlY3VyZTogKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsID8gd2luZG93LmxvY2F0aW9uID8gd2luZG93LmxvY2F0aW9uLnByb3RvY29sIDogdm9pZCAwIDogdm9pZCAwKSA9PT0gJ2h0dHBzOidcbn07XG5jb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24uQ09ORklHX1BBUkFNUyA9IFtcImFwaV9rZXlcIiwgXCJhcGlfc2VjcmV0XCIsIFwiY2FsbGJhY2tcIiwgXCJjZG5fc3ViZG9tYWluXCIsIFwiY2xvdWRfbmFtZVwiLCBcImNuYW1lXCIsIFwicHJpdmF0ZV9jZG5cIiwgXCJwcm90b2NvbFwiLCBcInJlc291cmNlX3R5cGVcIiwgXCJyZXNwb25zaXZlXCIsIFwicmVzcG9uc2l2ZV9jbGFzc1wiLCBcInJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzXCIsIFwicmVzcG9uc2l2ZV93aWR0aFwiLCBcInJvdW5kX2RwclwiLCBcInNlY3VyZVwiLCBcInNlY3VyZV9jZG5fc3ViZG9tYWluXCIsIFwic2VjdXJlX2Rpc3RyaWJ1dGlvblwiLCBcInNob3J0ZW5cIiwgXCJ0eXBlXCIsIFwidXBsb2FkX3ByZXNldFwiLCBcInVybF9zdWZmaXhcIiwgXCJ1c2Vfcm9vdF9wYXRoXCIsIFwidmVyc2lvblwiLCBcImV4dGVybmFsTGlicmFyaWVzXCIsIFwibWF4X3RpbWVvdXRfbXNcIl07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfY29uZmlndXJhdGlvbiA9IChjb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbGF5ZXIvbGF5ZXIuanNcbmZ1bmN0aW9uIGxheWVyX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gbGF5ZXJfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGxheWVyX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgbGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG52YXIgbGF5ZXJfTGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogTGF5ZXJcbiAgICogQGNvbnN0cnVjdG9yIExheWVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gbGF5ZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gTGF5ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBsYXllcl9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXllcik7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcblxuICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICAgIFtcInJlc291cmNlVHlwZVwiLCBcInR5cGVcIiwgXCJwdWJsaWNJZFwiLCBcImZvcm1hdFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnNba2V5XSA9IChyZWYgPSBvcHRpb25zW2tleV0pICE9IG51bGwgPyByZWYgOiBvcHRpb25zW3NuYWtlQ2FzZShrZXkpXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGxheWVyX2NyZWF0ZUNsYXNzKExheWVyLCBbe1xuICAgIGtleTogXCJyZXNvdXJjZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb3VyY2VUeXBlKHZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0eXBlKHZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudHlwZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1YmxpY0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1YmxpY0lkKHZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMucHVibGljSWQgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHB1YmxpYyBJRCwgZm9ybWF0dGVkIGZvciBsYXllciBwYXJhbWV0ZXJcbiAgICAgKiBAZnVuY3Rpb24gTGF5ZXIjZ2V0UHVibGljSWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHB1YmxpYyBJRFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHVibGljSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHVibGljSWQoKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLm9wdGlvbnMucHVibGljSWQpICE9IG51bGwgPyByZWYucmVwbGFjZSgvXFwvL2csIFwiOlwiKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwdWJsaWMgSUQsIHdpdGggZm9ybWF0IGlmIHByZXNlbnRcbiAgICAgKiBAZnVuY3Rpb24gTGF5ZXIjZ2V0RnVsbFB1YmxpY0lkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBwdWJsaWMgSURcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxQdWJsaWNJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsUHVibGljSWQoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFB1YmxpY0lkKCkgKyBcIi5cIiArIHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQdWJsaWNJZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9ybWF0ID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAZnVuY3Rpb24gTGF5ZXIjdG9TdHJpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudHM7XG4gICAgICBjb21wb25lbnRzID0gW107XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHVibGljSWQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcIk11c3Qgc3VwcGx5IHB1YmxpY0lkXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICghKHRoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMudHlwZSA9PT0gXCJ1cGxvYWRcIikpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy50eXBlKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMuZ2V0RnVsbFB1YmxpY0lkKCkpO1xuICAgICAgcmV0dXJuIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShjb21wb25lbnRzKS5qb2luKFwiOlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGF5ZXI7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxheWVyX2xheWVyID0gKGxheWVyX0xheWVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xheWVyL3RleHRsYXllci5qc1xuZnVuY3Rpb24gdGV4dGxheWVyX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gdGV4dGxheWVyX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIHRleHRsYXllcl90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHRleHRsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgdGV4dGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSB0ZXh0bGF5ZXJfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKSB7IHRleHRsYXllcl9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gdGV4dGxheWVyX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gdGV4dGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHRleHRsYXllcl9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gdGV4dGxheWVyX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiB0ZXh0bGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHRleHRsYXllcl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gdGV4dGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9nZXRQcm90b3R5cGVPZihvKSB7IHRleHRsYXllcl9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gdGV4dGxheWVyX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cbnZhciB0ZXh0bGF5ZXJfVGV4dExheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGF5ZXIpIHtcbiAgdGV4dGxheWVyX2luaGVyaXRzKFRleHRMYXllciwgX0xheWVyKTtcblxuICB2YXIgX3N1cGVyID0gdGV4dGxheWVyX2NyZWF0ZVN1cGVyKFRleHRMYXllcik7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvciBUZXh0TGF5ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBsYXllciBwYXJhbWV0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0TGF5ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIHRleHRsYXllcl9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0TGF5ZXIpO1xuXG4gICAgdmFyIGtleXM7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBrZXlzID0gW1wicmVzb3VyY2VUeXBlXCIsIFwicmVzb3VyY2VUeXBlXCIsIFwiZm9udEZhbWlseVwiLCBcImZvbnRTaXplXCIsIFwiZm9udFdlaWdodFwiLCBcImZvbnRTdHlsZVwiLCBcInRleHREZWNvcmF0aW9uXCIsIFwidGV4dEFsaWduXCIsIFwic3Ryb2tlXCIsIFwibGV0dGVyU3BhY2luZ1wiLCBcImxpbmVTcGFjaW5nXCIsIFwiZm9udEhpbnRpbmdcIiwgXCJmb250QW50aWFsaWFzaW5nXCIsIFwidGV4dFwiLCBcInRleHRTdHlsZVwiXTtcblxuICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zW2tleV0gPSAocmVmID0gb3B0aW9uc1trZXldKSAhPSBudWxsID8gcmVmIDogb3B0aW9uc1tzbmFrZUNhc2Uoa2V5KV07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfdGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSA9IFwidGV4dFwiO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHRleHRsYXllcl9jcmVhdGVDbGFzcyhUZXh0TGF5ZXIsIFt7XG4gICAga2V5OiBcInJlc291cmNlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvdXJjZVR5cGUoX3Jlc291cmNlVHlwZSkge1xuICAgICAgdGhyb3cgXCJDYW5ub3QgbW9kaWZ5IHJlc291cmNlVHlwZSBmb3IgdGV4dCBsYXllcnNcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0eXBlKF90eXBlKSB7XG4gICAgICB0aHJvdyBcIkNhbm5vdCBtb2RpZnkgdHlwZSBmb3IgdGV4dCBsYXllcnNcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChfZm9ybWF0KSB7XG4gICAgICB0aHJvdyBcIkNhbm5vdCBtb2RpZnkgZm9ybWF0IGZvciB0ZXh0IGxheWVyc1wiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250RmFtaWx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRGYW1pbHkoX2ZvbnRGYW1pbHkpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250RmFtaWx5ID0gX2ZvbnRGYW1pbHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udFNpemUoX2ZvbnRTaXplKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udFNpemUgPSBfZm9udFNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udFdlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250V2VpZ2h0KF9mb250V2VpZ2h0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udFdlaWdodCA9IF9mb250V2VpZ2h0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250U3R5bGUoX2ZvbnRTdHlsZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRTdHlsZSA9IF9mb250U3R5bGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dERlY29yYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dERlY29yYXRpb24oX3RleHREZWNvcmF0aW9uKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGV4dERlY29yYXRpb24gPSBfdGV4dERlY29yYXRpb247XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dEFsaWduXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRBbGlnbihfdGV4dEFsaWduKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGV4dEFsaWduID0gX3RleHRBbGlnbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdHJva2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Ryb2tlKF9zdHJva2UpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zdHJva2UgPSBfc3Ryb2tlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxldHRlclNwYWNpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGV0dGVyU3BhY2luZyhfbGV0dGVyU3BhY2luZykge1xuICAgICAgdGhpcy5vcHRpb25zLmxldHRlclNwYWNpbmcgPSBfbGV0dGVyU3BhY2luZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaW5lU3BhY2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lU3BhY2luZyhfbGluZVNwYWNpbmcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5saW5lU3BhY2luZyA9IF9saW5lU3BhY2luZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250SGludGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250SGludGluZyhfZm9udEhpbnRpbmcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250SGludGluZyA9IF9mb250SGludGluZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250QW50aWFsaWFzaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRBbnRpYWxpYXNpbmcoX2ZvbnRBbnRpYWxpYXNpbmcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250QW50aWFsaWFzaW5nID0gX2ZvbnRBbnRpYWxpYXNpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0KF90ZXh0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGV4dCA9IF90ZXh0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0U3R5bGUoX3RleHRTdHlsZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHRTdHlsZSA9IF90ZXh0U3R5bGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAZnVuY3Rpb24gVGV4dExheWVyI3RvU3RyaW5nXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50cywgaGFzUHVibGljSWQsIGhhc1N0eWxlLCBwdWJsaWNJZCwgcmUsIHJlcywgc3RhcnQsIHN0eWxlLCB0ZXh0LCB0ZXh0U291cmNlO1xuICAgICAgc3R5bGUgPSB0aGlzLnRleHRTdHlsZUlkZW50aWZpZXIoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wdWJsaWNJZCAhPSBudWxsKSB7XG4gICAgICAgIHB1YmxpY0lkID0gdGhpcy5nZXRGdWxsUHVibGljSWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgaGFzUHVibGljSWQgPSAhaXNFbXB0eShwdWJsaWNJZCk7XG4gICAgICAgIGhhc1N0eWxlID0gIWlzRW1wdHkoc3R5bGUpO1xuXG4gICAgICAgIGlmIChoYXNQdWJsaWNJZCAmJiBoYXNTdHlsZSB8fCAhaGFzUHVibGljSWQgJiYgIWhhc1N0eWxlKSB7XG4gICAgICAgICAgdGhyb3cgXCJNdXN0IHN1cHBseSBlaXRoZXIgc3R5bGUgcGFyYW1ldGVycyBvciBhIHB1YmxpY19pZCB3aGVuIHByb3ZpZGluZyB0ZXh0IHBhcmFtZXRlciBpbiBhIHRleHQgb3ZlcmxheS91bmRlcmxheSwgYnV0IG5vdCBib3RoIVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmUgPSAvXFwkXFwoW2EtekEtWl1cXHcqXFwpL2c7XG4gICAgICAgIHN0YXJ0ID0gMDsgLy8gICAgICAgIHRleHRTb3VyY2UgPSB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChcIlssL11cIiwgJ2cnKSwgKGMpLT4gXCIlI3tjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9XCIpXG5cbiAgICAgICAgdGV4dFNvdXJjZSA9IHNtYXJ0RXNjYXBlKHRoaXMub3B0aW9ucy50ZXh0LCAvWyxcXC9dL2cpO1xuICAgICAgICB0ZXh0ID0gXCJcIjtcblxuICAgICAgICB3aGlsZSAocmVzID0gcmUuZXhlYyh0ZXh0U291cmNlKSkge1xuICAgICAgICAgIHRleHQgKz0gc21hcnRFc2NhcGUodGV4dFNvdXJjZS5zbGljZShzdGFydCwgcmVzLmluZGV4KSk7XG4gICAgICAgICAgdGV4dCArPSByZXNbMF07XG4gICAgICAgICAgc3RhcnQgPSByZXMuaW5kZXggKyByZXNbMF0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCArPSBzbWFydEVzY2FwZSh0ZXh0U291cmNlLnNsaWNlKHN0YXJ0KSk7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudHMgPSBbdGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSwgc3R5bGUsIHB1YmxpY0lkLCB0ZXh0XTtcbiAgICAgIHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoY29tcG9uZW50cykuam9pbihcIjpcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRTdHlsZUlkZW50aWZpZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dFN0eWxlSWRlbnRpZmllcigpIHtcbiAgICAgIC8vIE5vdGU6IGlmIGEgdGV4dC1zdHlsZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhcyBhIHdob2xlLCBpdCBvdmVycmlkZXMgZXZlcnl0aGluZyBlbHNlLCBubyBtaXggYW5kIG1hdGNoLlxuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMub3B0aW9ucy50ZXh0U3R5bGUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGV4dFN0eWxlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tcG9uZW50cztcbiAgICAgIGNvbXBvbmVudHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb250V2VpZ2h0ICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMuZm9udFdlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9udFN0eWxlICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMuZm9udFN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50ZXh0RGVjb3JhdGlvbiAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy50ZXh0RGVjb3JhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMudGV4dEFsaWduKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJva2UgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMuc3Ryb2tlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoaXNFbXB0eSh0aGlzLm9wdGlvbnMubGV0dGVyU3BhY2luZykgJiYgIWlzTnVtYmVyTGlrZSh0aGlzLm9wdGlvbnMubGV0dGVyU3BhY2luZykpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChcImxldHRlcl9zcGFjaW5nX1wiICsgdGhpcy5vcHRpb25zLmxldHRlclNwYWNpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShpc0VtcHR5KHRoaXMub3B0aW9ucy5saW5lU3BhY2luZykgJiYgIWlzTnVtYmVyTGlrZSh0aGlzLm9wdGlvbnMubGluZVNwYWNpbmcpKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goXCJsaW5lX3NwYWNpbmdfXCIgKyB0aGlzLm9wdGlvbnMubGluZVNwYWNpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRW1wdHkodGhpcy5vcHRpb25zLmZvbnRBbnRpYWxpYXNpbmcpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChcImFudGlhbGlhc19cIiArIHRoaXMub3B0aW9ucy5mb250QW50aWFsaWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMub3B0aW9ucy5mb250SGludGluZykpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKFwiaGludGluZ19cIiArIHRoaXMub3B0aW9ucy5mb250SGludGluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNFbXB0eShjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoY29tcG9uZW50cykpKSB7XG4gICAgICAgIGlmIChpc0VtcHR5KHRoaXMub3B0aW9ucy5mb250RmFtaWx5KSkge1xuICAgICAgICAgIHRocm93IFwiTXVzdCBzdXBwbHkgZm9udEZhbWlseS4gXCIuY29uY2F0KGNvbXBvbmVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5vcHRpb25zLmZvbnRTaXplKSAmJiAhaXNOdW1iZXJMaWtlKHRoaXMub3B0aW9ucy5mb250U2l6ZSkpIHtcbiAgICAgICAgICB0aHJvdyBcIk11c3Qgc3VwcGx5IGZvbnRTaXplLlwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudHMudW5zaGlmdCh0aGlzLm9wdGlvbnMuZm9udEZhbWlseSwgdGhpcy5vcHRpb25zLmZvbnRTaXplKTtcbiAgICAgIGNvbXBvbmVudHMgPSBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoY29tcG9uZW50cykuam9pbihcIl9cIik7XG4gICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dExheWVyO1xufShsYXllcl9sYXllcik7XG5cbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRleHRsYXllciA9ICh0ZXh0bGF5ZXJfVGV4dExheWVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xheWVyL3N1YnRpdGxlc2xheWVyLmpzXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHN1YnRpdGxlc2xheWVyX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIHN1YnRpdGxlc2xheWVyX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHN1YnRpdGxlc2xheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBzdWJ0aXRsZXNsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKSB7IHN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gc3VidGl0bGVzbGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gc3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBzdWJ0aXRsZXNsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChzdWJ0aXRsZXNsYXllcl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gc3VidGl0bGVzbGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mKG8pIHsgc3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG52YXIgU3VidGl0bGVzTGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UZXh0TGF5ZXIpIHtcbiAgc3VidGl0bGVzbGF5ZXJfaW5oZXJpdHMoU3VidGl0bGVzTGF5ZXIsIF9UZXh0TGF5ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBzdWJ0aXRsZXNsYXllcl9jcmVhdGVTdXBlcihTdWJ0aXRsZXNMYXllcik7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHN1YnRpdGxlcyBsYXllclxuICAgKiBAY29uc3RydWN0b3IgU3VidGl0bGVzTGF5ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBsYXllciBwYXJhbWV0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiBTdWJ0aXRsZXNMYXllcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgc3VidGl0bGVzbGF5ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3VidGl0bGVzTGF5ZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBfdGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSA9IFwic3VidGl0bGVzXCI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIHN1YnRpdGxlc2xheWVyX2NyZWF0ZUNsYXNzKFN1YnRpdGxlc0xheWVyKTtcbn0odGV4dGxheWVyKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3VidGl0bGVzbGF5ZXIgPSAoU3VidGl0bGVzTGF5ZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbGF5ZXIvZmV0Y2hsYXllci5qc1xuZnVuY3Rpb24gZmV0Y2hsYXllcl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGZldGNobGF5ZXJfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgZmV0Y2hsYXllcl90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mKG8sIHApIHsgZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmZXRjaGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIGZldGNobGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChmZXRjaGxheWVyX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBmZXRjaGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZihvKSB7IGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxudmFyIGZldGNobGF5ZXJfRmV0Y2hMYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xheWVyKSB7XG4gIGZldGNobGF5ZXJfaW5oZXJpdHMoRmV0Y2hMYXllciwgX0xheWVyKTtcblxuICB2YXIgX3N1cGVyID0gZmV0Y2hsYXllcl9jcmVhdGVTdXBlcihGZXRjaExheWVyKTtcblxuICAvKipcbiAgICogQGNsYXNzIEZldGNoTGF5ZXJcbiAgICogQGNsYXNzZGVzYyBDcmVhdGVzIGFuIGltYWdlIGxheWVyIHVzaW5nIGEgcmVtb3RlIFVSTC5cbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvcHRpb25zIC0gbGF5ZXIgcGFyYW1ldGVycyBvciBhIHVybFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmwgdGhlIHVybCBvZiB0aGUgaW1hZ2UgdG8gZmV0Y2hcbiAgICovXG4gIGZ1bmN0aW9uIEZldGNoTGF5ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZldGNobGF5ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmV0Y2hMYXllcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKG9wdGlvbnMpKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLnVybCA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnVybCA6IHZvaWQgMCkge1xuICAgICAgX3RoaXMub3B0aW9ucy51cmwgPSBvcHRpb25zLnVybDtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBmZXRjaGxheWVyX2NyZWF0ZUNsYXNzKEZldGNoTGF5ZXIsIFt7XG4gICAga2V5OiBcInVybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cmwoX3VybCkge1xuICAgICAgdGhpcy5vcHRpb25zLnVybCA9IF91cmw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAZnVuY3Rpb24gRmV0Y2hMYXllciN0b1N0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiZmV0Y2g6XCIuY29uY2F0KGJhc2U2NEVuY29kZVVSTCh0aGlzLm9wdGlvbnMudXJsKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZldGNoTGF5ZXI7XG59KGxheWVyX2xheWVyKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZmV0Y2hsYXllciA9IChmZXRjaGxheWVyX0ZldGNoTGF5ZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcGFyYW1ldGVycy5qc1xuZnVuY3Rpb24gcGFyYW1ldGVyc190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHBhcmFtZXRlcnNfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgcGFyYW1ldGVyc190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgcGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZihvLCBwKSB7IHBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcGFyYW1ldGVyc19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwYXJhbWV0ZXJzX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAocGFyYW1ldGVyc190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gcGFyYW1ldGVyc19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YobykgeyBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgcGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgcGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gcGFyYW1ldGVyc1xuICogRGVwZW5kcyBvbiAndXRpbCcsICd0cmFuc2Zvcm1hdGlvbidcbiAqL1xuXG52YXIgcGFyYW1ldGVyc19QYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2luZ2xlIHBhcmFtZXRlci5cbiAgICogQGNsYXNzIFBhcmFtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiBzbmFrZV9jYXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGUgcGFyYW1ldGVyIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPVV0aWwuaWRlbnRpdHkgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIFBhcmFtKG5hbWUsIHNob3J0TmFtZSkge1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQuYTtcblxuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyYW0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiBzbmFrZV9jYXNlXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBQYXJhbSNuYW1lXG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IFBhcmFtI3Nob3J0TmFtZVxuICAgICAqL1xuXG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gICAgLyoqXG4gICAgICogTWFuaXB1bGF0ZSBvcmlnVmFsdWUgd2hlbiB2YWx1ZSBpcyBjYWxsZWRcbiAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbn0gUGFyYW0jcHJvY2Vzc1xuICAgICAqL1xuXG4gICAgdGhpcy5wcm9jZXNzID0gcHJvY2VzcztcbiAgfVxuICAvKipcbiAgICogU2V0IGEgKHVucHJvY2Vzc2VkKSB2YWx1ZSBmb3IgdGhpcyBwYXJhbWV0ZXJcbiAgICogQGZ1bmN0aW9uIFBhcmFtI3NldFxuICAgKiBAcGFyYW0geyp9IG9yaWdWYWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqIEByZXR1cm4ge1BhcmFtfSBzZWxmIGZvciBjaGFpbmluZ1xuICAgKi9cblxuXG4gIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoUGFyYW0sIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3JpZ1ZhbHVlKSB7XG4gICAgICB0aGlzLm9yaWdWYWx1ZSA9IG9yaWdWYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAZnVuY3Rpb24gUGFyYW0jc2VyaWFsaXplXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgdmFsLCB2YWxpZDtcbiAgICAgIHZhbCA9IHRoaXMudmFsdWUoKTtcbiAgICAgIHZhbGlkID0gaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbCkgfHwgaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHZhbCkgfHwgaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodmFsKSA/ICFpc0VtcHR5KHZhbCkgOiB2YWwgIT0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuc2hvcnROYW1lICE9IG51bGwgJiYgdmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcHJvY2Vzc2VkIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAZnVuY3Rpb24gUGFyYW0jdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0aGlzLm9yaWdWYWx1ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibm9ybV9jb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtX2NvbG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnJlcGxhY2UoL14jLywgJ3JnYjonKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRfYXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRfYXJyYXkoYXJnKSB7XG4gICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoYXJnKSkge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFthcmddO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIENvdmVydCB2YWx1ZSB0byB2aWRlbyBjb2RlYyBzdHJpbmcuXG4gICAgKlxuICAgICogSWYgdGhlIHBhcmFtZXRlciBpcyBhbiBvYmplY3QsXG4gICAgKiBAcGFyYW0geyhzdHJpbmd8T2JqZWN0KX0gcGFyYW0gLSB0aGUgdmlkZW8gY29kZWMgYXMgZWl0aGVyIGEgU3RyaW5nIG9yIGEgSGFzaFxuICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgdmlkZW8gY29kZWMgc3RyaW5nIGluIHRoZSBmb3JtYXQgY29kZWM6cHJvZmlsZTpsZXZlbDpiX2ZyYW1lc1xuICAgICogQGV4YW1wbGVcbiAgICAqIHZjX1sgOnByb2ZpbGUgOiBbbGV2ZWwgOiBbYl9mcmFtZXNdXV1cbiAgICAqIG9yXG4gICAgICB7IGNvZGVjOiAnaDI2NCcsIHByb2ZpbGU6ICdiYXNpYycsIGxldmVsOiAnMy4xJywgYl9mcmFtZXM6IGZhbHNlIH1cbiAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NfdmlkZW9fcGFyYW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NfdmlkZW9fcGFyYW1zKHBhcmFtKSB7XG4gICAgICB2YXIgdmlkZW87XG5cbiAgICAgIHN3aXRjaCAocGFyYW0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgdmlkZW8gPSBcIlwiO1xuXG4gICAgICAgICAgaWYgKCdjb2RlYycgaW4gcGFyYW0pIHtcbiAgICAgICAgICAgIHZpZGVvID0gcGFyYW0uY29kZWM7XG5cbiAgICAgICAgICAgIGlmICgncHJvZmlsZScgaW4gcGFyYW0pIHtcbiAgICAgICAgICAgICAgdmlkZW8gKz0gXCI6XCIgKyBwYXJhbS5wcm9maWxlO1xuXG4gICAgICAgICAgICAgIGlmICgnbGV2ZWwnIGluIHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmlkZW8gKz0gXCI6XCIgKyBwYXJhbS5sZXZlbDtcblxuICAgICAgICAgICAgICAgIGlmICgnYl9mcmFtZXMnIGluIHBhcmFtICYmIHBhcmFtLmJfZnJhbWVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgdmlkZW8gKz0gXCI6YmZyYW1lc19ub1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2aWRlbztcblxuICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgICByZXR1cm4gcGFyYW07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFyYW07XG59KCk7XG5cbnZhciBwYXJhbWV0ZXJzX0FycmF5UGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbSkge1xuICBwYXJhbWV0ZXJzX2luaGVyaXRzKEFycmF5UGFyYW0sIF9QYXJhbSk7XG5cbiAgdmFyIF9zdXBlciA9IHBhcmFtZXRlcnNfY3JlYXRlU3VwZXIoQXJyYXlQYXJhbSk7XG5cbiAgLyoqXG4gICAqIEEgcGFyYW1ldGVyIHRoYXQgcmVwcmVzZW50cyBhbiBhcnJheS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgSWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQsIHRoZSBwYXJhbWV0ZXIgd2lsbCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXA9Jy4nXSAtIFRoZSBzZXBhcmF0b3IgdG8gdXNlIHdoZW4gam9pbmluZyB0aGUgYXJyYXkgZWxlbWVudHMgdG9nZXRoZXJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2Nlc3M9VXRpbC5pZGVudGl0eSBdIC0gTWFuaXB1bGF0ZSBvcmlnVmFsdWUgd2hlbiB2YWx1ZSBpcyBjYWxsZWRcbiAgICogQGNsYXNzIEFycmF5UGFyYW1cbiAgICogQGV4dGVuZHMgUGFyYW1cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gQXJyYXlQYXJhbShuYW1lLCBzaG9ydE5hbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgc2VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnLic7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcblxuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXJyYXlQYXJhbSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIHNob3J0TmFtZSwgcHJvY2Vzcyk7XG4gICAgX3RoaXMuc2VwID0gc2VwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoQXJyYXlQYXJhbSwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIGlmICh0aGlzLnNob3J0TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBhcnJheVZhbHVlID0gdGhpcy52YWx1ZSgpO1xuXG4gICAgICAgIGlmIChpc0VtcHR5KGFycmF5VmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGFycmF5VmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KGFycmF5VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmbGF0ID0gYXJyYXlWYWx1ZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodC5zZXJpYWxpemUpID8gdC5zZXJpYWxpemUoKSA6IHQ7XG4gICAgICAgICAgfSkuam9pbih0aGlzLnNlcCk7XG4gICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KGZsYXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdWYWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnByb2Nlc3Modik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0aGlzLm9yaWdWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3JpZ1ZhbHVlKSB7XG4gICAgICBpZiAob3JpZ1ZhbHVlID09IG51bGwgfHwgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKG9yaWdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQocGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihBcnJheVBhcmFtLnByb3RvdHlwZSksIFwic2V0XCIsIHRoaXMpLmNhbGwodGhpcywgb3JpZ1ZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoQXJyYXlQYXJhbS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIFtvcmlnVmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXJyYXlQYXJhbTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG5cbnZhciBwYXJhbWV0ZXJzX1RyYW5zZm9ybWF0aW9uUGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbTIpIHtcbiAgcGFyYW1ldGVyc19pbmhlcml0cyhUcmFuc2Zvcm1hdGlvblBhcmFtLCBfUGFyYW0yKTtcblxuICB2YXIgX3N1cGVyMiA9IHBhcmFtZXRlcnNfY3JlYXRlU3VwZXIoVHJhbnNmb3JtYXRpb25QYXJhbSk7XG5cbiAgLyoqXG4gICAqIEEgcGFyYW1ldGVyIHRoYXQgcmVwcmVzZW50cyBhIHRyYW5zZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiBzbmFrZV9jYXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2hvcnROYW1lPSd0J10gLSBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXA9Jy4nXSAtIFRoZSBzZXBhcmF0b3IgdG8gdXNlIHdoZW4gam9pbmluZyB0aGUgYXJyYXkgZWxlbWVudHMgdG9nZXRoZXJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2Nlc3M9VXRpbC5pZGVudGl0eSBdIC0gTWFuaXB1bGF0ZSBvcmlnVmFsdWUgd2hlbiB2YWx1ZSBpcyBjYWxsZWRcbiAgICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uUGFyYW1cbiAgICogQGV4dGVuZHMgUGFyYW1cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb25QYXJhbShuYW1lKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIHZhciBzaG9ydE5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwidFwiO1xuICAgIHZhciBzZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcuJztcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2Zvcm1hdGlvblBhcmFtKTtcblxuICAgIF90aGlzMyA9IF9zdXBlcjIuY2FsbCh0aGlzLCBuYW1lLCBzaG9ydE5hbWUsIHByb2Nlc3MpO1xuICAgIF90aGlzMy5zZXAgPSBzZXA7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgc3RyaW5nIHJlcHJlc2VudGF0aW9ucyBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGVpdGhlciB0aGUgdHJhbnNmb3JtYXRpb24gYXMgYSBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHN0cmluZyByZXByZXNlbnRhdGlvbnMuXG4gICAqL1xuXG5cbiAgcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhUcmFuc2Zvcm1hdGlvblBhcmFtLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlKCk7XG5cbiAgICAgIGlmIChpc0VtcHR5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gLy8gdmFsIGlzIGFuIGFycmF5IG9mIHN0cmluZ3Mgc28gam9pbiB0aGVtXG5cblxuICAgICAgaWYgKGJhc2V1dGlsX2FsbFN0cmluZ3ModmFsKSkge1xuICAgICAgICB2YXIgam9pbmVkID0gdmFsLmpvaW4odGhpcy5zZXApOyAvLyBjcmVhdGVzIHQxLnQyLnQzIGluIGNhc2UgbXVsdGlwbGUgbmFtZWQgdHJhbnNmb3JtYXRpb25zIHdlcmUgY29uZmlndXJlZFxuXG4gICAgICAgIGlmICghaXNFbXB0eShqb2luZWQpKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBvcHRpb25zLnRyYW5zZm9ybWF0aW9uIHdhcyBub3Qgc2V0IHdpdGggYW4gZW1wdHkgc3RyaW5nICh2YWwgIT0gWycnXSk7XG4gICAgICAgICAgcmVzdWx0ID0gXCJcIi5jb25jYXQodGhpcy5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQoam9pbmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29udmVydCB2YWwgdG8gYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgICByZXN1bHQgPSB2YWwubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHQpICYmICFpc0VtcHR5KHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoX3RoaXM0LnNob3J0TmFtZSwgXCJfXCIpLmNvbmNhdCh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHQuc2VyaWFsaXplKSkge1xuICAgICAgICAgICAgcmV0dXJuIHQuc2VyaWFsaXplKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKSh0KSAmJiAhaXNFbXB0eSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBzcmNfdHJhbnNmb3JtYXRpb24odCkuc2VyaWFsaXplKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG9yaWdWYWx1ZTEpIHtcbiAgICAgIHRoaXMub3JpZ1ZhbHVlID0gb3JpZ1ZhbHVlMTtcblxuICAgICAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQocGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihUcmFuc2Zvcm1hdGlvblBhcmFtLnByb3RvdHlwZSksIFwic2V0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcy5vcmlnVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9nZXQocGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihUcmFuc2Zvcm1hdGlvblBhcmFtLnByb3RvdHlwZSksIFwic2V0XCIsIHRoaXMpLmNhbGwodGhpcywgW3RoaXMub3JpZ1ZhbHVlXSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYW5zZm9ybWF0aW9uUGFyYW07XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG52YXIgbnVtYmVyX3BhdHRlcm4gPSBcIihbMC05XSopXFxcXC4oWzAtOV0rKXwoWzAtOV0rKVwiO1xudmFyIG9mZnNldF9hbnlfcGF0dGVybiA9IFwiKFwiICsgbnVtYmVyX3BhdHRlcm4gKyBcIikoWyVwUF0pP1wiO1xuXG52YXIgcGFyYW1ldGVyc19SYW5nZVBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW0zKSB7XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoUmFuZ2VQYXJhbSwgX1BhcmFtMyk7XG5cbiAgdmFyIF9zdXBlcjMgPSBwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyKFJhbmdlUGFyYW0pO1xuXG4gIC8qKlxuICAgKiBBIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgYSByYW5nZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGUgcGFyYW1ldGVyIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPW5vcm1fcmFuZ2VfdmFsdWUgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBjbGFzcyBSYW5nZVBhcmFtXG4gICAqIEBleHRlbmRzIFBhcmFtXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlUGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFJhbmdlUGFyYW0ubm9ybV9yYW5nZV92YWx1ZTtcblxuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFuZ2VQYXJhbSk7XG5cbiAgICByZXR1cm4gX3N1cGVyMy5jYWxsKHRoaXMsIG5hbWUsIHNob3J0TmFtZSwgcHJvY2Vzcyk7XG4gIH1cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKFJhbmdlUGFyYW0sIG51bGwsIFt7XG4gICAga2V5OiBcIm5vcm1fcmFuZ2VfdmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybV9yYW5nZV92YWx1ZSh2YWx1ZSkge1xuICAgICAgdmFyIG9mZnNldCA9IFN0cmluZyh2YWx1ZSkubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyBvZmZzZXRfYW55X3BhdHRlcm4gKyAnJCcpKTtcblxuICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICB2YXIgbW9kaWZpZXIgPSBvZmZzZXRbNV0gIT0gbnVsbCA/ICdwJyA6ICcnO1xuICAgICAgICB2YWx1ZSA9IChvZmZzZXRbMV0gfHwgb2Zmc2V0WzRdKSArIG1vZGlmaWVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcmVzc2lvbi5ub3JtYWxpemUodmFsdWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSYW5nZVBhcmFtO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcblxudmFyIHBhcmFtZXRlcnNfUmF3UGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbTQpIHtcbiAgcGFyYW1ldGVyc19pbmhlcml0cyhSYXdQYXJhbSwgX1BhcmFtNCk7XG5cbiAgdmFyIF9zdXBlcjQgPSBwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyKFJhd1BhcmFtKTtcblxuICBmdW5jdGlvbiBSYXdQYXJhbShuYW1lLCBzaG9ydE5hbWUpIHtcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0LmE7XG5cbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhd1BhcmFtKTtcblxuICAgIHJldHVybiBfc3VwZXI0LmNhbGwodGhpcywgbmFtZSwgc2hvcnROYW1lLCBwcm9jZXNzKTtcbiAgfVxuXG4gIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoUmF3UGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSYXdQYXJhbTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG5cbnZhciBwYXJhbWV0ZXJzX0xheWVyUGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbTUpIHtcbiAgcGFyYW1ldGVyc19pbmhlcml0cyhMYXllclBhcmFtLCBfUGFyYW01KTtcblxuICB2YXIgX3N1cGVyNSA9IHBhcmFtZXRlcnNfY3JlYXRlU3VwZXIoTGF5ZXJQYXJhbSk7XG5cbiAgZnVuY3Rpb24gTGF5ZXJQYXJhbSgpIHtcbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheWVyUGFyYW0pO1xuXG4gICAgcmV0dXJuIF9zdXBlcjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoTGF5ZXJQYXJhbSwgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogLy8gUGFyc2UgbGF5ZXIgb3B0aW9uc1xuICAgIC8vIEByZXR1cm4gW3N0cmluZ10gbGF5ZXIgdHJhbnNmb3JtYXRpb24gc3RyaW5nXG4gICAgLy8gQHByaXZhdGVcbiAgICBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9yaWdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKHRoaXMub3JpZ1ZhbHVlIGluc3RhbmNlb2YgbGF5ZXJfbGF5ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5vcmlnVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKSh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgdmFyIGxheWVyT3B0aW9ucyA9IHdpdGhDYW1lbENhc2VLZXlzKHRoaXMub3JpZ1ZhbHVlKTtcblxuICAgICAgICBpZiAobGF5ZXJPcHRpb25zLnJlc291cmNlVHlwZSA9PT0gXCJ0ZXh0XCIgfHwgbGF5ZXJPcHRpb25zLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyB0ZXh0bGF5ZXIobGF5ZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXllck9wdGlvbnMucmVzb3VyY2VUeXBlID09PSBcInN1YnRpdGxlc1wiKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IHN1YnRpdGxlc2xheWVyKGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5ZXJPcHRpb25zLnJlc291cmNlVHlwZSA9PT0gXCJmZXRjaFwiIHx8IGxheWVyT3B0aW9ucy51cmwgIT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBmZXRjaGxheWVyKGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGxheWVyX2xheWVyKGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgIGlmICgvXmZldGNoOi4rLy50ZXN0KHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBmZXRjaGxheWVyKHRoaXMub3JpZ1ZhbHVlLnN1YnN0cig2KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5vcmlnVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwidGV4dFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRTdHlsZShsYXllcikge1xuICAgICAgcmV0dXJuIG5ldyB0ZXh0bGF5ZXIobGF5ZXIpLnRleHRTdHlsZUlkZW50aWZpZXIoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGF5ZXJQYXJhbTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG5cbnZhciBwYXJhbWV0ZXJzX0V4cHJlc3Npb25QYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtNikge1xuICBwYXJhbWV0ZXJzX2luaGVyaXRzKEV4cHJlc3Npb25QYXJhbSwgX1BhcmFtNik7XG5cbiAgdmFyIF9zdXBlcjYgPSBwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyKEV4cHJlc3Npb25QYXJhbSk7XG5cbiAgZnVuY3Rpb24gRXhwcmVzc2lvblBhcmFtKCkge1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwcmVzc2lvblBhcmFtKTtcblxuICAgIHJldHVybiBfc3VwZXI2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKEV4cHJlc3Npb25QYXJhbSwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZShfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoRXhwcmVzc2lvblBhcmFtLnByb3RvdHlwZSksIFwic2VyaWFsaXplXCIsIHRoaXMpLmNhbGwodGhpcykpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFeHByZXNzaW9uUGFyYW07XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RyYW5zZm9ybWF0aW9uLmpzXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIHRyYW5zZm9ybWF0aW9uX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHRyYW5zZm9ybWF0aW9uX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZihvLCBwKSB7IHRyYW5zZm9ybWF0aW9uX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gdHJhbnNmb3JtYXRpb25faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gdHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmICh0cmFuc2Zvcm1hdGlvbl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gdHJhbnNmb3JtYXRpb25fYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mKG8pIHsgdHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IHRyYW5zZm9ybWF0aW9uX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdHJhbnNmb3JtYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCB0cmFuc2Zvcm1hdGlvbl9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gdHJhbnNmb3JtYXRpb25fYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSB0cmFuc2Zvcm1hdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgdHJhbnNmb3JtYXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXG5cblxuXG5cblxuLyoqXG4gKiBBc3NpZ24ga2V5LCB2YWx1ZSB0byB0YXJnZXQsIHdoZW4gdmFsdWUgaXMgbm90IG51bGwuPGJyPlxuICogICBUaGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHRhcmdldCFcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgdGhlIG9iamVjdCB0byBhc3NpZ24gdGhlIHZhbHVlcyB0b1xuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZXMgb25lIG9yIG1vcmUgb2JqZWN0cyB0byBnZXQgdmFsdWVzIGZyb21cbiAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSB0YXJnZXQgYWZ0ZXIgdGhlIGFzc2lnbm1lbnRcbiAqL1xuXG5mdW5jdGlvbiBhc3NpZ25Ob3ROdWxsKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoc291cmNlW2tleV0gIT0gbnVsbCkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogVHJhbnNmb3JtYXRpb25CYXNlXG4gKiBEZXBlbmRzIG9uICdjb25maWd1cmF0aW9uJywgJ3BhcmFtZXRlcnMnLCd1dGlsJ1xuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFRoZSBiYXNlIGNsYXNzIGZvciB0cmFuc2Zvcm1hdGlvbnMuXG4gICAqIE1lbWJlcnMgb2YgdGhpcyBjbGFzcyBhcmUgZG9jdW1lbnRlZCBhcyBiZWxvbmdpbmcgdG8gdGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gY2xhc3MgZm9yIGNvbnZlbmllbmNlLlxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25CYXNlXG4gICAqL1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbkJhc2Uob3B0aW9ucykge1xuICAgIHRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybWF0aW9uQmFzZSk7XG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHZhciBwYXJlbnQsIHRyYW5zO1xuICAgIHBhcmVudCA9IHZvaWQgMDtcbiAgICB0cmFucyA9IHt9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBvcHRpb25zIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiBpZGVudGljYWwgVHJhbnNmb3JtYXRpb25cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jdG9PcHRpb25zXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGlzIHRyYW5zZm9ybWF0aW9uXG4gICAgICovXG5cbiAgICB0aGlzLnRvT3B0aW9ucyA9IGZ1bmN0aW9uICh3aXRoQ2hhaW4pIHtcbiAgICAgIHZhciBvcHQgPSB7fTtcblxuICAgICAgaWYgKHdpdGhDaGFpbiA9PSBudWxsKSB7XG4gICAgICAgIHdpdGhDaGFpbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5rZXlzKHRyYW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9wdFtrZXldID0gdHJhbnNba2V5XS5vcmlnVmFsdWU7XG4gICAgICB9KTtcbiAgICAgIGFzc2lnbk5vdE51bGwob3B0LCB0aGlzLm90aGVyT3B0aW9ucyk7XG5cbiAgICAgIGlmICh3aXRoQ2hhaW4gJiYgIWlzRW1wdHkodGhpcy5jaGFpbmVkKSkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuY2hhaW5lZC5tYXAoZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyLnRvT3B0aW9ucygpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdC5wdXNoKG9wdCk7XG4gICAgICAgIG9wdCA9IHt9O1xuICAgICAgICBhc3NpZ25Ob3ROdWxsKG9wdCwgdGhpcy5vdGhlck9wdGlvbnMpO1xuICAgICAgICBvcHQudHJhbnNmb3JtYXRpb24gPSBsaXN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGEgcGFyZW50IGZvciB0aGlzIG9iamVjdCBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jc2V0UGFyZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIHRoZSBwYXJlbnQgdG8gYmUgYXNzaWduZWQgdG9cbiAgICAgKiBAcmV0dXJucyB7VHJhbnNmb3JtYXRpb259IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICovXG5cblxuICAgIHRoaXMuc2V0UGFyZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcGFyZW50ID0gb2JqZWN0O1xuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5mcm9tT3B0aW9ucyh0eXBlb2Ygb2JqZWN0LnRvT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8gb2JqZWN0LnRvT3B0aW9ucygpIDogdm9pZCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBvYmplY3QgaW4gdGhlIGNoYWluXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI2dldFBhcmVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGlzIG9iamVjdCBpZiB0aGVyZSBpcyBhbnlcbiAgICAgKi9cblxuXG4gICAgdGhpcy5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH07IC8vIEhlbHBlciBtZXRob2RzIHRvIGNyZWF0ZSBwYXJhbWV0ZXIgbWV0aG9kc1xuICAgIC8vIFRoZXNlIG1ldGhvZHMgYXJlIGRlZmluZWQgaGVyZSBiZWNhdXNlIHRoZXkgYWNjZXNzIGB0cmFuc2Agd2hpY2ggaXNcbiAgICAvLyBhIHByaXZhdGUgbWVtYmVyIG9mIGBUcmFuc2Zvcm1hdGlvbkJhc2VgXG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuXG5cbiAgICB0aGlzLnBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyLCBkZWZhdWx0VmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgIGlmIChwcm9jZXNzID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgcHJvY2VzcyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzID0gaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0LmE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJhbnNbbmFtZV0gPSBuZXcgcGFyYW1ldGVyc19QYXJhbShuYW1lLCBhYmJyLCBwcm9jZXNzKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQHByb3RlY3RlZCAqL1xuXG5cbiAgICB0aGlzLnJhd1BhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyLCBkZWZhdWx0VmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgIHByb2Nlc3MgPSBsYXN0QXJnQ2FsbGJhY2soYXJndW1lbnRzKTtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfUmF3UGFyYW0obmFtZSwgYWJiciwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cblxuXG4gICAgdGhpcy5yYW5nZVBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyLCBkZWZhdWx0VmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgIHByb2Nlc3MgPSBsYXN0QXJnQ2FsbGJhY2soYXJndW1lbnRzKTtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfUmFuZ2VQYXJhbShuYW1lLCBhYmJyLCBwcm9jZXNzKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQHByb3RlY3RlZCAqL1xuXG5cbiAgICB0aGlzLmFycmF5UGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGFiYnIpIHtcbiAgICAgIHZhciBzZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwiOlwiO1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogW107XG4gICAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2VzcyA9IGxhc3RBcmdDYWxsYmFjayhhcmd1bWVudHMpO1xuICAgICAgdHJhbnNbbmFtZV0gPSBuZXcgcGFyYW1ldGVyc19BcnJheVBhcmFtKG5hbWUsIGFiYnIsIHNlcCwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cblxuXG4gICAgdGhpcy50cmFuc2Zvcm1hdGlvblBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyKSB7XG4gICAgICB2YXIgc2VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcIi5cIjtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1RyYW5zZm9ybWF0aW9uUGFyYW0obmFtZSwgYWJiciwgc2VwLCBwcm9jZXNzKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHRoaXMubGF5ZXJQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJicikge1xuICAgICAgdHJhbnNbbmFtZV0gPSBuZXcgcGFyYW1ldGVyc19MYXllclBhcmFtKG5hbWUsIGFiYnIpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9OyAvLyBFbmQgSGVscGVyIG1ldGhvZHNcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNnZXRWYWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEByZXR1cm4geyp9IHRoZSBwcm9jZXNzZWQgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAgICogQGRlc2NyaXB0aW9uIFVzZSB7QGxpbmsgZ2V0fS5vcmlnVmFsdWUgZm9yIHRoZSB2YWx1ZSBvcmlnaW5hbGx5IHByb3ZpZGVkIGZvciB0aGUgcGFyYW1ldGVyXG4gICAgICovXG5cblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gdHJhbnNbbmFtZV0gJiYgdHJhbnNbbmFtZV0udmFsdWUoKTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLm90aGVyT3B0aW9uc1tuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyYW1ldGVyIG9iamVjdCBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI2dldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXJcbiAgICAgKiBAcmV0dXJucyB7UGFyYW19IHRoZSBwYXJhbSBvYmplY3QgZm9yIHRoZSBnaXZlbiBuYW1lLCBvciB1bmRlZmluZWRcbiAgICAgKi9cblxuXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIHRyYW5zW25hbWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgdHJhbnNmb3JtYXRpb24gb3B0aW9uIGZyb20gdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNyZW1vdmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvcHRpb24gdG8gcmVtb3ZlXG4gICAgICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgb3B0aW9uIHRoYXQgd2FzIHJlbW92ZWQgb3IgbnVsbCBpZiBubyBvcHRpb24gYnkgdGhhdCBuYW1lIHdhcyBmb3VuZC4gVGhlIHR5cGUgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgIHJldHVybmVkIHZhbHVlIGRlcGVuZHMgb24gdGhlIHZhbHVlLlxuICAgICAqL1xuXG5cbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdGVtcDtcblxuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlIHRyYW5zW25hbWVdID09IG51bGw6XG4gICAgICAgICAgdGVtcCA9IHRyYW5zW25hbWVdO1xuICAgICAgICAgIGRlbGV0ZSB0cmFuc1tuYW1lXTtcbiAgICAgICAgICByZXR1cm4gdGVtcC5vcmlnVmFsdWU7XG5cbiAgICAgICAgY2FzZSB0aGlzLm90aGVyT3B0aW9uc1tuYW1lXSA9PSBudWxsOlxuICAgICAgICAgIHRlbXAgPSB0aGlzLm90aGVyT3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5vdGhlck9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgcmV0dXJuIHRlbXA7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBhbGwgdGhlIGtleXMgKG9wdGlvbiBuYW1lcykgaW4gdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IHRoZSBrZXlzIGluIHNuYWtlQ2FzZSBmb3JtYXRcbiAgICAgKi9cblxuXG4gICAgdGhpcy5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGtleTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHRzO1xuICAgICAgICByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChrZXkgaW4gdHJhbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChrZXkubWF0Y2goVkFSX05BTUVfUkUpID8ga2V5IDogc25ha2VDYXNlKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSgpLnNvcnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwbGFpbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLiBWYWx1ZXMgYXJlIHByb2Nlc3NlZC5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jdG9QbGFpbk9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnMgYXMgcGxhaW4gb2JqZWN0XG4gICAgICovXG5cblxuICAgIHRoaXMudG9QbGFpbk9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoYXNoLCBrZXksIGxpc3Q7XG4gICAgICBoYXNoID0ge307XG5cbiAgICAgIGZvciAoa2V5IGluIHRyYW5zKSB7XG4gICAgICAgIGhhc2hba2V5XSA9IHRyYW5zW2tleV0udmFsdWUoKTtcblxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKGhhc2hba2V5XSkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKGhhc2hba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMuY2hhaW5lZCkpIHtcbiAgICAgICAgbGlzdCA9IHRoaXMuY2hhaW5lZC5tYXAoZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyLnRvUGxhaW5PYmplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3QucHVzaChoYXNoKTtcbiAgICAgICAgaGFzaCA9IHtcbiAgICAgICAgICB0cmFuc2Zvcm1hdGlvbjogbGlzdFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFuZCBjaGFpbiB0byBhIG5ldyBvbmUuXG4gICAgICogSW4gdGhlIFVSTCwgdHJhbnNmb3JtYXRpb25zIGFyZSBjaGFpbmVkIHRvZ2V0aGVyIGJ5IHNsYXNoZXMuXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI2NoYWluXG4gICAgICogQHJldHVybiB7VHJhbnNmb3JtYXRpb259IFJldHVybnMgdGhpcyB0cmFuc2Zvcm1hdGlvbiBmb3IgY2hhaW5pbmdcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciB0ciA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KCk7XG4gICAgICogdHIud2lkdGgoMTApLmNyb3AoJ2ZpdCcpLmNoYWluKCkuYW5nbGUoMTUpLnNlcmlhbGl6ZSgpXG4gICAgICogLy8gcHJvZHVjZXMgXCJjX2ZpdCx3XzEwL2FfMTVcIlxuICAgICAqL1xuXG5cbiAgICB0aGlzLmNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWVzLCB0cjtcbiAgICAgIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModHJhbnMpO1xuXG4gICAgICBpZiAobmFtZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRyID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50b09wdGlvbnMoZmFsc2UpKTtcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zZm9ybWF0aW9ucygpO1xuICAgICAgICB0aGlzLmNoYWluZWQucHVzaCh0cik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0VHJhbnNmb3JtYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgdHJhbnMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLm90aGVyT3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuY2hhaW5lZCA9IFtdO1xuICAgIHRoaXMuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlIHRoZSBwcm92aWRlZCBvcHRpb25zIHdpdGggb3duJ3Mgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIGtleS12YWx1ZSBsaXN0IG9mIG9wdGlvbnNcbiAgICogQHJldHVybnMge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAqL1xuXG5cbiAgdHJhbnNmb3JtYXRpb25fY3JlYXRlQ2xhc3MoVHJhbnNmb3JtYXRpb25CYXNlLCBbe1xuICAgIGtleTogXCJmcm9tT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tT3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBUcmFuc2Zvcm1hdGlvbkJhc2UpIHtcbiAgICAgICAgdGhpcy5mcm9tVHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkob3B0aW9ucykgfHwgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKG9wdGlvbnMpKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uOiBvcHRpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKG9wdGlvbnMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRyYW5zZm9ybWF0aW9uQmFzZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHZhbHVlLmNsb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gSGFuZGxpbmcgb2YgXCJpZlwiIHN0YXRlbWVudHMgcHJlY2VkZXMgb3RoZXIgb3B0aW9ucyBhcyBpdCBjcmVhdGVzIGEgY2hhaW5lZCB0cmFuc2Zvcm1hdGlvblxuXG4gICAgICAgIGlmIChvcHRpb25zW1wiaWZcIl0pIHtcbiAgICAgICAgICB0aGlzLnNldChcImlmXCIsIG9wdGlvbnNbXCJpZlwiXSk7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnNbXCJpZlwiXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnNba2V5XTtcblxuICAgICAgICAgIGlmIChvcHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGtleS5tYXRjaChWQVJfTkFNRV9SRSkpIHtcbiAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJyRhdHRyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KCd2YXJpYWJsZScsIGtleSwgb3B0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBvcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21UcmFuc2Zvcm1hdGlvbihvdGhlcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgVHJhbnNmb3JtYXRpb25CYXNlKSB7XG4gICAgICAgIG90aGVyLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0KGtleSwgb3RoZXIuZ2V0KGtleSkub3JpZ1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBwYXJhbWV0ZXIuXG4gICAgICogVGhlIHBhcmFtZXRlciBuYW1lIGBrZXlgIGlzIGNvbnZlcnRlZCB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZXMgLSB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEByZXR1cm5zIHtUcmFuc2Zvcm1hdGlvbn0gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXkpIHtcbiAgICAgIHZhciBjYW1lbEtleTtcbiAgICAgIGNhbWVsS2V5ID0gY2FtZWxDYXNlKGtleSk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgdmFsdWVzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcywgY2FtZWxLZXkpKSB7XG4gICAgICAgIHRoaXNbY2FtZWxLZXldLmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm90aGVyT3B0aW9uc1trZXldID0gdmFsdWVzWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzTGF5ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzTGF5ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZShcIm92ZXJsYXlcIikgfHwgdGhpcy5nZXRWYWx1ZShcInVuZGVybGF5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3NlcmlhbGl6ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgdHJhbnNmb3JtYXRpb24gYXMgYSBzdHJpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgaWZQYXJhbSwgaiwgbGVuLCBwYXJhbUxpc3QsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVzdWx0QXJyYXksIHQsIHRyYW5zZm9ybWF0aW9uTGlzdCwgdHJhbnNmb3JtYXRpb25TdHJpbmcsIHRyYW5zZm9ybWF0aW9ucywgdmFsdWUsIHZhcmlhYmxlcywgdmFycztcbiAgICAgIHJlc3VsdEFycmF5ID0gdGhpcy5jaGFpbmVkLm1hcChmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLnNlcmlhbGl6ZSgpO1xuICAgICAgfSk7XG4gICAgICBwYXJhbUxpc3QgPSB0aGlzLmtleXMoKTtcbiAgICAgIHRyYW5zZm9ybWF0aW9ucyA9IChyZWYgPSB0aGlzLmdldChcInRyYW5zZm9ybWF0aW9uXCIpKSAhPSBudWxsID8gcmVmLnNlcmlhbGl6ZSgpIDogdm9pZCAwO1xuICAgICAgaWZQYXJhbSA9IChyZWYxID0gdGhpcy5nZXQoXCJpZlwiKSkgIT0gbnVsbCA/IHJlZjEuc2VyaWFsaXplKCkgOiB2b2lkIDA7XG4gICAgICB2YXJpYWJsZXMgPSBwcm9jZXNzVmFyKChyZWYyID0gdGhpcy5nZXQoXCJ2YXJpYWJsZXNcIikpICE9IG51bGwgPyByZWYyLnZhbHVlKCkgOiB2b2lkIDApO1xuICAgICAgcGFyYW1MaXN0ID0gZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfZGVmYXVsdCgpKHBhcmFtTGlzdCwgW1widHJhbnNmb3JtYXRpb25cIiwgXCJpZlwiLCBcInZhcmlhYmxlc1wiXSk7XG4gICAgICB2YXJzID0gW107XG4gICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QgPSBbXTtcblxuICAgICAgZm9yIChqID0gMCwgbGVuID0gcGFyYW1MaXN0Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHQgPSBwYXJhbUxpc3Rbal07XG5cbiAgICAgICAgaWYgKHQubWF0Y2goVkFSX05BTUVfUkUpKSB7XG4gICAgICAgICAgdmFycy5wdXNoKHQgKyBcIl9cIiArIGV4cHJlc3Npb24ubm9ybWFsaXplKChyZWYzID0gdGhpcy5nZXQodCkpICE9IG51bGwgPyByZWYzLnZhbHVlKCkgOiB2b2lkIDApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QucHVzaCgocmVmNCA9IHRoaXMuZ2V0KHQpKSAhPSBudWxsID8gcmVmNC5zZXJpYWxpemUoKSA6IHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlICFpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh0cmFuc2Zvcm1hdGlvbnMpOlxuICAgICAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdC5wdXNoKHRyYW5zZm9ybWF0aW9ucyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAhaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9ucyk6XG4gICAgICAgICAgcmVzdWx0QXJyYXkgPSByZXN1bHRBcnJheS5jb25jYXQodHJhbnNmb3JtYXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNmb3JtYXRpb25MaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaywgbGVuMSwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvciAoayA9IDAsIGxlbjEgPSB0cmFuc2Zvcm1hdGlvbkxpc3QubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgICAgdmFsdWUgPSB0cmFuc2Zvcm1hdGlvbkxpc3Rba107XG5cbiAgICAgICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbHVlKSAmJiAhaXNFbXB0eSh2YWx1ZSkgfHwgIWlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YWx1ZSkgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KCk7XG5cbiAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdCA9IHZhcnMuc29ydCgpLmNvbmNhdCh2YXJpYWJsZXMpLmNvbmNhdCh0cmFuc2Zvcm1hdGlvbkxpc3Quc29ydCgpKTtcblxuICAgICAgaWYgKGlmUGFyYW0gPT09IFwiaWZfZW5kXCIpIHtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnB1c2goaWZQYXJhbSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtcHR5KGlmUGFyYW0pKSB7XG4gICAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdC51bnNoaWZ0KGlmUGFyYW0pO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2Zvcm1hdGlvblN0cmluZyA9IGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKSh0cmFuc2Zvcm1hdGlvbkxpc3QpLmpvaW4odGhpcy5wYXJhbV9zZXBhcmF0b3IpO1xuXG4gICAgICBpZiAoIWlzRW1wdHkodHJhbnNmb3JtYXRpb25TdHJpbmcpKSB7XG4gICAgICAgIHJlc3VsdEFycmF5LnB1c2godHJhbnNmb3JtYXRpb25TdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKHJlc3VsdEFycmF5KS5qb2luKHRoaXMudHJhbnNfc2VwYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBhIGxpc3Qgb2YgYWxsIHRoZSB2YWxpZCB0cmFuc2Zvcm1hdGlvbiBvcHRpb24gbmFtZXNcbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jbGlzdE5hbWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBhIGFycmF5IG9mIGFsbCB0aGUgdmFsaWQgb3B0aW9uIG5hbWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b0h0bWxBdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXR0cmlidXRlcyBmb3IgYW4gSFRNTCB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkudG9IdG1sQXR0cmlidXRlc1xuICAgICAqIEByZXR1cm4gUGxhaW5PYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0h0bWxBdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBhdHRyTmFtZSwgaGVpZ2h0LCBvcHRpb25zLCByZWYyLCByZWYzLCB2YWx1ZSwgd2lkdGg7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgICB2YXIgc25ha2VDYXNlS2V5O1xuICAgICAgT2JqZWN0LmtleXModGhpcy5vdGhlck9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YWx1ZSA9IF90aGlzMi5vdGhlck9wdGlvbnNba2V5XTtcbiAgICAgICAgc25ha2VDYXNlS2V5ID0gc25ha2VDYXNlKGtleSk7XG5cbiAgICAgICAgaWYgKCFpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKSh0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5QQVJBTV9OQU1FUywgc25ha2VDYXNlS2V5KSAmJiAhaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkoVVJMX0tFWVMsIHNuYWtlQ2FzZUtleSkpIHtcbiAgICAgICAgICBhdHRyTmFtZSA9IC9eaHRtbF8vLnRlc3Qoa2V5KSA/IGtleS5zbGljZSg1KSA6IGtleTtcbiAgICAgICAgICBvcHRpb25zW2F0dHJOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gY29udmVydCBhbGwgXCJodG1sX2tleVwiIHRvIFwia2V5XCIgd2l0aCB0aGUgc2FtZSB2YWx1ZVxuXG4gICAgICB0aGlzLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKC9eaHRtbF8vLnRlc3Qoa2V5KSkge1xuICAgICAgICAgIG9wdGlvbnNbY2FtZWxDYXNlKGtleS5zbGljZSg1KSldID0gX3RoaXMyLmdldFZhbHVlKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoISh0aGlzLmhhc0xheWVyKCkgfHwgdGhpcy5nZXRWYWx1ZShcImFuZ2xlXCIpIHx8IGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKFtcImZpdFwiLCBcImxpbWl0XCIsIFwibGZpbGxcIl0sIHRoaXMuZ2V0VmFsdWUoXCJjcm9wXCIpKSkpIHtcbiAgICAgICAgd2lkdGggPSAocmVmMiA9IHRoaXMuZ2V0KFwid2lkdGhcIikpICE9IG51bGwgPyByZWYyLm9yaWdWYWx1ZSA6IHZvaWQgMDtcbiAgICAgICAgaGVpZ2h0ID0gKHJlZjMgPSB0aGlzLmdldChcImhlaWdodFwiKSkgIT0gbnVsbCA/IHJlZjMub3JpZ1ZhbHVlIDogdm9pZCAwO1xuXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KHdpZHRoKSA+PSAxLjApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy53aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlRmxvYXQoaGVpZ2h0KSA+PSAxLjApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0h0bWxcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZSB0byB0aGUgcGFyZW50ICh1cCB0aGUgY2FsbCBjaGFpbikgdG8gcHJvZHVjZSBIVE1MXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3RvSHRtbFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGFyZW50IGlmIHBvc3NpYmxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdGFnID0gY2xvdWRpbmFyeS5JbWFnZVRhZy5uZXcoXCJzYW1wbGVcIiwge2Nsb3VkX25hbWU6IFwiZGVtb1wifSlcbiAgICAgKiAvLyBJbWFnZVRhZyB7bmFtZTogXCJpbWdcIiwgcHVibGljSWQ6IFwic2FtcGxlXCJ9XG4gICAgICogdGFnLnRvSHRtbCgpXG4gICAgICogLy8gPGltZyBzcmM9XCJodHRwOi8vcmVzLmNsb3VkaW5hcnkuY29tL2RlbW8vaW1hZ2UvdXBsb2FkL3NhbXBsZVwiPlxuICAgICAqIHRhZy50cmFuc2Zvcm1hdGlvbigpLmNyb3AoXCJmaXRcIikud2lkdGgoMzAwKS50b0h0bWwoKVxuICAgICAqIC8vIDxpbWcgc3JjPVwiaHR0cDovL3Jlcy5jbG91ZGluYXJ5LmNvbS9kZW1vL2ltYWdlL3VwbG9hZC9jX2ZpdCx3XzMwMC9zYW1wbGVcIj5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0h0bWwoKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLmdldFBhcmVudCgpKSAhPSBudWxsID8gdHlwZW9mIHJlZi50b0h0bWwgPT09IFwiZnVuY3Rpb25cIiA/IHJlZi50b0h0bWwoKSA6IHZvaWQgMCA6IHZvaWQgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50b09wdGlvbnModHJ1ZSkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImxpc3ROYW1lc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0TmFtZXMoKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNWYWxpZFBhcmFtTmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkUGFyYW1OYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzLmluZGV4T2YoY2FtZWxDYXNlKG5hbWUpKSA+PSAwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2Zvcm1hdGlvbkJhc2U7XG59KCk7XG5cbnZhciBWQVJfTkFNRV9SRSA9IC9eXFwkW2EtekEtWjAtOV0rJC87XG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UucHJvdG90eXBlLnRyYW5zX3NlcGFyYXRvciA9ICcvJztcbnRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uQmFzZS5wcm90b3R5cGUucGFyYW1fc2VwYXJhdG9yID0gJywnO1xuXG5mdW5jdGlvbiBsYXN0QXJnQ2FsbGJhY2soYXJncykge1xuICB2YXIgY2FsbGJhY2s7XG4gIGNhbGxiYWNrID0gYXJncyAhPSBudWxsID8gYXJnc1thcmdzLmxlbmd0aCAtIDFdIDogdm9pZCAwO1xuXG4gIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Zhcih2YXJBcnJheSkge1xuICB2YXIgaiwgbGVuLCBuYW1lLCByZXN1bHRzLCB2O1xuXG4gIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodmFyQXJyYXkpKSB7XG4gICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yIChqID0gMCwgbGVuID0gdmFyQXJyYXkubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBfdmFyQXJyYXkkaiA9IHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkodmFyQXJyYXlbal0sIDIpO1xuXG4gICAgICBuYW1lID0gX3ZhckFycmF5JGpbMF07XG4gICAgICB2ID0gX3ZhckFycmF5JGpbMV07XG4gICAgICByZXN1bHRzLnB1c2goXCJcIi5jb25jYXQobmFtZSwgXCJfXCIpLmNvbmNhdChleHByZXNzaW9uLm5vcm1hbGl6ZSh2KSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YXJBcnJheTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ3VzdG9tRnVuY3Rpb24oX3JlZikge1xuICB2YXIgZnVuY3Rpb25fdHlwZSA9IF9yZWYuZnVuY3Rpb25fdHlwZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYuc291cmNlO1xuXG4gIGlmIChmdW5jdGlvbl90eXBlID09PSAncmVtb3RlJykge1xuICAgIHJldHVybiBbZnVuY3Rpb25fdHlwZSwgYnRvYShzb3VyY2UpXS5qb2luKFwiOlwiKTtcbiAgfSBlbHNlIGlmIChmdW5jdGlvbl90eXBlID09PSAnd2FzbScpIHtcbiAgICByZXR1cm4gW2Z1bmN0aW9uX3R5cGUsIHNvdXJjZV0uam9pbihcIjpcIik7XG4gIH1cbn1cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gQ2xhc3MgbWV0aG9kcy5cbiAqIFRoaXMgaXMgYSBsaXN0IG9mIHRoZSBwYXJhbWV0ZXJzIGRlZmluZWQgaW4gVHJhbnNmb3JtYXRpb24uXG4gKiBWYWx1ZXMgYXJlIGNhbWVsQ2FzZWQuXG4gKiBAY29uc3QgVHJhbnNmb3JtYXRpb24ubWV0aG9kc1xuICogQHByaXZhdGVcbiAqIEBpZ25vcmVcbiAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICovXG5cbi8qKlxuICogUGFyYW1ldGVycyB0aGF0IGFyZSBmaWx0ZXJlZCBvdXQgYmVmb3JlIHBhc3NpbmcgdGhlIG9wdGlvbnMgdG8gYW4gSFRNTCB0YWcuXG4gKlxuICogVGhlIGxpc3Qgb2YgcGFyYW1ldGVycyBpcyBhIGNvbWJpbmF0aW9uIG9mIGBUcmFuc2Zvcm1hdGlvbjo6bWV0aG9kc2AgYW5kIGBDb25maWd1cmF0aW9uOjpDT05GSUdfUEFSQU1TYFxuICogQGNvbnN0IHtBcnJheTxzdHJpbmc+fSBUcmFuc2Zvcm1hdGlvbi5QQVJBTV9OQU1FU1xuICogQHByaXZhdGVcbiAqIEBpZ25vcmVcbiAqIEBzZWUgdG9IdG1sQXR0cmlidXRlc1xuICovXG5cblxudmFyIHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHJhbnNmb3JtYXRpb25CYXNlKSB7XG4gIHRyYW5zZm9ybWF0aW9uX2luaGVyaXRzKFRyYW5zZm9ybWF0aW9uLCBfVHJhbnNmb3JtYXRpb25CYXNlKTtcblxuICB2YXIgX3N1cGVyID0gdHJhbnNmb3JtYXRpb25fY3JlYXRlU3VwZXIoVHJhbnNmb3JtYXRpb24pO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2luZ2xlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cbiAgICogQGV4YW1wbGVcbiAgICogdCA9IG5ldyBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uKCk7XG4gICAqIHQuYW5nbGUoMjApLmNyb3AoXCJzY2FsZVwiKS53aWR0aChcImF1dG9cIik7XG4gICAqXG4gICAqIC8vIG9yXG4gICAqXG4gICAqIHQgPSBuZXcgY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbigge2FuZ2xlOiAyMCwgY3JvcDogXCJzY2FsZVwiLCB3aWR0aDogXCJhdXRvXCJ9KTtcbiAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCJcbiAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAqL1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihvcHRpb25zKSB7XG4gICAgdHJhbnNmb3JtYXRpb25fY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtYXRpb24pO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm1hdGlvbn1cbiAgICogQGV4YW1wbGUgY2wgPSBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uLm5ldygge2FuZ2xlOiAyMCwgY3JvcDogXCJzY2FsZVwiLCB3aWR0aDogXCJhdXRvXCJ9KVxuICAgKi9cblxuXG4gIHRyYW5zZm9ybWF0aW9uX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybWF0aW9uLCBbe1xuICAgIGtleTogXCJhbmdsZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qXG4gICAgICBUcmFuc2Zvcm1hdGlvbiBQYXJhbWV0ZXJzXG4gICAgKi9cbiAgICBmdW5jdGlvbiBhbmdsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJhbmdsZVwiLCBcImFcIiwgXCIuXCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXVkaW9Db2RlY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdWRpb0NvZGVjKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJhdWRpb19jb2RlY1wiLCBcImFjXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdWRpb0ZyZXF1ZW5jeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdWRpb0ZyZXF1ZW5jeSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYXVkaW9fZnJlcXVlbmN5XCIsIFwiYWZcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJhc3BlY3RfcmF0aW9cIiwgXCJhclwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhY2tncm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFja2dyb3VuZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYmFja2dyb3VuZFwiLCBcImJcIiwgcGFyYW1ldGVyc19QYXJhbS5ub3JtX2NvbG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYml0UmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaXRSYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJiaXRfcmF0ZVwiLCBcImJyXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJib3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYm9yZGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJib3JkZXJcIiwgXCJib1wiLCBmdW5jdGlvbiAoYm9yZGVyKSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkoYm9yZGVyKSkge1xuICAgICAgICAgIGJvcmRlciA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe30sIHtcbiAgICAgICAgICAgIGNvbG9yOiBcImJsYWNrXCIsXG4gICAgICAgICAgICB3aWR0aDogMlxuICAgICAgICAgIH0sIGJvcmRlcik7XG4gICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGJvcmRlci53aWR0aCwgXCJweF9zb2xpZF9cIikuY29uY2F0KHBhcmFtZXRlcnNfUGFyYW0ubm9ybV9jb2xvcihib3JkZXIuY29sb3IpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYm9yZGVyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImNvbG9yXCIsIFwiY29cIiwgcGFyYW1ldGVyc19QYXJhbS5ub3JtX2NvbG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29sb3JTcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb2xvclNwYWNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjb2xvcl9zcGFjZVwiLCBcImNzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcm9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyb3AodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImNyb3BcIiwgXCJjXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXN0b21GdW5jdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXN0b21GdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiY3VzdG9tX2Z1bmN0aW9uXCIsIFwiZm5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc0N1c3RvbUZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXN0b21QcmVGdW5jdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXN0b21QcmVGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuZ2V0KCdjdXN0b21fZnVuY3Rpb24nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJhd1BhcmFtKHZhbHVlLCBcImN1c3RvbV9mdW5jdGlvblwiLCBcIlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhbHVlID0gcHJvY2Vzc0N1c3RvbUZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gXCJmbl9wcmU6XCIuY29uY2F0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0SW1hZ2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImRlZmF1bHRfaW1hZ2VcIiwgXCJkXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZGVsYXlcIiwgXCJkbFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVuc2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZW5zaXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJkZW5zaXR5XCIsIFwiZG5cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZVBhcmFtKHZhbHVlLCBcImR1cmF0aW9uXCIsIFwiZHVcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRwclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcHIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImRwclwiLCBcImRwclwiLCBmdW5jdGlvbiAoZHByKSB7XG4gICAgICAgIGRwciA9IGRwci50b1N0cmluZygpO1xuXG4gICAgICAgIGlmIChkcHIgIT0gbnVsbCA/IGRwci5tYXRjaCgvXlxcZCskLykgOiB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gZHByICsgXCIuMFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZShkcHIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWZmZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVmZmVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJlZmZlY3RcIiwgXCJlXCIsIFwiOlwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVsc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Vsc2UoKSB7XG4gICAgICByZXR1cm4gdGhpc1tcImlmXCJdKCdlbHNlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZElmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZElmKCkge1xuICAgICAgcmV0dXJuIHRoaXNbXCJpZlwiXSgnZW5kJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZmZzZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlUGFyYW0odmFsdWUsIFwiZW5kX29mZnNldFwiLCBcImVvXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmYWxsYmFja0NvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFsbGJhY2tDb250ZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJmYWxsYmFja19jb250ZW50XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmZXRjaEZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmZXRjaEZvcm1hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZmV0Y2hfZm9ybWF0XCIsIFwiZlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZm9ybWF0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmbGFnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbGFncyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJmbGFnc1wiLCBcImZsXCIsIFwiLlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3Jhdml0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmF2aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJncmF2aXR5XCIsIFwiZ1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZwcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZnBzXCIsIFwiZnBzXCIsIGZ1bmN0aW9uIChmcHMpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGZwcykpIHtcbiAgICAgICAgICByZXR1cm4gZnBzO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShmcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZwcy5qb2luKFwiLVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZnBzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlaWdodCh2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImhlaWdodFwiLCBcImhcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMzLmdldFZhbHVlKFwiY3JvcFwiKSB8fCBfdGhpczMuZ2V0VmFsdWUoXCJvdmVybGF5XCIpIHx8IF90aGlzMy5nZXRWYWx1ZShcInVuZGVybGF5XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImh0bWxIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaHRtbEhlaWdodCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaHRtbF9oZWlnaHRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImh0bWxXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBodG1sV2lkdGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImh0bWxfd2lkdGhcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pZigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJcIjtcbiAgICAgIHZhciBpLCBpZlZhbCwgaiwgcmVmLCB0cklmLCB0clJlc3Q7XG5cbiAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImVsc2VcIjpcbiAgICAgICAgICB0aGlzLmNoYWluKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaWZcIiwgXCJpZlwiKTtcblxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgdGhpcy5jaGFpbigpO1xuXG4gICAgICAgICAgZm9yIChpID0gaiA9IHJlZiA9IHRoaXMuY2hhaW5lZC5sZW5ndGggLSAxOyBqID49IDA7IGkgPSBqICs9IC0xKSB7XG4gICAgICAgICAgICBpZlZhbCA9IHRoaXMuY2hhaW5lZFtpXS5nZXRWYWx1ZShcImlmXCIpO1xuXG4gICAgICAgICAgICBpZiAoaWZWYWwgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlmVmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdHJJZiA9IFRyYW5zZm9ybWF0aW9uW1wibmV3XCJdKClbXCJpZlwiXShpZlZhbCk7XG4gICAgICAgICAgICAgIHRoaXMuY2hhaW5lZFtpXS5yZW1vdmUoXCJpZlwiKTtcbiAgICAgICAgICAgICAgdHJSZXN0ID0gdGhpcy5jaGFpbmVkW2ldO1xuICAgICAgICAgICAgICB0aGlzLmNoYWluZWRbaV0gPSBUcmFuc2Zvcm1hdGlvbltcIm5ld1wiXSgpLnRyYW5zZm9ybWF0aW9uKFt0cklmLCB0clJlc3RdKTtcblxuICAgICAgICAgICAgICBpZiAoaWZWYWwgIT09IFwiZWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJpZlwiLCBcImlmXCIpO1xuXG4gICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICByZXR1cm4gY29uZGl0aW9uW1wibmV3XCJdKCkuc2V0UGFyZW50KHRoaXMpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaWZcIiwgXCJpZlwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25bXCJuZXdcIl0odmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImtleWZyYW1lSW50ZXJ2YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5ZnJhbWVJbnRlcnZhbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwia2V5ZnJhbWVfaW50ZXJ2YWxcIiwgXCJraVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2NyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9jcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwib2NyXCIsIFwib2NyXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2Zmc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgZW5kX28sIHN0YXJ0X287XG5cbiAgICAgIHZhciBfcmVmMiA9IGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh2YWx1ZSAhPSBudWxsID8gdmFsdWUuc3BsaXQgOiB2b2lkIDApID8gdmFsdWUuc3BsaXQoJy4uJykgOiBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodmFsdWUpID8gdmFsdWUgOiBbbnVsbCwgbnVsbF07XG5cbiAgICAgIHZhciBfcmVmMyA9IHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkoX3JlZjIsIDIpO1xuXG4gICAgICBzdGFydF9vID0gX3JlZjNbMF07XG4gICAgICBlbmRfbyA9IF9yZWYzWzFdO1xuXG4gICAgICBpZiAoc3RhcnRfbyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhcnRPZmZzZXQoc3RhcnRfbyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRfbyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZE9mZnNldChlbmRfbyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wYWNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BhY2l0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwib3BhY2l0eVwiLCBcIm9cIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdmVybGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVyUGFyYW0odmFsdWUsIFwib3ZlcmxheVwiLCBcImxcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwicGFnZVwiLCBcInBnXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJwb3N0ZXJcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZWZpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVmaXgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInByZWZpeFwiLCBcInBcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInF1YWxpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcXVhbGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwicXVhbGl0eVwiLCBcInFcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYWRpdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFkaXVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVBhcmFtKHZhbHVlLCBcInJhZGl1c1wiLCBcInJcIiwgXCI6XCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmF3VHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmF3VHJhbnNmb3JtYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhd1BhcmFtKHZhbHVlLCBcInJhd190cmFuc2Zvcm1hdGlvblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgICB2YXIgaGVpZ2h0LCB3aWR0aDtcblxuICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh2YWx1ZSAhPSBudWxsID8gdmFsdWUuc3BsaXQgOiB2b2lkIDApKSB7XG4gICAgICAgIHZhciBfdmFsdWUkc3BsaXQgPSB2YWx1ZS5zcGxpdCgneCcpO1xuXG4gICAgICAgIHZhciBfdmFsdWUkc3BsaXQyID0gdHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheShfdmFsdWUkc3BsaXQsIDIpO1xuXG4gICAgICAgIHdpZHRoID0gX3ZhbHVlJHNwbGl0MlswXTtcbiAgICAgICAgaGVpZ2h0ID0gX3ZhbHVlJHNwbGl0MlsxXTtcbiAgICAgICAgdGhpcy53aWR0aCh3aWR0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodChoZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzb3VyY2VUeXBlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3VyY2VUeXBlcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwic291cmNlX3R5cGVzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzb3VyY2VUcmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3VyY2VUcmFuc2Zvcm1hdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwic291cmNlX3RyYW5zZm9ybWF0aW9uXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydE9mZnNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2VQYXJhbSh2YWx1ZSwgXCJzdGFydF9vZmZzZXRcIiwgXCJzb1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RyZWFtaW5nUHJvZmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJlYW1pbmdQcm9maWxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJzdHJlYW1pbmdfcHJvZmlsZVwiLCBcInNwXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb25QYXJhbSh2YWx1ZSwgXCJ0cmFuc2Zvcm1hdGlvblwiLCBcInRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuZGVybGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuZGVybGF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXllclBhcmFtKHZhbHVlLCBcInVuZGVybGF5XCIsIFwidVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFyaWFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBuYW1lLCBuYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFyaWFibGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhcmlhYmxlcyh2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWVzLCBcInZhcmlhYmxlc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9Db2RlY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb0NvZGVjKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ2aWRlb19jb2RlY1wiLCBcInZjXCIsIHBhcmFtZXRlcnNfUGFyYW0ucHJvY2Vzc192aWRlb19wYXJhbXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb1NhbXBsaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvU2FtcGxpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInZpZGVvX3NhbXBsaW5nXCIsIFwidnNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwid2lkdGhcIiwgXCJ3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzNC5nZXRWYWx1ZShcImNyb3BcIikgfHwgX3RoaXM0LmdldFZhbHVlKFwib3ZlcmxheVwiKSB8fCBfdGhpczQuZ2V0VmFsdWUoXCJ1bmRlcmxheVwiKSkge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInhcIiwgXCJ4XCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ5XCIsIFwieVwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiem9vbVwiLCBcInpcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5ld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYW5zZm9ybWF0aW9uO1xufSh0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UpO1xuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBDbGFzcyBtZXRob2RzLlxuICogVGhpcyBpcyBhIGxpc3Qgb2YgdGhlIHBhcmFtZXRlcnMgZGVmaW5lZCBpbiBUcmFuc2Zvcm1hdGlvbi5cbiAqIFZhbHVlcyBhcmUgY2FtZWxDYXNlZC5cbiAqL1xuXG5cbnRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHMgPSBbXCJhbmdsZVwiLCBcImF1ZGlvQ29kZWNcIiwgXCJhdWRpb0ZyZXF1ZW5jeVwiLCBcImFzcGVjdFJhdGlvXCIsIFwiYmFja2dyb3VuZFwiLCBcImJpdFJhdGVcIiwgXCJib3JkZXJcIiwgXCJjb2xvclwiLCBcImNvbG9yU3BhY2VcIiwgXCJjcm9wXCIsIFwiY3VzdG9tRnVuY3Rpb25cIiwgXCJjdXN0b21QcmVGdW5jdGlvblwiLCBcImRlZmF1bHRJbWFnZVwiLCBcImRlbGF5XCIsIFwiZGVuc2l0eVwiLCBcImR1cmF0aW9uXCIsIFwiZHByXCIsIFwiZWZmZWN0XCIsIFwiZWxzZVwiLCBcImVuZElmXCIsIFwiZW5kT2Zmc2V0XCIsIFwiZmFsbGJhY2tDb250ZW50XCIsIFwiZmV0Y2hGb3JtYXRcIiwgXCJmb3JtYXRcIiwgXCJmbGFnc1wiLCBcImdyYXZpdHlcIiwgXCJmcHNcIiwgXCJoZWlnaHRcIiwgXCJodG1sSGVpZ2h0XCIsIFwiaHRtbFdpZHRoXCIsIFwiaWZcIiwgXCJrZXlmcmFtZUludGVydmFsXCIsIFwib2NyXCIsIFwib2Zmc2V0XCIsIFwib3BhY2l0eVwiLCBcIm92ZXJsYXlcIiwgXCJwYWdlXCIsIFwicG9zdGVyXCIsIFwicHJlZml4XCIsIFwicXVhbGl0eVwiLCBcInJhZGl1c1wiLCBcInJhd1RyYW5zZm9ybWF0aW9uXCIsIFwic2l6ZVwiLCBcInNvdXJjZVR5cGVzXCIsIFwic291cmNlVHJhbnNmb3JtYXRpb25cIiwgXCJzdGFydE9mZnNldFwiLCBcInN0cmVhbWluZ1Byb2ZpbGVcIiwgXCJ0cmFuc2Zvcm1hdGlvblwiLCBcInVuZGVybGF5XCIsIFwidmFyaWFibGVcIiwgXCJ2YXJpYWJsZXNcIiwgXCJ2aWRlb0NvZGVjXCIsIFwidmlkZW9TYW1wbGluZ1wiLCBcIndpZHRoXCIsIFwieFwiLCBcInlcIiwgXCJ6b29tXCJdO1xuLyoqXG4gKiBQYXJhbWV0ZXJzIHRoYXQgYXJlIGZpbHRlcmVkIG91dCBiZWZvcmUgcGFzc2luZyB0aGUgb3B0aW9ucyB0byBhbiBIVE1MIHRhZy5cbiAqXG4gKiBUaGUgbGlzdCBvZiBwYXJhbWV0ZXJzIGlzIGEgY29tYmluYXRpb24gb2YgYFRyYW5zZm9ybWF0aW9uOjptZXRob2RzYCBhbmQgYENvbmZpZ3VyYXRpb246OkNPTkZJR19QQVJBTVNgXG4gKi9cblxudHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24uUEFSQU1fTkFNRVMgPSB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzLm1hcChzbmFrZUNhc2UpLmNvbmNhdChzcmNfY29uZmlndXJhdGlvbi5DT05GSUdfUEFSQU1TKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY190cmFuc2Zvcm1hdGlvbiA9ICh0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL2h0bWx0YWcuanNcbmZ1bmN0aW9uIGh0bWx0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBodG1sdGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBodG1sdGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgaHRtbHRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgaHRtbHRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIEdlbmVyaWMgSFRNTCB0YWdcbiAqIERlcGVuZHMgb24gJ3RyYW5zZm9ybWF0aW9uJywgJ3V0aWwnXG4gKi9cblxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSFRNTCAoRE9NKSB0YWdcbiAqIEBjb25zdHJ1Y3RvciBIdG1sVGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB0YWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGV4YW1wbGUgdGFnID0gbmV3IEh0bWxUYWcoICdkaXYnLCB7ICd3aWR0aCc6IDEwfSlcbiAqL1xuXG52YXIgaHRtbHRhZ19IdG1sVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSHRtbFRhZyhuYW1lLCBwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgIGh0bWx0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgSHRtbFRhZyk7XG5cbiAgICB2YXIgdHJhbnNmb3JtYXRpb247XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnB1YmxpY0lkID0gcHVibGljSWQ7XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHB1YmxpY0lkKSkge1xuICAgICAgICBvcHRpb25zID0gcHVibGljSWQ7XG4gICAgICAgIHRoaXMucHVibGljSWQgPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtYXRpb24gPSBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICAgIHRyYW5zZm9ybWF0aW9uLnNldFBhcmVudCh0aGlzKTtcblxuICAgIHRoaXMudHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb247XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3JcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBIVE1MIChET00pIHRhZ1xuICAgKiBAZnVuY3Rpb24gSHRtbFRhZy5uZXdcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdGFnXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge0h0bWxUYWd9XG4gICAqIEBleGFtcGxlIHRhZyA9IEh0bWxUYWcubmV3KCAnZGl2JywgeyAnd2lkdGgnOiAxMH0pXG4gICAqL1xuXG5cbiAgaHRtbHRhZ19jcmVhdGVDbGFzcyhIdG1sVGFnLCBbe1xuICAgIGtleTogXCJodG1sQXR0cnNcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBjb21iaW5lIGtleSBhbmQgdmFsdWUgZnJvbSB0aGUgYGF0dHJgIHRvIGdlbmVyYXRlIGFuIEhUTUwgdGFnIGF0dHJpYnV0ZXMgc3RyaW5nLlxuICAgICAqIGBUcmFuc2Zvcm1hdGlvbjo6dG9IdG1sVGFnT3B0aW9uc2AgaXMgdXNlZCB0byBmaWx0ZXIgb3V0IHRyYW5zZm9ybWF0aW9uIGFuZCBjb25maWd1cmF0aW9uIGtleXMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGF0dHJpYnV0ZXMgaW4gdGhlIGZvcm1hdCBgJ2tleTE9XCJ2YWx1ZTFcIiBrZXkyPVwidmFsdWUyXCInYFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBodG1sQXR0cnMoYXR0cnMpIHtcbiAgICAgIHZhciBrZXksIHBhaXJzLCB2YWx1ZTtcbiAgICAgIHJldHVybiBwYWlycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICAgIHZhbHVlID0gZXNjYXBlUXVvdGVzKGF0dHJzW2tleV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaHRtbHRhZ190b0F0dHJpYnV0ZShrZXksIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KCkuc29ydCgpLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBvcHRpb25zIHJlbGF0ZWQgdG8gdGhpcyB0YWcuXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjZ2V0T3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBvcHRpb25zXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uKCkudG9PcHRpb25zKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2Ygb3B0aW9uIGBuYW1lYFxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2dldE9wdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE9wdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24oKS5nZXRWYWx1ZShuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSB0YWcuXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjYXR0cmlidXRlc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIC8vIFRoZSBhdHRyaWJ1dGVzIGFyZSBiZSBjb21wdXRlZCBmcm9tIHRoZSBvcHRpb25zIGV2ZXJ5IHRpbWUgdGhpcyBtZXRob2QgaXMgaW52b2tlZC5cbiAgICAgIHZhciBodG1sQXR0cmlidXRlcyA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS50b0h0bWxBdHRyaWJ1dGVzKCk7XG4gICAgICBPYmplY3Qua2V5cyhodG1sQXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkoaHRtbEF0dHJpYnV0ZXNba2V5XSkpIHtcbiAgICAgICAgICBkZWxldGUgaHRtbEF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChodG1sQXR0cmlidXRlcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8vIEN1cnJlbnRseSBIVE1MIGF0dHJpYnV0ZXMgYXJlIGRlZmluZWQgYm90aCBhdCB0aGUgdG9wIGxldmVsIGFuZCB1bmRlciAnYXR0cmlidXRlcydcbiAgICAgICAgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoaHRtbEF0dHJpYnV0ZXMsIGh0bWxBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMpO1xuICAgICAgICBkZWxldGUgaHRtbEF0dHJpYnV0ZXMuYXR0cmlidXRlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGh0bWxBdHRyaWJ1dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSB0YWcgYXR0cmlidXRlIG5hbWVkIGBuYW1lYCB0byBgdmFsdWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjc2V0QXR0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRBdHRyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHIobmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5zZXQoXCJodG1sX1wiLmNvbmNhdChuYW1lKSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIHRhZyBhdHRyaWJ1dGUgYG5hbWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjZ2V0QXR0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMoKVtcImh0bWxfXCIuY29uY2F0KG5hbWUpXSB8fCB0aGlzLmF0dHJpYnV0ZXMoKVtuYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSB0YWcgYXR0cmlidXRlZCBuYW1lZCBgbmFtZWBcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNyZW1vdmVBdHRyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVBdHRyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0dHIobmFtZSkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiAocmVmID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLnJlbW92ZShcImh0bWxfXCIuY29uY2F0KG5hbWUpKSkgIT0gbnVsbCA/IHJlZiA6IHRoaXMudHJhbnNmb3JtYXRpb24oKS5yZW1vdmUobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2NvbnRlbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI29wZW5UYWdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3BlblRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuVGFnKCkge1xuICAgICAgdmFyIHRhZyA9IFwiPFwiICsgdGhpcy5uYW1lO1xuICAgICAgdmFyIGh0bWxBdHRycyA9IHRoaXMuaHRtbEF0dHJzKHRoaXMuYXR0cmlidXRlcygpKTtcblxuICAgICAgaWYgKGh0bWxBdHRycyAmJiBodG1sQXR0cnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0YWcgKz0gXCIgXCIgKyBodG1sQXR0cnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YWcgKyBcIj5cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjY2xvc2VUYWdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCI8L1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiPlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIEhUTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyN0b0h0bWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIEhUTUwgaW4gc3RyaW5nIGZvcm1hdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9IdG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSHRtbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wZW5UYWcoKSArIHRoaXMuY29udGVudCgpICsgdGhpcy5jbG9zZVRhZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRE9NIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyN0b0RPTVxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9ET00oKSB7XG4gICAgICB2YXIgZWxlbWVudCwgbmFtZSwgcmVmLCB2YWx1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50ICE9PSBudWxsID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA6IHZvaWQgMCkpIHtcbiAgICAgICAgdGhyb3cgXCJDYW4ndCBjcmVhdGUgRE9NIGlmIGRvY3VtZW50IGlzIG5vdCBwcmVzZW50IVwiO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm5hbWUpO1xuICAgICAgcmVmID0gdGhpcy5hdHRyaWJ1dGVzKCk7XG5cbiAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgdmFsdWUgPSByZWZbbmFtZV07XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibmV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXcobmFtZSwgcHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhuYW1lLCBwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUmVzcG9uc2l2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Jlc3BvbnNpdmUodGFnLCByZXNwb25zaXZlQ2xhc3MpIHtcbiAgICAgIHZhciBkYXRhU3JjO1xuICAgICAgZGF0YVNyYyA9IGxvZGFzaF9nZXREYXRhKHRhZywgJ3NyYy1jYWNoZScpIHx8IGxvZGFzaF9nZXREYXRhKHRhZywgJ3NyYycpO1xuICAgICAgcmV0dXJuIGxvZGFzaF9oYXNDbGFzcyh0YWcsIHJlc3BvbnNpdmVDbGFzcykgJiYgL1xcYndfYXV0b1xcYi8uZXhlYyhkYXRhU3JjKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSHRtbFRhZztcbn0oKTtcblxuO1xuLyoqXG4gKiBSZXByZXNlbnQgdGhlIGdpdmVuIGtleSBhbmQgdmFsdWUgYXMgYW4gSFRNTCBhdHRyaWJ1dGUuXG4gKiBAZnVuY3Rpb24gdG9BdHRyaWJ1dGVcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBhdHRyaWJ1dGUgbmFtZVxuICogQHBhcmFtIHsqfGJvb2xlYW59IHZhbHVlIC0gdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuIElmIHRoZSB2YWx1ZSBpcyBib29sZWFuIGB0cnVlYCwgcmV0dXJuIHRoZSBrZXkgb25seS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBhdHRyaWJ1dGVcbiAqXG4gKi9cblxuZnVuY3Rpb24gaHRtbHRhZ190b0F0dHJpYnV0ZShrZXksIHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa2V5LCBcIj1cXFwiXCIpLmNvbmNhdCh2YWx1ZSwgXCJcXFwiXCIpO1xuICB9XG59XG4vKipcbiAqIElmIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nLCByZXBsYWNlcyBxdW90ZXMgd2l0aCBjaGFyYWN0ZXIgZW50aXRpZXMgKCYjMzQ7LCAmIzM5OylcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGNoYW5nZVxuICogQHJldHVybnMgeyp9IGNoYW5nZWQgdmFsdWVcbiAqL1xuXG5cbmZ1bmN0aW9uIGVzY2FwZVF1b3Rlcyh2YWx1ZSkge1xuICByZXR1cm4gaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodmFsdWUpID8gdmFsdWUucmVwbGFjZSgnXCInLCAnJiMzNDsnKS5yZXBsYWNlKFwiJ1wiLCAnJiMzOTsnKSA6IHZhbHVlO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodG1sdGFnID0gKGh0bWx0YWdfSHRtbFRhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91cmwuanNcbnZhciBfZXhjbHVkZWQgPSBbXCJwbGFjZWhvbGRlclwiLCBcImFjY2Vzc2liaWxpdHlcIl07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cbi8qKlxuICogQWRkcyBwcm90b2NvbCwgaG9zdCwgcGF0aG5hbWUgcHJlZml4ZXMgdG8gZ2l2ZW4gc3RyaW5nXG4gKiBAcGFyYW0gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIG1ha2VVcmwoc3RyKSB7XG4gIHZhciBwcmVmaXggPSBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBkb2N1bWVudC5sb2NhdGlvbi5ob3N0O1xuXG4gIGlmIChzdHJbMF0gPT09ICc/Jykge1xuICAgIHByZWZpeCArPSBkb2N1bWVudC5sb2NhdGlvbi5wYXRobmFtZTtcbiAgfSBlbHNlIGlmIChzdHJbMF0gIT09ICcvJykge1xuICAgIHByZWZpeCArPSBkb2N1bWVudC5sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sICcvJyk7XG4gIH1cblxuICByZXR1cm4gcHJlZml4ICsgc3RyO1xufVxuLyoqXG4gKiBDaGVjayBpcyBnaXZlbiBzdHJpbmcgaXMgYSB1cmxcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNVcmwoc3RyKSB7XG4gIHJldHVybiBzdHIgPyAhIXN0ci5tYXRjaCgvXmh0dHBzPzpcXC8vKSA6IGZhbHNlO1xufSAvLyBQcm9kdWNlIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgNSB0byBiZSB1c2VkIGZvciBjZG4gc3ViIGRvbWFpbnMgZGVzaWduYXRpb25cblxuXG5mdW5jdGlvbiBjZG5TdWJkb21haW5OdW1iZXIocHVibGljSWQpIHtcbiAgcmV0dXJuIHNyY19jcmMzMihwdWJsaWNJZCkgJSA1ICsgMTtcbn1cbi8qKlxuICogUmVtb3ZlcyBzaWduYXR1cmUgZnJvbSBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBzaWduYXR1cmVcbiAqIE1ha2VzIHN1cmUgc2lnbmF0dXJlIGlzIGVtcHR5IG9yIG9mIHRoaXMgZm9ybWF0OiBzLS1zaWduYXR1cmUtLVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBmb3JtYXR0ZWQgc2lnbmF0dXJlXG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVTaWduYXR1cmUob3B0aW9ucykge1xuICB2YXIgc2lnbmF0dXJlID0gb3B0aW9ucy5zaWduYXR1cmU7XG4gIHZhciBpc0Zvcm1hdHRlZCA9ICFzaWduYXR1cmUgfHwgc2lnbmF0dXJlLmluZGV4T2YoJ3MtLScpID09PSAwICYmIHNpZ25hdHVyZS5zdWJzdHIoLTIpID09PSAnLS0nO1xuICBkZWxldGUgb3B0aW9ucy5zaWduYXR1cmU7XG4gIHJldHVybiBpc0Zvcm1hdHRlZCA/IHNpZ25hdHVyZSA6IFwicy0tXCIuY29uY2F0KHNpZ25hdHVyZSwgXCItLVwiKTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBVUkwgcHJlZml4IGZvciBDbG91ZGluYXJ5IHJlc291cmNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCB0aGUgcmVzb3VyY2UgcHVibGljIElEXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBhZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNsb3VkX25hbWUgLSB0aGUgY2xvdWQgbmFtZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2RuX3N1YmRvbWFpbj1mYWxzZV0gLSBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgYnVpbGQgVVJMcyB3aXRoXG4gKiAgbXVsdGlwbGUgQ0ROIHN1Yi1kb21haW5zLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByaXZhdGVfY2RuXSAtIEJvb2xlYW4gKGRlZmF1bHQ6IGZhbHNlKS4gU2hvdWxkIGJlIHNldCB0byB0cnVlIGZvciBBZHZhbmNlZCBwbGFuJ3MgdXNlcnNcbiAqICB0aGF0IGhhdmUgYSBwcml2YXRlIENETiBkaXN0cmlidXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvdG9jb2w9XCJodHRwOi8vXCJdIC0gdGhlIFVSSSBwcm90b2NvbCB0byB1c2UuIElmIG9wdGlvbnMuc2VjdXJlIGlzIHRydWUsXG4gKiAgdGhlIHZhbHVlIGlzIG92ZXJyaWRkZW4gdG8gXCJodHRwczovL1wiXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbl0gLSBUaGUgZG9tYWluIG5hbWUgb2YgdGhlIENETiBkaXN0cmlidXRpb24gdG8gdXNlIGZvciBidWlsZGluZyBIVFRQUyBVUkxzLlxuICogIFJlbGV2YW50IG9ubHkgZm9yIEFkdmFuY2VkIHBsYW4ncyB1c2VycyB0aGF0IGhhdmUgYSBwcml2YXRlIENETiBkaXN0cmlidXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY25hbWVdIC0gQ3VzdG9tIGRvbWFpbiBuYW1lIHRvIHVzZSBmb3IgYnVpbGRpbmcgSFRUUCBVUkxzLlxuICogIFJlbGV2YW50IG9ubHkgZm9yIEFkdmFuY2VkIHBsYW4ncyB1c2VycyB0aGF0IGhhdmUgYSBwcml2YXRlIENETiBkaXN0cmlidXRpb24gYW5kIGEgY3VzdG9tIENOQU1FLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY2RuX3N1YmRvbWFpbj10cnVlXSAtIFdoZW4gb3B0aW9ucy5zZWN1cmUgaXMgdHJ1ZSBhbmQgdGhpcyBwYXJhbWV0ZXIgaXMgZmFsc2UsXG4gKiAgdGhlIHN1YmRvbWFpbiBpcyBzZXQgdG8gXCJyZXNcIi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlPWZhbHNlXSAtIEZvcmNlIEhUVFBTIFVSTHMgb2YgaW1hZ2VzIGV2ZW4gaWYgZW1iZWRkZWQgaW4gbm9uLXNlY3VyZSBIVFRQIHBhZ2VzLlxuICogIFdoZW4gdGhpcyB2YWx1ZSBpcyB0cnVlLCBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gd2lsbCBiZSB1c2VkIGFzIGhvc3QgaWYgcHJvdmlkZWQsIGFuZCBvcHRpb25zLnByb3RvY29sIGlzIHNldFxuICogIHRvIFwiaHR0cHM6Ly9cIi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBVUkwgcHJlZml4IGZvciB0aGUgcmVzb3VyY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlUHJlZml4KHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmNsb3VkX25hbWUgJiYgb3B0aW9ucy5jbG91ZF9uYW1lWzBdID09PSAnLycpIHtcbiAgICByZXR1cm4gJy9yZXMnICsgb3B0aW9ucy5jbG91ZF9uYW1lO1xuICB9IC8vIGRlZmF1bHRzXG5cblxuICB2YXIgcHJvdG9jb2wgPSBcImh0dHA6Ly9cIjtcbiAgdmFyIGNkblBhcnQgPSBcIlwiO1xuICB2YXIgc3ViZG9tYWluID0gXCJyZXNcIjtcbiAgdmFyIGhvc3QgPSBcIi5jbG91ZGluYXJ5LmNvbVwiO1xuICB2YXIgcGF0aCA9IFwiL1wiICsgb3B0aW9ucy5jbG91ZF9uYW1lOyAvLyBtb2RpZmljYXRpb25zXG5cbiAgaWYgKG9wdGlvbnMucHJvdG9jb2wpIHtcbiAgICBwcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2wgKyAnLy8nO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucHJpdmF0ZV9jZG4pIHtcbiAgICBjZG5QYXJ0ID0gb3B0aW9ucy5jbG91ZF9uYW1lICsgXCItXCI7XG4gICAgcGF0aCA9IFwiXCI7XG4gIH1cblxuICBpZiAob3B0aW9ucy5jZG5fc3ViZG9tYWluKSB7XG4gICAgc3ViZG9tYWluID0gXCJyZXMtXCIgKyBjZG5TdWJkb21haW5OdW1iZXIocHVibGljSWQpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuc2VjdXJlKSB7XG4gICAgcHJvdG9jb2wgPSBcImh0dHBzOi8vXCI7XG5cbiAgICBpZiAob3B0aW9ucy5zZWN1cmVfY2RuX3N1YmRvbWFpbiA9PT0gZmFsc2UpIHtcbiAgICAgIHN1YmRvbWFpbiA9IFwicmVzXCI7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbiAhPSBudWxsICYmIG9wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbiAhPT0gT0xEX0FLQU1BSV9TSEFSRURfQ0ROICYmIG9wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbiAhPT0gU0hBUkVEX0NETikge1xuICAgICAgY2RuUGFydCA9IFwiXCI7XG4gICAgICBzdWJkb21haW4gPSBcIlwiO1xuICAgICAgaG9zdCA9IG9wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbjtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5jbmFtZSkge1xuICAgIHByb3RvY29sID0gXCJodHRwOi8vXCI7XG4gICAgY2RuUGFydCA9IFwiXCI7XG4gICAgc3ViZG9tYWluID0gb3B0aW9ucy5jZG5fc3ViZG9tYWluID8gJ2EnICsgKHNyY19jcmMzMihwdWJsaWNJZCkgJSA1ICsgMSkgKyAnLicgOiAnJztcbiAgICBob3N0ID0gb3B0aW9ucy5jbmFtZTtcbiAgfVxuXG4gIHJldHVybiBbcHJvdG9jb2wsIGNkblBhcnQsIHN1YmRvbWFpbiwgaG9zdCwgcGF0aF0uam9pbihcIlwiKTtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvdXJjZSB0eXBlIGFuZCBhY3Rpb24gdHlwZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvblxuICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaGFuZGxlUmVzb3VyY2VUeXBlXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHJlc291cmNlX3R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT0ndXBsb2FkJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdXJsX3N1ZmZpeF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZV9yb290X3BhdGhdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG9ydGVuXVxuICogQHJldHVybnMge3N0cmluZ30gcmVzb3VyY2VfdHlwZS90eXBlXG4gKiBAaWdub3JlXG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVSZXNvdXJjZVR5cGUoX3JlZikge1xuICB2YXIgX3JlZiRyZXNvdXJjZV90eXBlID0gX3JlZi5yZXNvdXJjZV90eXBlLFxuICAgICAgcmVzb3VyY2VfdHlwZSA9IF9yZWYkcmVzb3VyY2VfdHlwZSA9PT0gdm9pZCAwID8gXCJpbWFnZVwiIDogX3JlZiRyZXNvdXJjZV90eXBlLFxuICAgICAgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxuICAgICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gXCJ1cGxvYWRcIiA6IF9yZWYkdHlwZSxcbiAgICAgIHVybF9zdWZmaXggPSBfcmVmLnVybF9zdWZmaXgsXG4gICAgICB1c2Vfcm9vdF9wYXRoID0gX3JlZi51c2Vfcm9vdF9wYXRoLFxuICAgICAgc2hvcnRlbiA9IF9yZWYuc2hvcnRlbjtcbiAgdmFyIG9wdGlvbnMsXG4gICAgICByZXNvdXJjZVR5cGUgPSByZXNvdXJjZV90eXBlO1xuXG4gIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkocmVzb3VyY2VUeXBlKSkge1xuICAgIG9wdGlvbnMgPSByZXNvdXJjZVR5cGU7XG4gICAgcmVzb3VyY2VUeXBlID0gb3B0aW9ucy5yZXNvdXJjZV90eXBlO1xuICAgIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgc2hvcnRlbiA9IG9wdGlvbnMuc2hvcnRlbjtcbiAgfVxuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICB0eXBlID0gJ3VwbG9hZCc7XG4gIH1cblxuICBpZiAodXJsX3N1ZmZpeCAhPSBudWxsKSB7XG4gICAgcmVzb3VyY2VUeXBlID0gU0VPX1RZUEVTW1wiXCIuY29uY2F0KHJlc291cmNlVHlwZSwgXCIvXCIpLmNvbmNhdCh0eXBlKV07XG4gICAgdHlwZSA9IG51bGw7XG5cbiAgICBpZiAocmVzb3VyY2VUeXBlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVSTCBTdWZmaXggb25seSBzdXBwb3J0ZWQgZm9yIFwiLmNvbmNhdChPYmplY3Qua2V5cyhTRU9fVFlQRVMpLmpvaW4oJywgJykpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodXNlX3Jvb3RfcGF0aCkge1xuICAgIGlmIChyZXNvdXJjZVR5cGUgPT09ICdpbWFnZScgJiYgdHlwZSA9PT0gJ3VwbG9hZCcgfHwgcmVzb3VyY2VUeXBlID09PSBcImltYWdlc1wiKSB7XG4gICAgICByZXNvdXJjZVR5cGUgPSBudWxsO1xuICAgICAgdHlwZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgcGF0aCBvbmx5IHN1cHBvcnRlZCBmb3IgaW1hZ2UvdXBsb2FkXCIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaG9ydGVuICYmIHJlc291cmNlVHlwZSA9PT0gJ2ltYWdlJyAmJiB0eXBlID09PSAndXBsb2FkJykge1xuICAgIHJlc291cmNlVHlwZSA9ICdpdSc7XG4gICAgdHlwZSA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gW3Jlc291cmNlVHlwZSwgdHlwZV0uam9pbihcIi9cIik7XG59XG4vKipcbiAqIEVuY29kZSBwdWJsaWNJZFxuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBlbmNvZGVkIHB1YmxpY0lkXG4gKi9cblxuXG5mdW5jdGlvbiBlbmNvZGVQdWJsaWNJZChwdWJsaWNJZCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHB1YmxpY0lkKS5yZXBsYWNlKC8lM0EvZywgJzonKS5yZXBsYWNlKC8lMkYvZywgJy8nKTtcbn1cbi8qKlxuICogRW5jb2RlIGFuZCBmb3JtYXQgcHVibGljSWRcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHB1YmxpY0lkXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRQdWJsaWNJZChwdWJsaWNJZCwgb3B0aW9ucykge1xuICBpZiAoaXNVcmwocHVibGljSWQpKSB7XG4gICAgcHVibGljSWQgPSBlbmNvZGVQdWJsaWNJZChwdWJsaWNJZCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIE1ha2Ugc3VyZSBwdWJsaWNJZCBpcyBVUkkgZW5jb2RlZC5cbiAgICAgIHB1YmxpY0lkID0gZGVjb2RlVVJJQ29tcG9uZW50KHB1YmxpY0lkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge31cblxuICAgIHB1YmxpY0lkID0gZW5jb2RlUHVibGljSWQocHVibGljSWQpO1xuXG4gICAgaWYgKG9wdGlvbnMudXJsX3N1ZmZpeCkge1xuICAgICAgcHVibGljSWQgPSBwdWJsaWNJZCArICcvJyArIG9wdGlvbnMudXJsX3N1ZmZpeDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5mb3JtYXQpIHtcbiAgICAgIGlmICghb3B0aW9ucy50cnVzdF9wdWJsaWNfaWQpIHtcbiAgICAgICAgcHVibGljSWQgPSBwdWJsaWNJZC5yZXBsYWNlKC9cXC4oanBnfHBuZ3xnaWZ8d2VicCkkLywgJycpO1xuICAgICAgfVxuXG4gICAgICBwdWJsaWNJZCA9IHB1YmxpY0lkICsgJy4nICsgb3B0aW9ucy5mb3JtYXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHB1YmxpY0lkO1xufVxuLyoqXG4gKiBHZXQgYW55IGVycm9yIHdpdGggdXJsIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBpZiBlcnJvciwgb3RoZXJ3aXNlIHJldHVybiB1bmRlZmluZWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgdmFyIGNsb3VkX25hbWUgPSBvcHRpb25zLmNsb3VkX25hbWUsXG4gICAgICB1cmxfc3VmZml4ID0gb3B0aW9ucy51cmxfc3VmZml4O1xuXG4gIGlmICghY2xvdWRfbmFtZSkge1xuICAgIHJldHVybiAnVW5rbm93biBjbG91ZF9uYW1lJztcbiAgfVxuXG4gIGlmICh1cmxfc3VmZml4ICYmIHVybF9zdWZmaXgubWF0Y2goL1tcXC5cXC9dLykpIHtcbiAgICByZXR1cm4gJ3VybF9zdWZmaXggc2hvdWxkIG5vdCBpbmNsdWRlIC4gb3IgLyc7XG4gIH1cbn1cbi8qKlxuICogR2V0IHZlcnNpb24gcGFydCBvZiB0aGUgdXJsXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlVmVyc2lvbihwdWJsaWNJZCwgb3B0aW9ucykge1xuICAvLyBmb3JjZV92ZXJzaW9uIHBhcmFtIG1lYW5zIHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyBhIHZlcnNpb24gaW4gdGhlIHVybCAoRGVmYXVsdCBpcyB0cnVlKVxuICB2YXIgaXNGb3JjZVZlcnNpb24gPSBvcHRpb25zLmZvcmNlX3ZlcnNpb24gfHwgdHlwZW9mIG9wdGlvbnMuZm9yY2VfdmVyc2lvbiA9PT0gJ3VuZGVmaW5lZCc7IC8vIElzIHZlcnNpb24gaW5jbHVkZWQgaW4gcHVibGljSWQgb3IgaW4gb3B0aW9ucywgb3IgcHVibGljSWQgaXMgYSB1cmwgKGRvZXNuJ3QgbmVlZCB2ZXJzaW9uKVxuXG4gIHZhciBpc1ZlcnNpb25FeGlzdCA9IHB1YmxpY0lkLmluZGV4T2YoJy8nKSA8IDAgfHwgcHVibGljSWQubWF0Y2goL152WzAtOV0rLykgfHwgaXNVcmwocHVibGljSWQpIHx8IG9wdGlvbnMudmVyc2lvbjtcblxuICBpZiAoaXNGb3JjZVZlcnNpb24gJiYgIWlzVmVyc2lvbkV4aXN0KSB7XG4gICAgb3B0aW9ucy52ZXJzaW9uID0gMTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zLnZlcnNpb24gPyBcInZcIi5jb25jYXQob3B0aW9ucy52ZXJzaW9uKSA6ICcnO1xufVxuLyoqXG4gKiBHZXQgZmluYWwgdHJhbnNmb3JtYXRpb24gY29tcG9uZW50IGZvciB1cmwgc3RyaW5nXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbmRsZVRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIF9yZWYyID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgIHBsYWNlaG9sZGVyID0gX3JlZjIucGxhY2Vob2xkZXIsXG4gICAgICBhY2Nlc3NpYmlsaXR5ID0gX3JlZjIuYWNjZXNzaWJpbGl0eSxcbiAgICAgIG90aGVyT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgX2V4Y2x1ZGVkKTtcblxuICB2YXIgcmVzdWx0ID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihvdGhlck9wdGlvbnMpOyAvLyBBcHBlbmQgYWNjZXNzaWJpbGl0eSB0cmFuc2Zvcm1hdGlvbnNcblxuICBpZiAoYWNjZXNzaWJpbGl0eSAmJiBBQ0NFU1NJQklMSVRZX01PREVTW2FjY2Vzc2liaWxpdHldKSB7XG4gICAgcmVzdWx0LmNoYWluKCkuZWZmZWN0KEFDQ0VTU0lCSUxJVFlfTU9ERVNbYWNjZXNzaWJpbGl0eV0pO1xuICB9IC8vIEFwcGVuZCBwbGFjZWhvbGRlciB0cmFuc2Zvcm1hdGlvbnNcblxuXG4gIGlmIChwbGFjZWhvbGRlcikge1xuICAgIGlmIChwbGFjZWhvbGRlciA9PT0gXCJwcmVkb21pbmFudC1jb2xvclwiICYmIHJlc3VsdC5nZXRWYWx1ZSgnd2lkdGgnKSAmJiByZXN1bHQuZ2V0VmFsdWUoJ2hlaWdodCcpKSB7XG4gICAgICBwbGFjZWhvbGRlciArPSAnLXBpeGVsJztcbiAgICB9XG5cbiAgICB2YXIgcGxhY2Vob2xkZXJUcmFuc2Zvcm1hdGlvbnMgPSBQTEFDRUhPTERFUl9JTUFHRV9NT0RFU1twbGFjZWhvbGRlcl0gfHwgUExBQ0VIT0xERVJfSU1BR0VfTU9ERVMuYmx1cjtcbiAgICBwbGFjZWhvbGRlclRyYW5zZm9ybWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmNoYWluKCkudHJhbnNmb3JtYXRpb24odCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnNlcmlhbGl6ZSgpO1xufVxuLyoqXG4gKiBJZiB0eXBlIGlzICdmZXRjaCcsIHVwZGF0ZSBwdWJsaWNJZCB0byBiZSBhIHVybFxuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIHByZXBhcmVQdWJsaWNJZChwdWJsaWNJZCwgX3JlZjMpIHtcbiAgdmFyIHR5cGUgPSBfcmVmMy50eXBlO1xuICByZXR1cm4gIWlzVXJsKHB1YmxpY0lkKSAmJiB0eXBlID09PSAnZmV0Y2gnID8gbWFrZVVybChwdWJsaWNJZCkgOiBwdWJsaWNJZDtcbn1cbi8qKlxuICogR2VuZXJhdGUgdXJsIHN0cmluZ1xuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gZmluYWwgdXJsXG4gKi9cblxuXG5mdW5jdGlvbiB1cmxTdHJpbmcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgaWYgKGlzVXJsKHB1YmxpY0lkKSAmJiAob3B0aW9ucy50eXBlID09PSAndXBsb2FkJyB8fCBvcHRpb25zLnR5cGUgPT09ICdhc3NldCcpKSB7XG4gICAgcmV0dXJuIHB1YmxpY0lkO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSBoYW5kbGVWZXJzaW9uKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgdmFyIHRyYW5zZm9ybWF0aW9uU3RyaW5nID0gaGFuZGxlVHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gIHZhciBwcmVmaXggPSBoYW5kbGVQcmVmaXgocHVibGljSWQsIG9wdGlvbnMpO1xuICB2YXIgc2lnbmF0dXJlID0gaGFuZGxlU2lnbmF0dXJlKG9wdGlvbnMpO1xuICB2YXIgcmVzb3VyY2VUeXBlID0gaGFuZGxlUmVzb3VyY2VUeXBlKG9wdGlvbnMpO1xuICBwdWJsaWNJZCA9IGZvcm1hdFB1YmxpY0lkKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShbcHJlZml4LCByZXNvdXJjZVR5cGUsIHNpZ25hdHVyZSwgdHJhbnNmb3JtYXRpb25TdHJpbmcsIHZlcnNpb24sIHB1YmxpY0lkXSkuam9pbignLycpLnJlcGxhY2UoLyhbXjpdKVxcLysvZywgJyQxLycpIC8vIHJlcGxhY2UgJy8vLycgd2l0aCAnLy8nXG4gIC5yZXBsYWNlKCcgJywgJyUyMCcpO1xufVxuLyoqXG4gKiBNZXJnZSBvcHRpb25zIGFuZCBjb25maWcgd2l0aCBkZWZhdWx0c1xuICogdXBkYXRlIG9wdGlvbnMgZmV0Y2hfZm9ybWF0IGFjY29yZGluZyB0byAndHlwZScgcGFyYW1cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY29uZmlnXG4gKiBAcmV0dXJucyB7Kn0gdXBkYXRlZCBvcHRpb25zXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBjb25maWcpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBzcmNfdHJhbnNmb3JtYXRpb24pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucy50b09wdGlvbnMoKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgY29uZmlnLCBERUZBVUxUX0lNQUdFX1BBUkFNUyk7XG5cbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2ZldGNoJykge1xuICAgIG9wdGlvbnMuZmV0Y2hfZm9ybWF0ID0gb3B0aW9ucy5mZXRjaF9mb3JtYXQgfHwgb3B0aW9ucy5mb3JtYXQ7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgVVJMIGZvciBhbnkgYXNzZXQgaW4geW91ciBNZWRpYSBsaWJyYXJ5LlxuICogQGZ1bmN0aW9uIHVybFxuICogQGlnbm9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgbWVkaWEgYXNzZXQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBpbmNsdWRlIGluIHRoZSBVUkwuXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbmZpZz17fV0gLSBVUkwgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3R5cGV9IFtvcHRpb25zLnR5cGU9J3VwbG9hZCddIC0gVGhlIGFzc2V0J3Mgc3RvcmFnZSB0eXBlLlxuICogIEZvciBkZXRhaWxzIG9uIGFsbCBmZXRjaCB0eXBlcywgc2VlXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9ucyNmZXRjaGluZ19pbWFnZXNfZnJvbV9yZW1vdGVfbG9jYXRpb25zXCJcbiAqICB0YXJnZXQ9XCJfYmxhbmtcIj5GZXRjaCB0eXBlczwvYT4uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucmVzb3VyY2VfdHlwZT0naW1hZ2UnXSAtIFRoZSB0eXBlIG9mIGFzc2V0LiA8cD5Qb3NzaWJsZSB2YWx1ZXM6PGJyLz5cbiAqICAtIGBpbWFnZWA8YnIvPlxuICogIC0gYHZpZGVvYDxici8+XG4gKiAgLSBgcmF3YFxuICogQHBhcmFtIHtzaWduYXR1cmV9IFtvcHRpb25zLnNpZ25hdHVyZT0ncy0tMTIzNDU2NzgtLSddIC0gVGhlIHNpZ25hdHVyZSBjb21wb25lbnQgb2YgYVxuICogIHNpZ25lZCBkZWxpdmVyeSBVUkwgb2YgdGhlIGZvcm1hdDogL3MtLVNJR05BVFVSRS0tLy5cbiAqICBGb3IgZGV0YWlscyBvbiBzaWduYXR1cmVzLCBzZWVcbiAqIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc2lnbmF0dXJlc1wiIHRhcmdldD1cIl9ibGFua1wiPlNpZ25hdHVyZXM8L2E+LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbWVkaWEgYXNzZXQgVVJMLlxuICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAqL1xuXG5cbmZ1bmN0aW9uIHVybF91cmwocHVibGljSWQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICBpZiAoIXB1YmxpY0lkKSB7XG4gICAgcmV0dXJuIHB1YmxpY0lkO1xuICB9XG5cbiAgb3B0aW9ucyA9IHByZXBhcmVPcHRpb25zKG9wdGlvbnMsIGNvbmZpZyk7XG4gIHB1YmxpY0lkID0gcHJlcGFyZVB1YmxpY0lkKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgdmFyIGVycm9yID0gdmFsaWRhdGUob3B0aW9ucyk7XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICB2YXIgcmVzdWx0VXJsID0gdXJsU3RyaW5nKHB1YmxpY0lkLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucy51cmxBbmFseXRpY3MpIHtcbiAgICB2YXIgYW5hbHl0aWNzT3B0aW9ucyA9IGdldEFuYWx5dGljc09wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIHNka0FuYWx5dGljc1NpZ25hdHVyZSA9IGdldFNES0FuYWx5dGljc1NpZ25hdHVyZShhbmFseXRpY3NPcHRpb25zKTsgLy8gdXJsIG1pZ2h0IGFscmVhZHkgaGF2ZSBhICc/JyBxdWVyeSBwYXJhbVxuXG4gICAgdmFyIGFwcGVuZGVyID0gJz8nO1xuXG4gICAgaWYgKHJlc3VsdFVybC5pbmRleE9mKCc/JykgPj0gMCkge1xuICAgICAgYXBwZW5kZXIgPSAnJic7XG4gICAgfVxuXG4gICAgcmVzdWx0VXJsID0gXCJcIi5jb25jYXQocmVzdWx0VXJsKS5jb25jYXQoYXBwZW5kZXIsIFwiX2E9XCIpLmNvbmNhdChzZGtBbmFseXRpY3NTaWduYXR1cmUpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYXV0aF90b2tlbikge1xuICAgIHZhciBfYXBwZW5kZXIgPSByZXN1bHRVcmwuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPyc7XG5cbiAgICByZXN1bHRVcmwgPSBcIlwiLmNvbmNhdChyZXN1bHRVcmwpLmNvbmNhdChfYXBwZW5kZXIsIFwiX19jbGRfdG9rZW5fXz1cIikuY29uY2F0KG9wdGlvbnMuYXV0aF90b2tlbik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0VXJsO1xufVxuO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9nZW5lcmF0ZUJyZWFrcG9pbnRzLmpzXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5V2l0aEhvbGVzKGFycikgfHwgZ2VuZXJhdGVCcmVha3BvaW50c19pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IGdlbmVyYXRlQnJlYWtwb2ludHNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBnZW5lcmF0ZUJyZWFrcG9pbnRzX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZXRzIG9yIHBvcHVsYXRlcyBzcmNzZXQgYnJlYWtwb2ludHMgdXNpbmcgcHJvdmlkZWQgcGFyYW1ldGVyc1xuICogRWl0aGVyIHRoZSBicmVha3BvaW50cyBvciBtaW5fd2lkdGgsIG1heF93aWR0aCwgbWF4X2ltYWdlcyBtdXN0IGJlIHByb3ZpZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3NyY3NldH0gc3Jjc2V0IE9wdGlvbnMgd2l0aCBlaXRoZXIgYGJyZWFrcG9pbnRzYCBvciBgbWluX3dpZHRoYCwgYG1heF93aWR0aGAsIGFuZCBgbWF4X2ltYWdlc2BcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gQXJyYXkgb2YgYnJlYWtwb2ludHNcbiAqXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHMoc3Jjc2V0KSB7XG4gIHZhciBicmVha3BvaW50cyA9IHNyY3NldC5icmVha3BvaW50cyB8fCBbXTtcblxuICBpZiAoYnJlYWtwb2ludHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJyZWFrcG9pbnRzO1xuICB9XG5cbiAgdmFyIF9tYXAgPSBbc3Jjc2V0Lm1pbl93aWR0aCwgc3Jjc2V0Lm1heF93aWR0aCwgc3Jjc2V0Lm1heF9pbWFnZXNdLm1hcChOdW1iZXIpLFxuICAgICAgX21hcDIgPSBnZW5lcmF0ZUJyZWFrcG9pbnRzX3NsaWNlZFRvQXJyYXkoX21hcCwgMyksXG4gICAgICBtaW5fd2lkdGggPSBfbWFwMlswXSxcbiAgICAgIG1heF93aWR0aCA9IF9tYXAyWzFdLFxuICAgICAgbWF4X2ltYWdlcyA9IF9tYXAyWzJdO1xuXG4gIGlmIChbbWluX3dpZHRoLCBtYXhfd2lkdGgsIG1heF9pbWFnZXNdLnNvbWUoaXNOYU4pKSB7XG4gICAgdGhyb3cgJ0VpdGhlciAobWluX3dpZHRoLCBtYXhfd2lkdGgsIG1heF9pbWFnZXMpICcgKyAnb3IgYnJlYWtwb2ludHMgbXVzdCBiZSBwcm92aWRlZCB0byB0aGUgaW1hZ2Ugc3Jjc2V0IGF0dHJpYnV0ZSc7XG4gIH1cblxuICBpZiAobWluX3dpZHRoID4gbWF4X3dpZHRoKSB7XG4gICAgdGhyb3cgJ21pbl93aWR0aCBtdXN0IGJlIGxlc3MgdGhhbiBtYXhfd2lkdGgnO1xuICB9XG5cbiAgaWYgKG1heF9pbWFnZXMgPD0gMCkge1xuICAgIHRocm93ICdtYXhfaW1hZ2VzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJztcbiAgfSBlbHNlIGlmIChtYXhfaW1hZ2VzID09PSAxKSB7XG4gICAgbWluX3dpZHRoID0gbWF4X3dpZHRoO1xuICB9XG5cbiAgdmFyIHN0ZXBTaXplID0gTWF0aC5jZWlsKChtYXhfd2lkdGggLSBtaW5fd2lkdGgpIC8gTWF0aC5tYXgobWF4X2ltYWdlcyAtIDEsIDEpKTtcblxuICBmb3IgKHZhciBjdXJyZW50ID0gbWluX3dpZHRoOyBjdXJyZW50IDwgbWF4X3dpZHRoOyBjdXJyZW50ICs9IHN0ZXBTaXplKSB7XG4gICAgYnJlYWtwb2ludHMucHVzaChjdXJyZW50KTtcbiAgfVxuXG4gIGJyZWFrcG9pbnRzLnB1c2gobWF4X3dpZHRoKTtcbiAgcmV0dXJuIGJyZWFrcG9pbnRzO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9zcmNzZXRVdGlscy5qc1xuXG52YXIgc3Jjc2V0VXRpbHNfaXNFbXB0eSA9IGlzRW1wdHk7XG5cblxuXG4vKipcbiAqIE9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgc3Jjc2V0IGF0dHJpYnV0ZS5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IHNyY3NldFxuICogQHByb3BlcnR5IHsobnVtYmVyW118c3RyaW5nW10pfSAgIFticmVha3BvaW50c10gQW4gYXJyYXkgb2YgYnJlYWtwb2ludHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gICAgICAgICAgICAgICAgW21pbl93aWR0aF0gICBNaW5pbWFsIHdpZHRoIG9mIHRoZSBzcmNzZXQgaW1hZ2VzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9ICAgICAgICAgICAgICAgIFttYXhfd2lkdGhdICAgTWF4aW1hbCB3aWR0aCBvZiB0aGUgc3Jjc2V0IGltYWdlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgICAgICAgICAgICAgICBbbWF4X2ltYWdlc10gIE51bWJlciBvZiBzcmNzZXQgaW1hZ2VzIHRvIGdlbmVyYXRlLlxuICogQHByb3BlcnR5IHtvYmplY3R8c3RyaW5nfSAgICAgICAgIFt0cmFuc2Zvcm1hdGlvbl0gVGhlIHRyYW5zZm9ybWF0aW9uIHRvIHVzZSBpbiB0aGUgc3Jjc2V0IHVybHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICAgICAgICAgICAgICAgW3NpemVzXSBXaGV0aGVyIHRvIGNhbGN1bGF0ZSBhbmQgYWRkIHRoZSBzaXplcyBhdHRyaWJ1dGUuXG4gKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIEdlbmVyYXRlcyBhIHNpbmdsZSBzcmNzZXQgaXRlbSB1cmxcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY19pZCAgUHVibGljIElEIG9mIHRoZSByZXNvdXJjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgICAgIFdpZHRoIGluIHBpeGVscyBvZiB0aGUgc3Jjc2V0IGl0ZW0uXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IHRyYW5zZm9ybWF0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHRpbmcgVVJMIG9mIHRoZSBpdGVtXG4gKi9cblxuZnVuY3Rpb24gc2NhbGVkVXJsKHB1YmxpY19pZCwgd2lkdGgsIHRyYW5zZm9ybWF0aW9uKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgdmFyIGNvbmZpZ1BhcmFtcyA9IGV4dHJhY3RVcmxQYXJhbXMob3B0aW9ucyk7XG4gIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24gfHwgb3B0aW9ucztcbiAgY29uZmlnUGFyYW1zLnJhd190cmFuc2Zvcm1hdGlvbiA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24oW21lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdC5hKHt9LCB0cmFuc2Zvcm1hdGlvbiksIHtcbiAgICBjcm9wOiAnc2NhbGUnLFxuICAgIHdpZHRoOiB3aWR0aFxuICB9XSkudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHVybF91cmwocHVibGljX2lkLCBjb25maWdQYXJhbXMpO1xufVxuLyoqXG4gKiBJZiBjYWNoZSBpcyBlbmFibGVkLCBnZXQgdGhlIGJyZWFrcG9pbnRzIGZyb20gdGhlIGNhY2hlLiBJZiB0aGUgdmFsdWVzIHdlcmUgbm90IGZvdW5kIGluIHRoZSBjYWNoZSxcbiAqIG9yIGNhY2hlIGlzIG5vdCBlbmFibGVkLCBnZW5lcmF0ZSB0aGUgdmFsdWVzLlxuICogQHBhcmFtIHtzcmNzZXR9IHNyY3NldCBUaGUgc3Jjc2V0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY19pZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyp8QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gZ2V0T3JHZW5lcmF0ZUJyZWFrcG9pbnRzKHB1YmxpY19pZCkge1xuICB2YXIgc3Jjc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50cyhzcmNzZXQpO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIEdlbmVyYXRlcyBzcmNzZXQgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBIVE1MIGltZyB0YWdcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY19pZCAgUHVibGljIElEIG9mIHRoZSByZXNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJbXX0gYnJlYWtwb2ludHMgQW4gYXJyYXkgb2YgYnJlYWtwb2ludHMgKGluIHBpeGVscylcbiAqIEBwYXJhbSB7b2JqZWN0fSB0cmFuc2Zvcm1hdGlvbiBUaGUgdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEluY2x1ZGVzIGh0bWwgdGFnIG9wdGlvbnMsIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0aW5nIHNyY3NldCBhdHRyaWJ1dGUgdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVNyY3NldEF0dHJpYnV0ZShwdWJsaWNfaWQsIGJyZWFrcG9pbnRzLCB0cmFuc2Zvcm1hdGlvbiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQuYShvcHRpb25zKTtcbiAgcGF0Y2hGZXRjaEZvcm1hdChvcHRpb25zKTtcbiAgcmV0dXJuIGJyZWFrcG9pbnRzLm1hcChmdW5jdGlvbiAod2lkdGgpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoc2NhbGVkVXJsKHB1YmxpY19pZCwgd2lkdGgsIHRyYW5zZm9ybWF0aW9uLCBvcHRpb25zKSwgXCIgXCIpLmNvbmNhdCh3aWR0aCwgXCJ3XCIpO1xuICB9KS5qb2luKCcsICcpO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIEdlbmVyYXRlcyBzaXplcyBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIEhUTUwgaW1nIHRhZ1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyW119IGJyZWFrcG9pbnRzIEFuIGFycmF5IG9mIGJyZWFrcG9pbnRzLlxuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHRpbmcgc2l6ZXMgYXR0cmlidXRlIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdGVTaXplc0F0dHJpYnV0ZShicmVha3BvaW50cykge1xuICBpZiAoYnJlYWtwb2ludHMgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBicmVha3BvaW50cy5tYXAoZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgcmV0dXJuIFwiKG1heC13aWR0aDogXCIuY29uY2F0KHdpZHRoLCBcInB4KSBcIikuY29uY2F0KHdpZHRoLCBcInB4XCIpO1xuICB9KS5qb2luKCcsICcpO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIEdlbmVyYXRlcyBzcmNzZXQgYW5kIHNpemVzIGF0dHJpYnV0ZXMgb2YgdGhlIGltYWdlIHRhZ1xuICpcbiAqIEdlbmVyYXRlZCBhdHRyaWJ1dGVzIGFyZSBhZGRlZCB0byBhdHRyaWJ1dGVzIGFyZ3VtZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBwdWJsaWNJZCAgVGhlIHB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICBhdHRyaWJ1dGVzIEV4aXN0aW5nIEhUTUwgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3Jjc2V0fSAgICBzcmNzZXREYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gICAgb3B0aW9ucyAgICBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiBhcnJheSBUaGUgcmVzcG9uc2l2ZSBhdHRyaWJ1dGVzXG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZVJlc3BvbnNpdmVBdHRyaWJ1dGVzKHB1YmxpY0lkKSB7XG4gIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHNyY3NldERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIC8vIENyZWF0ZSBib3RoIHNyY3NldCBhbmQgc2l6ZXMgaGVyZSB0byBhdm9pZCBmZXRjaGluZyBicmVha3BvaW50cyB0d2ljZVxuICB2YXIgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMgPSB7fTtcblxuICBpZiAoc3Jjc2V0VXRpbHNfaXNFbXB0eShzcmNzZXREYXRhKSkge1xuICAgIHJldHVybiByZXNwb25zaXZlQXR0cmlidXRlcztcbiAgfVxuXG4gIHZhciBnZW5lcmF0ZVNpemVzID0gIWF0dHJpYnV0ZXMuc2l6ZXMgJiYgc3Jjc2V0RGF0YS5zaXplcyA9PT0gdHJ1ZTtcbiAgdmFyIGdlbmVyYXRlU3Jjc2V0ID0gIWF0dHJpYnV0ZXMuc3Jjc2V0O1xuXG4gIGlmIChnZW5lcmF0ZVNyY3NldCB8fCBnZW5lcmF0ZVNpemVzKSB7XG4gICAgdmFyIGJyZWFrcG9pbnRzID0gZ2V0T3JHZW5lcmF0ZUJyZWFrcG9pbnRzKHB1YmxpY0lkLCBzcmNzZXREYXRhLCBvcHRpb25zKTtcblxuICAgIGlmIChnZW5lcmF0ZVNyY3NldCkge1xuICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uID0gc3Jjc2V0RGF0YS50cmFuc2Zvcm1hdGlvbjtcbiAgICAgIHZhciBzcmNzZXRBdHRyID0gZ2VuZXJhdGVTcmNzZXRBdHRyaWJ1dGUocHVibGljSWQsIGJyZWFrcG9pbnRzLCB0cmFuc2Zvcm1hdGlvbiwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICghc3Jjc2V0VXRpbHNfaXNFbXB0eShzcmNzZXRBdHRyKSkge1xuICAgICAgICByZXNwb25zaXZlQXR0cmlidXRlcy5zcmNzZXQgPSBzcmNzZXRBdHRyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnZW5lcmF0ZVNpemVzKSB7XG4gICAgICB2YXIgc2l6ZXNBdHRyID0gZ2VuZXJhdGVTaXplc0F0dHJpYnV0ZShicmVha3BvaW50cyk7XG5cbiAgICAgIGlmICghc3Jjc2V0VXRpbHNfaXNFbXB0eShzaXplc0F0dHIpKSB7XG4gICAgICAgIHJlc3BvbnNpdmVBdHRyaWJ1dGVzLnNpemVzID0gc2l6ZXNBdHRyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXNwb25zaXZlQXR0cmlidXRlcztcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBtZWRpYSBxdWVyeVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gb3B0aW9ucy5taW5fd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gb3B0aW9ucy5tYXhfd2lkdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gYSBtZWRpYSBxdWVyeSBzdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiBnZW5lcmF0ZU1lZGlhQXR0cihvcHRpb25zKSB7XG4gIHZhciBtZWRpYVF1ZXJ5ID0gW107XG5cbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zLm1pbl93aWR0aCAhPSBudWxsKSB7XG4gICAgICBtZWRpYVF1ZXJ5LnB1c2goXCIobWluLXdpZHRoOiBcIi5jb25jYXQob3B0aW9ucy5taW5fd2lkdGgsIFwicHgpXCIpKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5tYXhfd2lkdGggIT0gbnVsbCkge1xuICAgICAgbWVkaWFRdWVyeS5wdXNoKFwiKG1heC13aWR0aDogXCIuY29uY2F0KG9wdGlvbnMubWF4X3dpZHRoLCBcInB4KVwiKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lZGlhUXVlcnkuam9pbignIGFuZCAnKTtcbn1cbnZhciBzcmNzZXRVcmwgPSBzY2FsZWRVcmw7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL2ltYWdldGFnLmpzXG5mdW5jdGlvbiBpbWFnZXRhZ190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGltYWdldGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIGltYWdldGFnX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgaW1hZ2V0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGltYWdldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IGltYWdldGFnX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsgfSBlbHNlIHsgaW1hZ2V0YWdfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IGltYWdldGFnX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIGltYWdldGFnX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIGltYWdldGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IGltYWdldGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBpbWFnZXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gaW1hZ2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGltYWdldGFnX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBpbWFnZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChpbWFnZXRhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gaW1hZ2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX2dldFByb3RvdHlwZU9mKG8pIHsgaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIGltYWdldGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogSW1hZ2UgVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAnY2xvdWRpbmFyeSdcbiAqL1xuXG5cblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gSFRNTCAoRE9NKSBJbWFnZSB0YWcgdXNpbmcgQ2xvdWRpbmFyeSBhcyB0aGUgc291cmNlLlxuICogQGNvbnN0cnVjdG9yIEltYWdlVGFnXG4gKiBAZXh0ZW5kcyBIdG1sVGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG5cbnZhciBpbWFnZXRhZ19JbWFnZVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgaW1hZ2V0YWdfaW5oZXJpdHMoSW1hZ2VUYWcsIF9IdG1sVGFnKTtcblxuICB2YXIgX3N1cGVyID0gaW1hZ2V0YWdfY3JlYXRlU3VwZXIoSW1hZ2VUYWcpO1xuXG4gIGZ1bmN0aW9uIEltYWdlVGFnKHB1YmxpY0lkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgaW1hZ2V0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2VUYWcpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiaW1nXCIsIHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgfVxuICAvKiogQG92ZXJyaWRlICovXG5cblxuICBpbWFnZXRhZ19jcmVhdGVDbGFzcyhJbWFnZVRhZywgW3tcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIGF0dHIsIG9wdGlvbnMsIHNyY0F0dHJpYnV0ZTtcbiAgICAgIGF0dHIgPSBpbWFnZXRhZ19nZXQoaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YoSW1hZ2VUYWcucHJvdG90eXBlKSwgXCJhdHRyaWJ1dGVzXCIsIHRoaXMpLmNhbGwodGhpcykgfHwge307XG4gICAgICBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuZ2V0T3B0aW9uKCdhdHRyaWJ1dGVzJykgfHwge307XG4gICAgICB2YXIgc3Jjc2V0UGFyYW0gPSB0aGlzLmdldE9wdGlvbignc3Jjc2V0JykgfHwgYXR0cmlidXRlcy5zcmNzZXQ7XG4gICAgICB2YXIgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMgPSB7fTtcblxuICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHNyY3NldFBhcmFtKSkge1xuICAgICAgICByZXNwb25zaXZlQXR0cmlidXRlcy5zcmNzZXQgPSBzcmNzZXRQYXJhbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbnNpdmVBdHRyaWJ1dGVzID0gZ2VuZXJhdGVJbWFnZVJlc3BvbnNpdmVBdHRyaWJ1dGVzKHRoaXMucHVibGljSWQsIGF0dHJpYnV0ZXMsIHNyY3NldFBhcmFtLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0VtcHR5KHJlc3BvbnNpdmVBdHRyaWJ1dGVzKSkge1xuICAgICAgICBkZWxldGUgYXR0ci53aWR0aDtcbiAgICAgICAgZGVsZXRlIGF0dHIuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQoKShhdHRyLCByZXNwb25zaXZlQXR0cmlidXRlcyk7XG4gICAgICBzcmNBdHRyaWJ1dGUgPSBvcHRpb25zLnJlc3BvbnNpdmUgJiYgIW9wdGlvbnMuY2xpZW50X2hpbnRzID8gJ2RhdGEtc3JjJyA6ICdzcmMnO1xuXG4gICAgICBpZiAoYXR0cltzcmNBdHRyaWJ1dGVdID09IG51bGwpIHtcbiAgICAgICAgYXR0cltzcmNBdHRyaWJ1dGVdID0gdXJsX3VybCh0aGlzLnB1YmxpY0lkLCB0aGlzLmdldE9wdGlvbnMoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZVRhZztcbn0oaHRtbHRhZyk7XG5cbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGltYWdldGFnID0gKGltYWdldGFnX0ltYWdlVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3Mvc291cmNldGFnLmpzXG5mdW5jdGlvbiBzb3VyY2V0YWdfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBzb3VyY2V0YWdfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgc291cmNldGFnX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gc291cmNldGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgc291cmNldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBzb3VyY2V0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gc291cmNldGFnX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IHNvdXJjZXRhZ19nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IHNvdXJjZXRhZ19nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gc291cmNldGFnX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIHNvdXJjZXRhZ19nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IHNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gc291cmNldGFnX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gc291cmNldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gc291cmNldGFnX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBzb3VyY2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHNvdXJjZXRhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gc291cmNldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gc291cmNldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZihvKSB7IHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gc291cmNldGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogSW1hZ2UgVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAnY2xvdWRpbmFyeSdcbiAqL1xuXG5cblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gSFRNTCAoRE9NKSBJbWFnZSB0YWcgdXNpbmcgQ2xvdWRpbmFyeSBhcyB0aGUgc291cmNlLlxuICogQGNvbnN0cnVjdG9yIFNvdXJjZVRhZ1xuICogQGV4dGVuZHMgSHRtbFRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xuXG52YXIgc291cmNldGFnX1NvdXJjZVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgc291cmNldGFnX2luaGVyaXRzKFNvdXJjZVRhZywgX0h0bWxUYWcpO1xuXG4gIHZhciBfc3VwZXIgPSBzb3VyY2V0YWdfY3JlYXRlU3VwZXIoU291cmNlVGFnKTtcblxuICBmdW5jdGlvbiBTb3VyY2VUYWcocHVibGljSWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBzb3VyY2V0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgU291cmNlVGFnKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcInNvdXJjZVwiLCBwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqL1xuXG5cbiAgc291cmNldGFnX2NyZWF0ZUNsYXNzKFNvdXJjZVRhZywgW3tcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIHNyY3NldFBhcmFtID0gdGhpcy5nZXRPcHRpb24oJ3NyY3NldCcpO1xuICAgICAgdmFyIGF0dHIgPSBzb3VyY2V0YWdfZ2V0KHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZihTb3VyY2VUYWcucHJvdG90eXBlKSwgXCJhdHRyaWJ1dGVzXCIsIHRoaXMpLmNhbGwodGhpcykgfHwge307XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoYXR0ciwgZ2VuZXJhdGVJbWFnZVJlc3BvbnNpdmVBdHRyaWJ1dGVzKHRoaXMucHVibGljSWQsIGF0dHIsIHNyY3NldFBhcmFtLCBvcHRpb25zKSk7XG5cbiAgICAgIGlmICghYXR0ci5zcmNzZXQpIHtcbiAgICAgICAgYXR0ci5zcmNzZXQgPSB1cmxfdXJsKHRoaXMucHVibGljSWQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWF0dHIubWVkaWEgJiYgb3B0aW9ucy5tZWRpYSkge1xuICAgICAgICBhdHRyLm1lZGlhID0gZ2VuZXJhdGVNZWRpYUF0dHIob3B0aW9ucy5tZWRpYSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTb3VyY2VUYWc7XG59KGh0bWx0YWcpO1xuXG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzb3VyY2V0YWcgPSAoc291cmNldGFnX1NvdXJjZVRhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL3BpY3R1cmV0YWcuanNcbmZ1bmN0aW9uIHBpY3R1cmV0YWdfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBwaWN0dXJldGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIHBpY3R1cmV0YWdfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBwaWN0dXJldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBwaWN0dXJldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfZ2V0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgcGljdHVyZXRhZ19nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IHBpY3R1cmV0YWdfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IHBpY3R1cmV0YWdfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gcGljdHVyZXRhZ19nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mKG8sIHApIHsgcGljdHVyZXRhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gcGljdHVyZXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBwaWN0dXJldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHBpY3R1cmV0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChwaWN0dXJldGFnX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBwaWN0dXJldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihvKSB7IHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxuXG5cblxudmFyIHBpY3R1cmV0YWdfUGljdHVyZVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgcGljdHVyZXRhZ19pbmhlcml0cyhQaWN0dXJlVGFnLCBfSHRtbFRhZyk7XG5cbiAgdmFyIF9zdXBlciA9IHBpY3R1cmV0YWdfY3JlYXRlU3VwZXIoUGljdHVyZVRhZyk7XG5cbiAgZnVuY3Rpb24gUGljdHVyZVRhZyhwdWJsaWNJZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgc291cmNlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG5cbiAgICBwaWN0dXJldGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBpY3R1cmVUYWcpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAncGljdHVyZScsIHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICBfdGhpcy53aWR0aExpc3QgPSBzb3VyY2VzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKiogQG92ZXJyaWRlICovXG5cblxuICBwaWN0dXJldGFnX2NyZWF0ZUNsYXNzKFBpY3R1cmVUYWcsIFt7XG4gICAga2V5OiBcImNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy53aWR0aExpc3QubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBtaW5fd2lkdGggPSBfcmVmLm1pbl93aWR0aCxcbiAgICAgICAgICAgIG1heF93aWR0aCA9IF9yZWYubWF4X3dpZHRoLFxuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24gPSBfcmVmLnRyYW5zZm9ybWF0aW9uO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0gX3RoaXMyLmdldE9wdGlvbnMoKTtcblxuICAgICAgICB2YXIgc291cmNlVHJhbnNmb3JtYXRpb24gPSBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICAgICAgICBzb3VyY2VUcmFuc2Zvcm1hdGlvbi5jaGFpbigpLmZyb21PcHRpb25zKHR5cGVvZiB0cmFuc2Zvcm1hdGlvbiA9PT0gJ3N0cmluZycgPyB7XG4gICAgICAgICAgcmF3X3RyYW5zZm9ybWF0aW9uOiB0cmFuc2Zvcm1hdGlvblxuICAgICAgICB9IDogdHJhbnNmb3JtYXRpb24pO1xuICAgICAgICBvcHRpb25zID0gZXh0cmFjdFVybFBhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5tZWRpYSA9IHtcbiAgICAgICAgICBtaW5fd2lkdGg6IG1pbl93aWR0aCxcbiAgICAgICAgICBtYXhfd2lkdGg6IG1heF93aWR0aFxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnRyYW5zZm9ybWF0aW9uID0gc291cmNlVHJhbnNmb3JtYXRpb247XG4gICAgICAgIHJldHVybiBuZXcgc291cmNldGFnKF90aGlzMi5wdWJsaWNJZCwgb3B0aW9ucykudG9IdG1sKCk7XG4gICAgICB9KS5qb2luKCcnKSArIG5ldyBpbWFnZXRhZyh0aGlzLnB1YmxpY0lkLCB0aGlzLmdldE9wdGlvbnMoKSkudG9IdG1sKCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBhdHRyID0gcGljdHVyZXRhZ19nZXQocGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihQaWN0dXJlVGFnLnByb3RvdHlwZSksIFwiYXR0cmlidXRlc1wiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBkZWxldGUgYXR0ci53aWR0aDtcbiAgICAgIGRlbGV0ZSBhdHRyLmhlaWdodDtcbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZVRhZygpIHtcbiAgICAgIHJldHVybiBcIjwvXCIgKyB0aGlzLm5hbWUgKyBcIj5cIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGljdHVyZVRhZztcbn0oaHRtbHRhZyk7XG5cbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHBpY3R1cmV0YWcgPSAocGljdHVyZXRhZ19QaWN0dXJlVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvdmlkZW90YWcuanNcbmZ1bmN0aW9uIHZpZGVvdGFnX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gdmlkZW90YWdfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgdmlkZW90YWdfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSB2aWRlb3RhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgdmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfZ2V0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgdmlkZW90YWdfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyB2aWRlb3RhZ19nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gdmlkZW90YWdfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gdmlkZW90YWdfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgdmlkZW90YWdfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX3NldFByb3RvdHlwZU9mKG8sIHApIHsgdmlkZW90YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHZpZGVvdGFnX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSB2aWRlb3RhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gdmlkZW90YWdfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHZpZGVvdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHZpZGVvdGFnX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiB2aWRlb3RhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfZ2V0UHJvdG90eXBlT2YobykgeyB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gdmlkZW90YWdfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLyoqXG4gKiBWaWRlbyBUYWdcbiAqIERlcGVuZHMgb24gJ3RhZ3MvaHRtbHRhZycsICd1dGlsJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG5cblxudmFyIFZJREVPX1RBR19QQVJBTVMgPSBbJ3NvdXJjZV90eXBlcycsICdzb3VyY2VfdHJhbnNmb3JtYXRpb24nLCAnZmFsbGJhY2tfY29udGVudCcsICdwb3N0ZXInLCAnc291cmNlcyddO1xudmFyIHZpZGVvdGFnX0RFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTID0gWyd3ZWJtJywgJ21wNCcsICdvZ3YnXTtcbnZhciB2aWRlb3RhZ19ERUZBVUxUX1BPU1RFUl9PUFRJT05TID0ge1xuICBmb3JtYXQ6ICdqcGcnLFxuICByZXNvdXJjZV90eXBlOiAndmlkZW8nXG59O1xuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUwgKERPTSkgVmlkZW8gdGFnIHVzaW5nIENsb3VkaW5hcnkgYXMgdGhlIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvciBWaWRlb1RhZ1xuICogQGV4dGVuZHMgSHRtbFRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xuXG52YXIgdmlkZW90YWdfVmlkZW9UYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIHZpZGVvdGFnX2luaGVyaXRzKFZpZGVvVGFnLCBfSHRtbFRhZyk7XG5cbiAgdmFyIF9zdXBlciA9IHZpZGVvdGFnX2NyZWF0ZVN1cGVyKFZpZGVvVGFnKTtcblxuICBmdW5jdGlvbiBWaWRlb1RhZyhwdWJsaWNJZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZpZGVvdGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVGFnKTtcblxuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgREVGQVVMVF9WSURFT19QQVJBTVMpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcInZpZGVvXCIsIHB1YmxpY0lkLnJlcGxhY2UoL1xcLihtcDR8b2d2fHdlYm0pJC8sICcnKSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdHJhbnNmb3JtYXRpb24gdG8gYXBwbHkgb24gZWFjaCBzb3VyY2VcbiAgICogQGZ1bmN0aW9uIFZpZGVvVGFnI3NldFNvdXJjZVRyYW5zZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBwYWlycyBvZiBzb3VyY2UgdHlwZSBhbmQgc291cmNlIHRyYW5zZm9ybWF0aW9uXG4gICAqIEByZXR1cm5zIHtWaWRlb1RhZ30gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICovXG5cblxuICB2aWRlb3RhZ19jcmVhdGVDbGFzcyhWaWRlb1RhZywgW3tcbiAgICBrZXk6IFwic2V0U291cmNlVHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U291cmNlVHJhbnNmb3JtYXRpb24odmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5zb3VyY2VUcmFuc2Zvcm1hdGlvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzb3VyY2UgdHlwZXMgdG8gaW5jbHVkZSBpbiB0aGUgdmlkZW8gdGFnXG4gICAgICogQGZ1bmN0aW9uIFZpZGVvVGFnI3NldFNvdXJjZVR5cGVzXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhbiBhcnJheSBvZiBzb3VyY2UgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTb3VyY2VUeXBlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTb3VyY2VUeXBlcyh2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLnNvdXJjZVR5cGVzKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBvc3RlciB0byBiZSB1c2VkIGluIHRoZSB2aWRlbyB0YWdcbiAgICAgKiBAZnVuY3Rpb24gVmlkZW9UYWcjc2V0UG9zdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSB2YWx1ZVxuICAgICAqIC0gc3RyaW5nOiBhIFVSTCB0byB1c2UgZm9yIHRoZSBwb3N0ZXJcbiAgICAgKiAtIE9iamVjdDogdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVycyB0byBhcHBseSB0byB0aGUgcG9zdGVyLiBNYXkgb3B0aW9uYWxseSBpbmNsdWRlIGEgcHVibGljX2lkIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSB2aWRlbyBwdWJsaWNfaWQuXG4gICAgICogQHJldHVybnMge1ZpZGVvVGFnfSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc3Rlcih2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLnBvc3Rlcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb250ZW50IHRvIHVzZSBhcyBmYWxsYmFjayBpbiB0aGUgdmlkZW8gdGFnXG4gICAgICogQGZ1bmN0aW9uIFZpZGVvVGFnI3NldEZhbGxiYWNrQ29udGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBjb250ZW50IHRvIHVzZSwgaW4gSFRNTCBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRGYWxsYmFja0NvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmFsbGJhY2tDb250ZW50KHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZmFsbGJhY2tDb250ZW50KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc291cmNlVHlwZXMgPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZ2V0VmFsdWUoJ3NvdXJjZV90eXBlcycpO1xuICAgICAgdmFyIHNvdXJjZVRyYW5zZm9ybWF0aW9uID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLmdldFZhbHVlKCdzb3VyY2VfdHJhbnNmb3JtYXRpb24nKTtcbiAgICAgIHZhciBmYWxsYmFjayA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5nZXRWYWx1ZSgnZmFsbGJhY2tfY29udGVudCcpO1xuICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLmdldE9wdGlvbignc291cmNlcycpO1xuICAgICAgdmFyIGlubmVyVGFncyA9IFtdO1xuXG4gICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHNvdXJjZXMpICYmICFpc0VtcHR5KHNvdXJjZXMpKSB7XG4gICAgICAgIGlubmVyVGFncyA9IHNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICB2YXIgc3JjID0gdXJsX3VybChfdGhpcy5wdWJsaWNJZCwgZGVmYXVsdHMoe30sIHNvdXJjZS50cmFuc2Zvcm1hdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICBmb3JtYXQ6IHNvdXJjZS50eXBlXG4gICAgICAgICAgfSksIF90aGlzLmdldE9wdGlvbnMoKSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZVNvdXJjZVRhZyhzcmMsIHNvdXJjZS50eXBlLCBzb3VyY2UuY29kZWNzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNFbXB0eShzb3VyY2VUeXBlcykpIHtcbiAgICAgICAgICBzb3VyY2VUeXBlcyA9IHZpZGVvdGFnX0RFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShzb3VyY2VUeXBlcykpIHtcbiAgICAgICAgICBpbm5lclRhZ3MgPSBzb3VyY2VUeXBlcy5tYXAoZnVuY3Rpb24gKHNyY1R5cGUpIHtcbiAgICAgICAgICAgIHZhciBzcmMgPSB1cmxfdXJsKF90aGlzLnB1YmxpY0lkLCBkZWZhdWx0cyh7fSwgc291cmNlVHJhbnNmb3JtYXRpb25bc3JjVHlwZV0gfHwge30sIHtcbiAgICAgICAgICAgICAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgICAgZm9ybWF0OiBzcmNUeXBlXG4gICAgICAgICAgICB9KSwgX3RoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVTb3VyY2VUYWcoc3JjLCBzcmNUeXBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5uZXJUYWdzLmpvaW4oJycpICsgZmFsbGJhY2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBzb3VyY2VUeXBlcyA9IHRoaXMuZ2V0T3B0aW9uKCdzb3VyY2VfdHlwZXMnKTtcbiAgICAgIHZhciBwb3N0ZXIgPSB0aGlzLmdldE9wdGlvbigncG9zdGVyJyk7XG5cbiAgICAgIGlmIChwb3N0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3N0ZXIgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShwb3N0ZXIpKSB7XG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHBvc3Rlci5wdWJsaWNfaWQgIT0gbnVsbCA/IERFRkFVTFRfSU1BR0VfUEFSQU1TIDogdmlkZW90YWdfREVGQVVMVF9QT1NURVJfT1BUSU9OUztcbiAgICAgICAgcG9zdGVyID0gdXJsX3VybChwb3N0ZXIucHVibGljX2lkIHx8IHRoaXMucHVibGljSWQsIGRlZmF1bHRzKHt9LCBwb3N0ZXIsIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0ciA9IHZpZGVvdGFnX2dldCh2aWRlb3RhZ19nZXRQcm90b3R5cGVPZihWaWRlb1RhZy5wcm90b3R5cGUpLCBcImF0dHJpYnV0ZXNcIiwgdGhpcykuY2FsbCh0aGlzKSB8fCB7fTtcbiAgICAgIGF0dHIgPSBvbWl0KGF0dHIsIFZJREVPX1RBR19QQVJBTVMpO1xuICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLmdldE9wdGlvbignc291cmNlcycpOyAvLyBJbiBjYXNlIG9mIGVtcHR5IHNvdXJjZVR5cGVzIC0gZmFsbGJhY2sgdG8gZGVmYXVsdCBzb3VyY2UgdHlwZXMgaXMgdXNlZC5cblxuICAgICAgdmFyIGhhc1NvdXJjZVRhZ3MgPSAhaXNFbXB0eShzb3VyY2VzKSB8fCBpc0VtcHR5KHNvdXJjZVR5cGVzKSB8fCBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoc291cmNlVHlwZXMpO1xuXG4gICAgICBpZiAoIWhhc1NvdXJjZVRhZ3MpIHtcbiAgICAgICAgYXR0cltcInNyY1wiXSA9IHVybF91cmwodGhpcy5wdWJsaWNJZCwgdGhpcy5nZXRPcHRpb25zKCksIHtcbiAgICAgICAgICByZXNvdXJjZV90eXBlOiAndmlkZW8nLFxuICAgICAgICAgIGZvcm1hdDogc291cmNlVHlwZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3N0ZXIgIT0gbnVsbCkge1xuICAgICAgICBhdHRyW1wicG9zdGVyXCJdID0gcG9zdGVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlU291cmNlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVNvdXJjZVRhZyhzcmMsIHNvdXJjZVR5cGUpIHtcbiAgICAgIHZhciBjb2RlY3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgbWltZVR5cGUgPSBudWxsO1xuXG4gICAgICBpZiAoIWlzRW1wdHkoc291cmNlVHlwZSkpIHtcbiAgICAgICAgdmFyIHZpZGVvVHlwZSA9IHNvdXJjZVR5cGUgPT09ICdvZ3YnID8gJ29nZycgOiBzb3VyY2VUeXBlO1xuICAgICAgICBtaW1lVHlwZSA9ICd2aWRlby8nICsgdmlkZW9UeXBlO1xuXG4gICAgICAgIGlmICghaXNFbXB0eShjb2RlY3MpKSB7XG4gICAgICAgICAgdmFyIGNvZGVjc1N0ciA9IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShjb2RlY3MpID8gY29kZWNzLmpvaW4oJywgJykgOiBjb2RlY3M7XG4gICAgICAgICAgbWltZVR5cGUgKz0gJzsgY29kZWNzPScgKyBjb2RlY3NTdHI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiPHNvdXJjZSBcIiArIHRoaXMuaHRtbEF0dHJzKHtcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgICB9KSArIFwiPlwiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaWRlb1RhZztcbn0oaHRtbHRhZyk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHZpZGVvdGFnID0gKHZpZGVvdGFnX1ZpZGVvVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvY2xpZW50aGludHNtZXRhdGFnLmpzXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgY2xpZW50aGludHNtZXRhdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBjbGllbnRoaW50c21ldGF0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIGNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mKG8sIHApIHsgY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBjbGllbnRoaW50c21ldGF0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBjbGllbnRoaW50c21ldGF0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKG8pIHsgY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLyoqXG4gKiBJbWFnZSBUYWdcbiAqIERlcGVuZHMgb24gJ3RhZ3MvaHRtbHRhZycsICdjbG91ZGluYXJ5J1xuICovXG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUwgKERPTSkgTWV0YSB0YWcgdGhhdCBlbmFibGVzIENsaWVudC1IaW50cyBmb3IgdGhlIEhUTUwgcGFnZS4gPGJyLz5cbiAqICBTZWVcbiAqICA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3Jlc3BvbnNpdmVfaW1hZ2VzI2F1dG9tYXRpbmdfcmVzcG9uc2l2ZV9pbWFnZXNfd2l0aF9jbGllbnRfaGludHNcIlxuICogIHRhcmdldD1cIl9uZXdcIj5BdXRvbWF0aW5nIHJlc3BvbnNpdmUgaW1hZ2VzIHdpdGggQ2xpZW50IEhpbnRzPC9hPiBmb3IgbW9yZSBkZXRhaWxzLlxuICogQGNvbnN0cnVjdG9yIENsaWVudEhpbnRzTWV0YVRhZ1xuICogQGV4dGVuZHMgSHRtbFRhZ1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBleGFtcGxlXG4gKiB0YWcgPSBuZXcgQ2xpZW50SGludHNNZXRhVGFnKClcbiAqIC8vcmV0dXJuczogPG1ldGEgaHR0cC1lcXVpdj1cIkFjY2VwdC1DSFwiIGNvbnRlbnQ9XCJEUFIsIFZpZXdwb3J0LVdpZHRoLCBXaWR0aFwiPlxuICovXG5cbnZhciBjbGllbnRoaW50c21ldGF0YWdfQ2xpZW50SGludHNNZXRhVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSHRtbFRhZykge1xuICBjbGllbnRoaW50c21ldGF0YWdfaW5oZXJpdHMoQ2xpZW50SGludHNNZXRhVGFnLCBfSHRtbFRhZyk7XG5cbiAgdmFyIF9zdXBlciA9IGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVTdXBlcihDbGllbnRIaW50c01ldGFUYWcpO1xuXG4gIGZ1bmN0aW9uIENsaWVudEhpbnRzTWV0YVRhZyhvcHRpb25zKSB7XG4gICAgY2xpZW50aGludHNtZXRhdGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaWVudEhpbnRzTWV0YVRhZyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJ21ldGEnLCB2b2lkIDAsIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgXCJodHRwLWVxdWl2XCI6IFwiQWNjZXB0LUNIXCIsXG4gICAgICBjb250ZW50OiBcIkRQUiwgVmlld3BvcnQtV2lkdGgsIFdpZHRoXCJcbiAgICB9LCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqL1xuXG5cbiAgY2xpZW50aGludHNtZXRhdGFnX2NyZWF0ZUNsYXNzKENsaWVudEhpbnRzTWV0YVRhZywgW3tcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2xpZW50SGludHNNZXRhVGFnO1xufShodG1sdGFnKTtcblxuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xpZW50aGludHNtZXRhdGFnID0gKGNsaWVudGhpbnRzbWV0YXRhZ19DbGllbnRIaW50c01ldGFUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9wYXJzZS9ub3JtYWxpemVUb0FycmF5LmpzXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gbm9ybWFsaXplVG9BcnJheV9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IG5vcm1hbGl6ZVRvQXJyYXlfaXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9ybWFsaXplVG9BcnJheV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vcm1hbGl6ZVRvQXJyYXlfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gbm9ybWFsaXplVG9BcnJheV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gbm9ybWFsaXplVG9BcnJheV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gbm9ybWFsaXplVG9BcnJheV9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5cbi8qKlxuICogQGRlc2Mgbm9ybWFsaXplIGVsZW1lbnRzLCBzdXBwb3J0IGEgc2luZ2xlIGVsZW1lbnQsIGFycmF5IG9yIG5vZGVsaXN0LCBhbHdheXMgb3V0cHV0cyBhcnJheVxuICogQHBhcmFtIGVsZW1lbnRzPEhUTUxFbGVtZW50W10+XG4gKiBAcmV0dXJucyB7W119XG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheShlbGVtZW50cykge1xuICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKGVsZW1lbnRzKSkge1xuICAgIHJldHVybiBlbGVtZW50cztcbiAgfSBlbHNlIGlmIChlbGVtZW50cy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk5vZGVMaXN0XCIpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplVG9BcnJheV90b0NvbnN1bWFibGVBcnJheShlbGVtZW50cyk7IC8vIGVuc3VyZSBhbiBhcnJheSBpcyBhbHdheXMgcmV0dXJuZWQsIGV2ZW4gaWYgbm9kZWxpc3RcbiAgfSBlbHNlIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShlbGVtZW50cykpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbGVtZW50cyksIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbZWxlbWVudHNdO1xuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vbW91bnRDbG91ZGluYXJ5VmlkZW9UYWcuanNcbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbEVsQ29udGFpbmVyXG4gKiBAcGFyYW0ge29iamVjdH0gY2xJbnN0YW5jZSBjbG91ZGluYXJ5IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVHJhbnNmb3JtYXRpb25PcHRpb25zXG4gKiBAcmV0dXJucyBQcm9taXNlPEhUTUxFbGVtZW50PlxuICovXG5mdW5jdGlvbiBtb3VudENsb3VkaW5hcnlWaWRlb1RhZyhodG1sRWxDb250YWluZXIsIGNsSW5zdGFuY2UsIHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaHRtbEVsQ29udGFpbmVyLmlubmVySFRNTCA9IGNsSW5zdGFuY2UudmlkZW9UYWcocHVibGljSWQsIG9wdGlvbnMpLnRvSHRtbCgpOyAvLyBBbGwgdmlkZW9zIHVuZGVyIHRoZSBodG1sIGNvbnRhaW5lciBtdXN0IGhhdmUgYSB3aWR0aCBvZiAxMDAlLCBvciB0aGV5IG1pZ2h0IG92ZXJmbG93IGZyb20gdGhlIGNvbnRhaW5lclxuXG4gICAgdmFyIGNsb3VkaW5hcnlWaWRlb0VsZW1lbnQgPSBodG1sRWxDb250YWluZXIucXVlcnlTZWxlY3RvcignLmNsZC10cmFuc3BhcmVudC12aWRlbycpO1xuICAgIGNsb3VkaW5hcnlWaWRlb0VsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgcmVzb2x2ZShodG1sRWxDb250YWluZXIpO1xuICB9KTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19tb3VudENsb3VkaW5hcnlWaWRlb1RhZyA9IChtb3VudENsb3VkaW5hcnlWaWRlb1RhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL3RyYW5zZm9ybWF0aW9ucy9hZGRGbGFnLmpzXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEZ1bmN0aW9uIHdpbGwgcHVzaCBhIGZsYWcgdG8gaW5jb21pbmcgb3B0aW9uc1xuICogQHBhcmFtIHt7dHJhbnNmb3JtYXRpb259IHwgey4uLnRyYW5zZm9ybWF0aW9ufX0gb3B0aW9ucyAtIFRoZXNlIG9wdGlvbnMgYXJlIHRoZSBzYW1lIG9wdGlvbnMgcHJvdmlkZWQgdG8gYWxsIG91ciBTREsgbWV0aG9kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBXZSBleHBlY3Qgb3B0aW9ucyB0byBlaXRoZXIgYmUgdGhlIHRyYW5zZm9ybWF0aW9uIGl0c2VsZiwgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gYXJyYXkgb2YgdHJhbnNmb3JtYXRpb25zXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZsYWdcbiAqIEByZXR1cm5zIHRoZSBtdXRhdGVkIG9wdGlvbnMgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFkZEZsYWdUb09wdGlvbnMob3B0aW9ucywgZmxhZykge1xuICAvLyBEbyB3ZSBoYXZlIHRyYW5zZm9ybWF0aW9uXG4gIGlmIChvcHRpb25zLnRyYW5zZm9ybWF0aW9uKSB7XG4gICAgb3B0aW9ucy50cmFuc2Zvcm1hdGlvbi5wdXNoKHtcbiAgICAgIGZsYWdzOiBbZmxhZ11cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBubyB0cmFuc2Zvcm1hdGlvblxuICAgIC8vIGVuc3VyZSB0aGUgZmxhZ3MgYXJlIGV4dGVuZGVkXG4gICAgaWYgKCFvcHRpb25zLmZsYWdzKSB7XG4gICAgICBvcHRpb25zLmZsYWdzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsYWdzID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucy5mbGFncyA9IFtvcHRpb25zLmZsYWdzXTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmZsYWdzLnB1c2goZmxhZyk7XG4gIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYWRkRmxhZyA9IChhZGRGbGFnVG9PcHRpb25zKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8uanNcblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEVuZm9yY2Ugb3B0aW9uIHN0cnVjdHVyZSwgc2V0cyBkZWZhdWx0cyBhbmQgZW5zdXJlcyBhbHBoYSBmbGFnIGV4aXN0c1xuICogQHBhcmFtIG9wdGlvbnMge1RyYW5zZm9ybWF0aW9uT3B0aW9uc31cbiAqL1xuXG5mdW5jdGlvbiBlbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8ob3B0aW9ucykge1xuICBvcHRpb25zLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgb3B0aW9ucy5tdXRlZCA9IHRydWU7XG4gIG9wdGlvbnMuY29udHJvbHMgPSBmYWxzZTtcbiAgb3B0aW9ucy5tYXhfdGltZW91dF9tcyA9IG9wdGlvbnMubWF4X3RpbWVvdXRfbXMgfHwgREVGQVVMVF9USU1FT1VUX01TO1xuICBvcHRpb25zW1wiY2xhc3NcIl0gPSBvcHRpb25zW1wiY2xhc3NcIl0gfHwgJyc7XG4gIG9wdGlvbnNbXCJjbGFzc1wiXSArPSAnIGNsZC10cmFuc3BhcmVudC12aWRlbyc7XG4gIG9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMgPSBvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzIHx8IHt9O1xuXG4gIGlmICghb3B0aW9ucy5leHRlcm5hbExpYnJhcmllcy5zZWVUaHJ1KSB7XG4gICAgb3B0aW9ucy5leHRlcm5hbExpYnJhcmllcy5zZWVUaHJ1ID0gREVGQVVMVF9FWFRFUk5BTF9MSUJSQVJJRVMuc2VlVGhydTtcbiAgfSAvLyBlbnN1cmUgdGhlcmUncyBhbiBhbHBoYSB0cmFuc2Zvcm1hdGlvbiBwcmVzZW50XG4gIC8vIHRoaXMgaXMgYSBub24gZG9jdW1lbnRlZCBpbnRlcm5hbCBmbGFnXG5cblxuICBhZGRGbGFnKG9wdGlvbnMsICdhbHBoYScpO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX2VuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyA9IChlbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC94aHIvbG9hZFNjcmlwdC5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBHaXZlbiBhIHN0cmluZyBVUkwsIHRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIHRoZSBzY3JpcHQgYW5kIHJlc29sdmUgdGhlIHByb21pc2UuXG4gKiAgICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gZG9lc24ndCByZXNvbHZlIGFueSB2YWx1ZSxcbiAqICAgICAgICAgICAgICAgIHRoaXMgaXMgbm90IGEgVU1EIGxvYWRlciB3aGVyZSB5b3UgY2FuIGdldCB5b3VyIGxpYnJhcnkgbmFtZSBiYWNrLlxuICogQHBhcmFtIHNjcmlwdFVSTCB7c3RyaW5nfVxuICogQHBhcmFtIHtudW1iZXJ9IG1heF90aW1lb3V0X21zIC0gVGltZSB0byBlbGFwc2UgYmVmb3JlIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEBwYXJhbSBpc0FscmVhZHlMb2FkZWQge2Jvb2xlYW59IGlmIHRydWUsIHRoZSBsb2FkU2NyaXB0IHJlc29sdmVzIGltbWVkaWF0ZWx5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGlzIHVzZWQgZm9yIG11bHRpcGxlIGludm9jYXRpb25zIC0gcHJldmVudHMgdGhlIHNjcmlwdCBmcm9tIGJlaW5nIGxvYWRlZCBtdWx0aXBsZSB0aW1lc1xuICogQHJldHVybiB7UHJvbWlzZTxhbnkgfCB7c3RhdHVzOnN0cmluZywgbWVzc2FnZTpzdHJpbmd9Pn1cbiAqL1xuZnVuY3Rpb24gbG9hZFNjcmlwdChzY3JpcHRVUkwsIG1heF90aW1lb3V0X21zLCBpc0FscmVhZHlMb2FkZWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoaXNBbHJlYWR5TG9hZGVkKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzY3JpcHRUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdFRhZy5zcmMgPSBzY3JpcHRVUkw7XG4gICAgICB2YXIgdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWplY3Qoe1xuICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICBtZXNzYWdlOiBcIlRpbWVvdXQgbG9hZGluZyBzY3JpcHQgXCIuY29uY2F0KHNjcmlwdFVSTClcbiAgICAgICAgfSk7XG4gICAgICB9LCBtYXhfdGltZW91dF9tcyk7IC8vIDEwIHNlY29uZHMgZm9yIHRpbWVvdXRcblxuICAgICAgc2NyaXB0VGFnLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTsgLy8gY2xlYXIgdGltZW91dCByZWplY3QgZXJyb3JcblxuICAgICAgICByZWplY3Qoe1xuICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICBtZXNzYWdlOiBcIkVycm9yIGxvYWRpbmcgXCIuY29uY2F0KHNjcmlwdFVSTClcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBzY3JpcHRUYWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7IC8vIGNsZWFyIHRpbWVvdXQgcmVqZWN0IGVycm9yXG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcblxuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRUYWcpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocl9sb2FkU2NyaXB0ID0gKGxvYWRTY3JpcHQpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC94aHIvZ2V0QmxvYkZyb21VUkwuanNcbi8qKlxuICogUmVqZWN0IG9uIHRpbWVvdXRcbiAqIEBwYXJhbSBtYXhUaW1lb3V0TVNcbiAqIEBwYXJhbSByZWplY3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRpbWVySURcbiAqL1xuZnVuY3Rpb24gcmVqZWN0T25UaW1lb3V0KG1heFRpbWVvdXRNUywgcmVqZWN0KSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICByZWplY3Qoe1xuICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgbWVzc2FnZTogJ1RpbWVvdXQgbG9hZGluZyBCbG9iIFVSTCdcbiAgICB9KTtcbiAgfSwgbWF4VGltZW91dE1TKTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIENvbnZlcnRzIGEgVVJMIHRvIGEgQkxPQiBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxUb0xvYWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhfdGltZW91dF9tcyAtIFRpbWUgdG8gZWxhcHNlIGJlZm9yZSBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcmV0dXJuIHtQcm9taXNlPHtcbiAqICAgc3RhdHVzOiAnc3VjY2VzcycgfCAnZXJyb3InXG4gKiAgIG1lc3NhZ2U/OiBzdHJpbmcsXG4gKiAgICBwYXlsb2FkOiB7XG4gKiAgICAgIHVybDogc3RyaW5nXG4gKiAgICB9XG4gKiB9Pn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEJsb2JGcm9tVVJMKHVybFRvTG9hZCwgbWF4VGltZW91dE1TKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHRpbWVySUQgPSByZWplY3RPblRpbWVvdXQobWF4VGltZW91dE1TLCByZWplY3QpOyAvLyBJZiBmZXRjaCBleGlzdHMsIHVzZSBpdCB0byBmZXRjaCBibG9iLCBvdGhlcndpc2UgdXNlIFhIUi5cbiAgICAvLyBYSFIgY2F1c2VzIGlzc3VlcyBvbiBzYWZhcmkgMTQuMSBzbyB3ZSBwcmVmZXIgZmV0Y2hcblxuICAgIHZhciBmZXRjaEJsb2IgPSB0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnICYmIGZldGNoID8gbG9hZFVybFVzaW5nRmV0Y2ggOiBsb2FkVXJsVXNpbmdYaHI7XG4gICAgZmV0Y2hCbG9iKHVybFRvTG9hZCkudGhlbihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgYmxvYlVSTDogVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdCh7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgbWVzc2FnZTogJ0Vycm9yIGxvYWRpbmcgQmxvYiBVUkwnXG4gICAgICB9KTtcbiAgICB9KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXQgdGltZXIgb24gZmFpbCBvciBzdWNjZXNzLlxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuICAgIH0pO1xuICB9KTtcbn1cbi8qKlxuICogVXNlIGZldGNoIGZ1bmN0aW9uIHRvIGZldGNoIGZpbGVcbiAqIEBwYXJhbSB1cmxUb0xvYWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPHVua25vd24+fVxuICovXG5cblxuZnVuY3Rpb24gbG9hZFVybFVzaW5nRmV0Y2godXJsVG9Mb2FkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZmV0Y2godXJsVG9Mb2FkKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgcmVzcG9uc2UuYmxvYigpLnRoZW4oZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgcmVzb2x2ZShibG9iKTtcbiAgICAgIH0pO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KCdlcnJvcicpO1xuICAgIH0pO1xuICB9KTtcbn1cbi8qKlxuICogVXNlIFhIUiB0byBmZXRjaCBmaWxlXG4gKiBAcGFyYW0gdXJsVG9Mb2FkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRVcmxVc2luZ1hocih1cmxUb0xvYWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJlc29sdmUoeGhyLnJlc3BvbnNlKTtcbiAgICB9O1xuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZWplY3QoJ2Vycm9yJyk7XG4gICAgfTtcblxuICAgIHhoci5vcGVuKCdHRVQnLCB1cmxUb0xvYWQsIHRydWUpO1xuICAgIHhoci5zZW5kKCk7XG4gIH0pO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJfZ2V0QmxvYkZyb21VUkwgPSAoZ2V0QmxvYkZyb21VUkwpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL2NyZWF0ZUhpZGRlblZpZGVvVGFnLmpzXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgaGlkZGVuIEhUTUxWaWRlb0VsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHZpZGVvT3B0aW9uc1xuICogQHBhcmFtIHt7YXV0b3BsYXksIHBsYXlzaW5saW5lLCBsb29wLCBtdXRlZCwgcG9zdGVyLCBibG9iVVJMLCB2aWRlb1VSTCB9fSB2aWRlb09wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlkZW9PcHRpb25zLmF1dG9wbGF5IC0gYXV0b3BsYXlzIHRoZSB2aWRlbyBpZiB0cnVlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9PcHRpb25zLmJsb2JVUkwgLSB0aGUgYmxvYlVSTCB0byBzZXQgYXMgdmlkZW8uc3JjXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9PcHRpb25zLnZpZGVvVVJMIC0gdGhlIG9yaWdpbmFsIHZpZGVvVVJMIHRoZSB1c2VyIGNyZWF0ZWQgKHdpdGggdHJhbnNmb3JtYXRpb25zKVxuICogQHJldHVybiB7SFRNTFZpZGVvRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGlkZGVuVmlkZW9UYWcodmlkZW9PcHRpb25zKSB7XG4gIHZhciBhdXRvcGxheSA9IHZpZGVvT3B0aW9ucy5hdXRvcGxheSxcbiAgICAgIHBsYXlzaW5saW5lID0gdmlkZW9PcHRpb25zLnBsYXlzaW5saW5lLFxuICAgICAgbG9vcCA9IHZpZGVvT3B0aW9ucy5sb29wLFxuICAgICAgbXV0ZWQgPSB2aWRlb09wdGlvbnMubXV0ZWQsXG4gICAgICBwb3N0ZXIgPSB2aWRlb09wdGlvbnMucG9zdGVyLFxuICAgICAgYmxvYlVSTCA9IHZpZGVvT3B0aW9ucy5ibG9iVVJMLFxuICAgICAgdmlkZW9VUkwgPSB2aWRlb09wdGlvbnMudmlkZW9VUkw7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgZWwucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBlbC54ID0gMDtcbiAgZWwueSA9IDA7XG4gIGVsLnNyYyA9IGJsb2JVUkw7XG4gIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS12aWRlby11cmwnLCB2aWRlb1VSTCk7IC8vIGZvciBkZWJ1Z2dpbmcvdGVzdGluZ1xuXG4gIGF1dG9wbGF5ICYmIGVsLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCBhdXRvcGxheSk7XG4gIHBsYXlzaW5saW5lICYmIGVsLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCBwbGF5c2lubGluZSk7XG4gIGxvb3AgJiYgZWwuc2V0QXR0cmlidXRlKCdsb29wJywgbG9vcCk7XG4gIG11dGVkICYmIGVsLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCBtdXRlZCk7XG4gIG11dGVkICYmIChlbC5tdXRlZCA9IG11dGVkKTsgLy8gdGhpcyBpcyBhbHNvIG5lZWRlZCBmb3IgYXV0b3BsYXksIG9uIHRvcCBvZiBzZXRBdHRyaWJ1dGVcblxuICBwb3N0ZXIgJiYgZWwuc2V0QXR0cmlidXRlKCdwb3N0ZXInLCBwb3N0ZXIpOyAvLyBGcmVlIG1lbW9yeSBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlIGxvYWRpbmcuXG5cbiAgZWwub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gIH07XG5cbiAgcmV0dXJuIGVsO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX2NyZWF0ZUhpZGRlblZpZGVvVGFnID0gKGNyZWF0ZUhpZGRlblZpZGVvVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9pbnN0YW50aWF0ZVNlZVRocnUuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIG5ldyBpbnN0YW5jIGVvZiBzZWVUaHJ1IChzZWVUaHJ1LmNyZWF0ZSgpKSBhbmQgcmV0dXJucyBhIHByb21pc2Ugb2YgdGhlIHNlZVRocnUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudH0gdmlkZW9FbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4X3RpbWVvdXRfbXMgLSBUaW1lIHRvIGVsYXBzZSBiZWZvcmUgcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IGN1c3RvbUNsYXNzIC0gQSBjbGFzc25hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGNhbnZhcyBlbGVtZW50IGNyZWF0ZWQgYnkgc2VlVGhydVxuICogQHBhcmFtIHtib29sZWFufSBhdXRvUGxheVxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fSBTZWVUaHJ1IGluc3RhbmNlIG9yIHJlamVjdGlvbiBlcnJvclxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVNlZVRocnUodmlkZW9FbGVtZW50LCBtYXhfdGltZW91dF9tcywgY3VzdG9tQ2xhc3MsIGF1dG9QbGF5KSB7XG4gIHZhciBfd2luZG93ID0gd2luZG93LFxuICAgICAgc2VlVGhydSA9IF93aW5kb3cuc2VlVGhydSxcbiAgICAgIHNldFRpbWVvdXQgPSBfd2luZG93LnNldFRpbWVvdXQsXG4gICAgICBjbGVhclRpbWVvdXQgPSBfd2luZG93LmNsZWFyVGltZW91dDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnVGltZW91dCBpbnN0YW50aWF0aW5nIHNlZVRocnUgaW5zdGFuY2UnXG4gICAgICB9KTtcbiAgICB9LCBtYXhfdGltZW91dF9tcyk7XG5cbiAgICBpZiAoc2VlVGhydSkge1xuICAgICAgdmFyIHNlZVRocnVJbnN0YW5jZSA9IHNlZVRocnUuY3JlYXRlKHZpZGVvRWxlbWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjbGVhciB0aW1lb3V0IHJlamVjdCBlcnJvclxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7IC8vIGZvcmNlIGNvbnRhaW5lciB3aWR0aCwgZWxzZSB0aGUgY2FudmFzIGNhbiBvdmVyZmxvdyBvdXRcblxuICAgICAgICB2YXIgY2FudmFzRWxlbWVudCA9IHNlZVRocnVJbnN0YW5jZS5nZXRDYW52YXMoKTtcbiAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgY2FudmFzRWxlbWVudC5jbGFzc05hbWUgKz0gJyAnICsgY3VzdG9tQ2xhc3M7IC8vIHN0YXJ0IHRoZSB2aWRlbyBpZiBhdXRvcGxheSBpcyBzZXRcblxuICAgICAgICBpZiAoYXV0b1BsYXkpIHtcbiAgICAgICAgICBzZWVUaHJ1SW5zdGFuY2UucGxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShzZWVUaHJ1SW5zdGFuY2UpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgbWVzc2FnZTogJ0Vycm9yIGluc3RhbnRpYXRpbmcgc2VlVGhydSBpbnN0YW5jZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9faW5zdGFudGlhdGVTZWVUaHJ1ID0gKGluc3RhbnRpYXRlU2VlVGhydSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vbW91bnRTZWVUaHJ1Q2FudmFzVGFnLmpzXG5cblxuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxFbENvbnRhaW5lclxuICogQHBhcmFtIHtzdHJpbmd9IHZpZGVvVVJMXG4gKiBAcGFyYW0ge1RyYW5zZm9ybWF0aW9uT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG5cbmZ1bmN0aW9uIG1vdW50U2VlVGhydUNhbnZhc1RhZyhodG1sRWxDb250YWluZXIsIHZpZGVvVVJMLCBvcHRpb25zKSB7XG4gIHZhciBwb3N0ZXIgPSBvcHRpb25zLnBvc3RlcixcbiAgICAgIGF1dG9wbGF5ID0gb3B0aW9ucy5hdXRvcGxheSxcbiAgICAgIHBsYXlzaW5saW5lID0gb3B0aW9ucy5wbGF5c2lubGluZSxcbiAgICAgIGxvb3AgPSBvcHRpb25zLmxvb3AsXG4gICAgICBtdXRlZCA9IG9wdGlvbnMubXV0ZWQ7XG4gIHZpZGVvVVJMID0gdmlkZW9VUkwgKyAnLm1wNCc7IC8vIHNlZVRocnUgYWx3YXlzIHVzZXMgbXA0XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB4aHJfbG9hZFNjcmlwdChvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzLnNlZVRocnUsIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMsIHdpbmRvdy5zZWVUaHJ1KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHhocl9nZXRCbG9iRnJvbVVSTCh2aWRlb1VSTCwgb3B0aW9ucy5tYXhfdGltZW91dF9tcykudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IF9yZWYucGF5bG9hZDtcbiAgICAgICAgdmFyIHZpZGVvRWxlbWVudCA9IHRyYW5zcGFyZW50VmlkZW9fY3JlYXRlSGlkZGVuVmlkZW9UYWcoe1xuICAgICAgICAgIGJsb2JVUkw6IHBheWxvYWQuYmxvYlVSTCxcbiAgICAgICAgICB2aWRlb1VSTDogdmlkZW9VUkwsXG4gICAgICAgICAgLy8gZm9yIGRlYnVnZ2luZy90ZXN0aW5nXG4gICAgICAgICAgcG9zdGVyOiBwb3N0ZXIsXG4gICAgICAgICAgYXV0b3BsYXk6IGF1dG9wbGF5LFxuICAgICAgICAgIHBsYXlzaW5saW5lOiBwbGF5c2lubGluZSxcbiAgICAgICAgICBsb29wOiBsb29wLFxuICAgICAgICAgIG11dGVkOiBtdXRlZFxuICAgICAgICB9KTtcbiAgICAgICAgaHRtbEVsQ29udGFpbmVyLmFwcGVuZENoaWxkKHZpZGVvRWxlbWVudCk7XG4gICAgICAgIHRyYW5zcGFyZW50VmlkZW9faW5zdGFudGlhdGVTZWVUaHJ1KHZpZGVvRWxlbWVudCwgb3B0aW9ucy5tYXhfdGltZW91dF9tcywgb3B0aW9uc1tcImNsYXNzXCJdLCBvcHRpb25zLmF1dG9wbGF5KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlKGh0bWxFbENvbnRhaW5lcik7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTsgLy8gY2F0Y2ggZm9yIGdldEJsb2JGcm9tVVJMKClcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBfcmVmMi5zdGF0dXMsXG4gICAgICAgICAgICBtZXNzYWdlID0gX3JlZjIubWVzc2FnZTtcbiAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIGNhdGNoIGZvciBsb2FkU2NyaXB0KClcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgdmFyIHN0YXR1cyA9IF9yZWYzLnN0YXR1cyxcbiAgICAgICAgICBtZXNzYWdlID0gX3JlZjMubWVzc2FnZTtcbiAgICAgIHJlamVjdCh7XG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9fbW91bnRTZWVUaHJ1Q2FudmFzVGFnID0gKG1vdW50U2VlVGhydUNhbnZhc1RhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5LmpzXG4vKipcbiAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59IC0gV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0cmFuc3BhcmVudCB2aWRlb3Mgb3Igbm90XG4gKi9cblxuXG5mdW5jdGlvbiBjaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3koKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gUmVzb2x2ZSBlYXJseSBmb3Igc2FmYXJpLlxuICAgIC8vIEN1cnJlbnRseSAoMjkgRGVjZW1iZXIgMjAyMSkgU2FmYXJpIGNhbiBwbGF5IHdlYm0vdnA5LFxuICAgIC8vIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0IHRyYW5zcGFyZW50IHZpZGVvIGluIHRoZSBmb3JtYXQgd2UncmUgb3V0cHV0dGluZ1xuICAgIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgIHZhciBjYW5QbGF5ID0gdmlkZW8uY2FuUGxheVR5cGUgJiYgdmlkZW8uY2FuUGxheVR5cGUoJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZwOVwiJyk7XG4gICAgcmVzb2x2ZShjYW5QbGF5ID09PSAnbWF5YmUnIHx8IGNhblBsYXkgPT09ICdwcm9iYWJseScpO1xuICB9KTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19jaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kgPSAoY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Nsb3VkaW5hcnkuanNcbmZ1bmN0aW9uIGNsb3VkaW5hcnlfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBjbG91ZGluYXJ5X2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBjbG91ZGluYXJ5X2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgY2xvdWRpbmFyeV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgY2xvdWRpbmFyeV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cbnZhciBhcHBseUJyZWFrcG9pbnRzLCBjbG9zZXN0QWJvdmUsIGRlZmF1bHRCcmVha3BvaW50cywgY2xvdWRpbmFyeV9maW5kQ29udGFpbmVyV2lkdGgsIGNsb3VkaW5hcnlfbWF4V2lkdGgsIHVwZGF0ZURwcjtcblxuXG5cblxuXG5cblxuXG5cbiAvL1xuXG5cblxuXG5cblxuZGVmYXVsdEJyZWFrcG9pbnRzID0gZnVuY3Rpb24gZGVmYXVsdEJyZWFrcG9pbnRzKHdpZHRoKSB7XG4gIHZhciBzdGVwcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwO1xuICByZXR1cm4gc3RlcHMgKiBNYXRoLmNlaWwod2lkdGggLyBzdGVwcyk7XG59O1xuXG5jbG9zZXN0QWJvdmUgPSBmdW5jdGlvbiBjbG9zZXN0QWJvdmUobGlzdCwgdmFsdWUpIHtcbiAgdmFyIGk7XG4gIGkgPSBsaXN0Lmxlbmd0aCAtIDI7XG5cbiAgd2hpbGUgKGkgPj0gMCAmJiBsaXN0W2ldID49IHZhbHVlKSB7XG4gICAgaS0tO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RbaSArIDFdO1xufTtcblxuYXBwbHlCcmVha3BvaW50cyA9IGZ1bmN0aW9uIGFwcGx5QnJlYWtwb2ludHModGFnLCB3aWR0aCwgc3RlcHMsIG9wdGlvbnMpIHtcbiAgdmFyIHJlZiwgcmVmMSwgcmVmMiwgcmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHM7XG4gIHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzID0gKHJlZiA9IChyZWYxID0gKHJlZjIgPSBvcHRpb25zWydyZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyddKSAhPSBudWxsID8gcmVmMiA6IG9wdGlvbnNbJ3Jlc3BvbnNpdmVfdXNlX3N0b3Bwb2ludHMnXSkgIT0gbnVsbCA/IHJlZjEgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMnKSkgIT0gbnVsbCA/IHJlZiA6IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlX3VzZV9zdG9wcG9pbnRzJyk7XG5cbiAgaWYgKCFyZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyB8fCByZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyA9PT0gJ3Jlc2l6ZScgJiYgIW9wdGlvbnMucmVzaXppbmcpIHtcbiAgICByZXR1cm4gd2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsY19icmVha3BvaW50KHRhZywgd2lkdGgsIHN0ZXBzKTtcbiAgfVxufTtcblxuY2xvdWRpbmFyeV9maW5kQ29udGFpbmVyV2lkdGggPSBmdW5jdGlvbiBmaW5kQ29udGFpbmVyV2lkdGgoZWxlbWVudCkge1xuICB2YXIgY29udGFpbmVyV2lkdGgsIHN0eWxlO1xuICBjb250YWluZXJXaWR0aCA9IDA7XG5cbiAgd2hpbGUgKChlbGVtZW50ID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5wYXJlbnROb2RlIDogdm9pZCAwKSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmICghL15pbmxpbmUvLnRlc3Qoc3R5bGUuZGlzcGxheSkpIHtcbiAgICAgIGNvbnRhaW5lcldpZHRoID0gbG9kYXNoX3dpZHRoKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250YWluZXJXaWR0aDtcbn07XG5cbnVwZGF0ZURwciA9IGZ1bmN0aW9uIHVwZGF0ZURwcihkYXRhU3JjLCByb3VuZERwcikge1xuICByZXR1cm4gZGF0YVNyYy5yZXBsYWNlKC9cXGJkcHJfKDFcXC4wfGF1dG8pXFxiL2csICdkcHJfJyArIHRoaXMuZGV2aWNlX3BpeGVsX3JhdGlvKHJvdW5kRHByKSk7XG59O1xuXG5jbG91ZGluYXJ5X21heFdpZHRoID0gZnVuY3Rpb24gbWF4V2lkdGgocmVxdWlyZWRXaWR0aCwgdGFnKSB7XG4gIHZhciBpbWFnZVdpZHRoO1xuICBpbWFnZVdpZHRoID0gbG9kYXNoX2dldERhdGEodGFnLCAnd2lkdGgnKSB8fCAwO1xuXG4gIGlmIChyZXF1aXJlZFdpZHRoID4gaW1hZ2VXaWR0aCkge1xuICAgIGltYWdlV2lkdGggPSByZXF1aXJlZFdpZHRoO1xuICAgIGxvZGFzaF9zZXREYXRhKHRhZywgJ3dpZHRoJywgcmVxdWlyZWRXaWR0aCk7XG4gIH1cblxuICByZXR1cm4gaW1hZ2VXaWR0aDtcbn07XG5cbnZhciBjbG91ZGluYXJ5X0Nsb3VkaW5hcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDbG91ZGluYXJ5IGluc3RhbmNlLlxuICAgKiBAY2xhc3MgQ2xvdWRpbmFyeVxuICAgKiBAY2xhc3NkZXNjIE1haW4gY2xhc3MgZm9yIGFjY2Vzc2luZyBDbG91ZGluYXJ5IGZ1bmN0aW9uYWxpdHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQSB7QGxpbmsgQ29uZmlndXJhdGlvbn0gb2JqZWN0IGZvciBnbG9iYWxseSBjb25maWd1cmluZyBDbG91ZGluYXJ5IGFjY291bnQgc2V0dGluZ3MuXG4gICAqIEBleGFtcGxlPGJyLz5cbiAgICogIHZhciBjbCA9IG5ldyBjbG91ZGluYXJ5LkNsb3VkaW5hcnkoIHsgY2xvdWRfbmFtZTogXCJteWNsb3VkXCJ9KTs8YnIvPlxuICAgKiAgdmFyIGltZ1RhZyA9IGNsLmltYWdlKFwibXlQaWNJRFwiKTtcbiAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgKiAgQXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICovXG4gIGZ1bmN0aW9uIENsb3VkaW5hcnkob3B0aW9ucykge1xuICAgIGNsb3VkaW5hcnlfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xvdWRpbmFyeSk7XG5cbiAgICB2YXIgY29uZmlndXJhdGlvbjtcbiAgICB0aGlzLmRldmljZVBpeGVsUmF0aW9DYWNoZSA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZUNvbmZpZyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZVJlc2l6ZUluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgY29uZmlndXJhdGlvbiA9IG5ldyBzcmNfY29uZmlndXJhdGlvbihvcHRpb25zKTsgLy8gUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblxuICAgIHRoaXMuY29uZmlnID0gZnVuY3Rpb24gKG5ld0NvbmZpZywgbmV3VmFsdWUpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uLmNvbmZpZyhuZXdDb25maWcsIG5ld1ZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZSBcXDxtZXRhXFw+IHRhZ3MgaW4gdGhlIGRvY3VtZW50IHRvIGNvbmZpZ3VyZSB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIFRoaXMge0Nsb3VkaW5hcnl9IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cblxuXG4gICAgdGhpcy5mcm9tRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25maWd1cmF0aW9uLmZyb21Eb2N1bWVudCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIGNvbmZpZ3VyZSB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIFRoaXMge0Nsb3VkaW5hcnl9IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cblxuXG4gICAgdGhpcy5mcm9tRW52aXJvbm1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25maWd1cmF0aW9uLmZyb21FbnZpcm9ubWVudCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiAgVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGludm9rZXMgYm90aCB7QGxpbmsgQ29uZmlndXJhdGlvbiNmcm9tRW52aXJvbm1lbnR8ZnJvbUVudmlyb25tZW50KCl9XG4gICAgICogIChOb2RlLmpzIGVudmlyb25tZW50IG9ubHkpIGFuZCB7QGxpbmsgQ29uZmlndXJhdGlvbiNmcm9tRG9jdW1lbnR8ZnJvbURvY3VtZW50KCl9LlxuICAgICAqICBJdCBmaXJzdCB0cmllcyB0byByZXRyaWV2ZSB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICAgKiAgSWYgbm90IGF2YWlsYWJsZSwgaXQgdHJpZXMgZnJvbSB0aGUgZG9jdW1lbnQgbWV0YSB0YWdzLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2luaXRcbiAgICAgKiBAc2VlIENvbmZpZ3VyYXRpb24jaW5pdFxuICAgICAqIEByZXR1cm4gVGhpcyB7Q2xvdWRpbmFyeX0gaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuXG5cbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25maWd1cmF0aW9uLmluaXQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge0Nsb3VkaW5hcnl9XG4gICAqIEBleGFtcGxlIGNsID0gY2xvdWRpbmFyeS5DbG91ZGluYXJ5Lm5ldyggeyBjbG91ZF9uYW1lOiBcIm15Y2xvdWRcIn0pXG4gICAqL1xuXG5cbiAgY2xvdWRpbmFyeV9jcmVhdGVDbGFzcyhDbG91ZGluYXJ5LCBbe1xuICAgIGtleTogXCJ1cmxcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBVUkwgZm9yIGFueSBhc3NldCBpbiB5b3VyIE1lZGlhIGxpYnJhcnkuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgbWVkaWEgYXNzZXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgVVJMLlxuICAgICAqIEBwYXJhbSB7dHlwZX0gW29wdGlvbnMudHlwZT0ndXBsb2FkJ10gLSBUaGUgYXNzZXQncyBzdG9yYWdlIHR5cGUuXG4gICAgICogIEZvciBkZXRhaWxzIG9uIGFsbCBmZXRjaCB0eXBlcywgc2VlXG4gICAgICogPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbnMjZmV0Y2hpbmdfaW1hZ2VzX2Zyb21fcmVtb3RlX2xvY2F0aW9uc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkZldGNoIHR5cGVzPC9hPi5cbiAgICAgKiBAcGFyYW0ge3Jlc291cmNlVHlwZX0gW29wdGlvbnMucmVzb3VyY2VfdHlwZT0naW1hZ2UnXSAtIFRoZSB0eXBlIG9mIGFzc2V0LiBQb3NzaWJsZSB2YWx1ZXM6PGJyLz5cbiAgICAgKiAgLSBgaW1hZ2VgPGJyLz5cbiAgICAgKiAgLSBgdmlkZW9gPGJyLz5cbiAgICAgKiAgLSBgcmF3YFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG1lZGlhIGFzc2V0IFVSTC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVybChwdWJsaWNJZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHVybF91cmwocHVibGljSWQsIG9wdGlvbnMsIHRoaXMuY29uZmlnKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB2aWRlbyBhc3NldCBVUkwuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdmlkZW9fdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgdmlkZW8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgVVJMLlxuICAgICAqIEBwYXJhbSB7dHlwZX0gW29wdGlvbnMudHlwZT0ndXBsb2FkJ10gLSBUaGUgYXNzZXQncyBzdG9yYWdlIHR5cGUuXG4gICAgICogIEZvciBkZXRhaWxzIG9uIGFsbCBmZXRjaCB0eXBlcywgc2VlXG4gICAgICogIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25zI2ZldGNoaW5nX2ltYWdlc19mcm9tX3JlbW90ZV9sb2NhdGlvbnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5GZXRjaCB0eXBlczwvYT4uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmlkZW8gVVJMLlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9fdXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvX3VybChwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICByZXNvdXJjZV90eXBlOiAndmlkZW8nXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnVybChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYW4gaW1hZ2UgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBhIHRodW1ibmFpbCBmb3IgdGhlIHNwZWNpZmllZCB2aWRlby5cbiAgICAgKiAgSWRlbnRpY2FsIHRvIHtAbGluayBDbG91ZGluYXJ5I3VybHx1cmx9LCBleGNlcHQgdGhhdCB0aGUgYHJlc291cmNlX3R5cGVgIGlzIGB2aWRlb2BcbiAgICAgKiAgYW5kIHRoZSBkZWZhdWx0IGBmb3JtYXRgIGlzIGBqcGdgLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvX3RodW1ibmFpbF91cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSAgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB2aWRlbyBmcm9tIHdoaWNoIHlvdSB3YW50IHRvIGdlbmVyYXRlIGEgdGh1bWJuYWlsIGltYWdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgaW1hZ2Uge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGFwcGx5IHRvIHRoZSB0aHVtYm5haWwuXG4gICAgICogSW4gYWRkaXRpb24gdG8gc3RhbmRhcmQgaW1hZ2UgdHJhbnNmb3JtYXRpb25zLCB5b3UgY2FuIGFsc28gdXNlIHRoZSBgc3RhcnRfb2Zmc2V0YCB0cmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXJcbiAgICAgKiB0byBpbnN0cnVjdCBDbG91ZGluYXJ5IHRvIGdlbmVyYXRlIHRoZSB0aHVtYm5haWwgZnJvbSBhIGZyYW1lIG90aGVyIHRoYW4gdGhlIG1pZGRsZSBmcmFtZSBvZiB0aGUgdmlkZW8uXG4gICAgICogRm9yIGRldGFpbHMsIHNlZVxuICAgICAqIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fbWFuaXB1bGF0aW9uX2FuZF9kZWxpdmVyeSNnZW5lcmF0aW5nX3ZpZGVvX3RodW1ibmFpbHNcIlxuICAgICAqIHRhcmdldD1cIl9ibGFua1wiPkdlbmVyYXRpbmcgdmlkZW8gdGh1bWJuYWlsczwvYT4gaW4gdGhlIENsb3VkaW5hcnkgZG9jdW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3R5cGV9IFtvcHRpb25zLnR5cGU9J3VwbG9hZCddIC0gVGhlIGFzc2V0J3Mgc3RvcmFnZSB0eXBlLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVSTCBvZiB0aGUgdmlkZW8gdGh1bWJuYWlsIGltYWdlLlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvX3RodW1ibmFpbF91cmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9fdGh1bWJuYWlsX3VybChwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe30sIERFRkFVTFRfUE9TVEVSX09QVElPTlMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMudXJsKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzcGVjaWZpZWQgdHJhbnNmb3JtYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN0cmFuc2Zvcm1hdGlvbl9zdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IG9wdGlvbnMuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyYW5zZm9ybWF0aW9uIHN0cmluZy5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtYXRpb25fc3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3N0cmluZyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihvcHRpb25zKS5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGltYWdlIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNpbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIERPTSBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltYWdlKHB1YmxpY0lkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgY2xpZW50X2hpbnRzLCBpbWcsIHJlZjtcbiAgICAgIGltZyA9IHRoaXMuaW1hZ2VUYWcocHVibGljSWQsIG9wdGlvbnMpO1xuICAgICAgY2xpZW50X2hpbnRzID0gKHJlZiA9IG9wdGlvbnMuY2xpZW50X2hpbnRzICE9IG51bGwgPyBvcHRpb25zLmNsaWVudF9oaW50cyA6IHRoaXMuY29uZmlnKCdjbGllbnRfaGludHMnKSkgIT0gbnVsbCA/IHJlZiA6IGZhbHNlO1xuXG4gICAgICBpZiAob3B0aW9ucy5zcmMgPT0gbnVsbCAmJiAhY2xpZW50X2hpbnRzKSB7XG4gICAgICAgIC8vIHNyYyBtdXN0IGJlIHJlbW92ZWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBET00gZWxlbWVudCB0byBhdm9pZCBsb2FkaW5nIHRoZSBpbWFnZVxuICAgICAgICBpbWcuc2V0QXR0cihcInNyY1wiLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGltZyA9IGltZy50b0RPTSgpO1xuXG4gICAgICBpZiAoIWNsaWVudF9oaW50cykge1xuICAgICAgICAvLyBjYWNoZSB0aGUgaW1hZ2Ugc3JjXG4gICAgICAgIGxvZGFzaF9zZXREYXRhKGltZywgJ3NyYy1jYWNoZScsIHRoaXMudXJsKHB1YmxpY0lkLCBvcHRpb25zKSk7IC8vIHNldCBpbWFnZSBzcmMgdGFraW5nIHJlc3BvbnNpdmVuZXNzIGluIGFjY291bnRcblxuICAgICAgICB0aGlzLmNsb3VkaW5hcnlfdXBkYXRlKGltZywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW1hZ2VUYWcgaW5zdGFuY2UgdXNpbmcgdGhlIGNvbmZpZ3VyYXRpb24gZGVmaW5lZCBmb3IgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaW1hZ2VUYWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SW1hZ2VUYWd9IEFuIEltYWdlVGFnIGluc3RhbmNlIHRoYXQgaXMgYXR0YWNoZWQgKGNoYWluZWQpIHRvIHRoaXMgQ2xvdWRpbmFyeSBpbnN0YW5jZS5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbWFnZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbWFnZVRhZyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHRhZztcbiAgICAgIHRhZyA9IG5ldyBpbWFnZXRhZyhwdWJsaWNJZCwgdGhpcy5jb25maWcoKSk7XG4gICAgICB0YWcudHJhbnNmb3JtYXRpb24oKS5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgUGljdHVyZVRhZyBpbnN0YW5jZSwgY29uZmlndXJlZCB1c2luZyB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNQaWN0dXJlVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gdGhlIHB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBuZXcgSW1hZ2VUYWcgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHNvdXJjZXMgLSB0aGUgc291cmNlcyBkZWZpbml0aW9uc1xuICAgICAqIEByZXR1cm4ge1BpY3R1cmVUYWd9IEEgUGljdHVyZVRhZyB0aGF0IGlzIGF0dGFjaGVkIChjaGFpbmVkKSB0byB0aGlzIENsb3VkaW5hcnkgaW5zdGFuY2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBpY3R1cmVUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGljdHVyZVRhZyhwdWJsaWNJZCwgb3B0aW9ucywgc291cmNlcykge1xuICAgICAgdmFyIHRhZztcbiAgICAgIHRhZyA9IG5ldyBwaWN0dXJldGFnKHB1YmxpY0lkLCB0aGlzLmNvbmZpZygpLCBzb3VyY2VzKTtcbiAgICAgIHRhZy50cmFuc2Zvcm1hdGlvbigpLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VUYWcgaW5zdGFuY2UsIGNvbmZpZ3VyZWQgdXNpbmcgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjU291cmNlVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gdGhlIHB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge1NvdXJjZVRhZ30gQSBTb3VyY2VUYWcgdGhhdCBpcyBhdHRhY2hlZCAoY2hhaW5lZCkgdG8gdGhpcyBDbG91ZGluYXJ5IGluc3RhbmNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzb3VyY2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc291cmNlVGFnKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdGFnO1xuICAgICAgdGFnID0gbmV3IHNvdXJjZXRhZyhwdWJsaWNJZCwgdGhpcy5jb25maWcoKSk7XG4gICAgICB0YWcudHJhbnNmb3JtYXRpb24oKS5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHZpZGVvIHRodW1ibmFpbCBVUkwgZnJvbSB0aGUgc3BlY2lmaWVkIHJlbW90ZSB2aWRlbyBhbmQgaW5jbHVkZXMgaXQgaW4gYW4gaW1hZ2UgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvX3RodW1ibmFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdmlkZW8gZnJvbSB0aGUgcmVsZXZhbnQgdmlkZW8gc2l0ZS5cbiAgICAgKiAgQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZSB0byB0aGUgaWRlbnRpZmllciB2YWx1ZSBvciBzZXRcbiAgICAgKiAgdGhlIGltYWdlIGRlbGl2ZXJ5IGZvcm1hdCBpbiB0aGUgJ29wdGlvbnMnIHBhcmFtZXRlciB1c2luZyB0aGUgJ2Zvcm1hdCcgdHJhbnNmb3JtYXRpb24gb3B0aW9uLlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSBZb3VUdWJlIHZpZGVvIG1pZ2h0IGhhdmUgdGhlIGlkZW50aWZpZXI6ICdvLXVybmxhSnBPQS5qcGcnLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGFwcGx5LlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIEhUTUwgaW1hZ2UgdGFnIGVsZW1lbnRcbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb190aHVtYm5haWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9fdGh1bWJuYWlsKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoe30sIERFRkFVTFRfUE9TVEVSX09QVElPTlMsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGZhY2Vib29rIHByb2ZpbGUgaW1hZ2UgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2ZhY2Vib29rX3Byb2ZpbGVfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgRmFjZWJvb2sgbnVtZXJpYyBJRC4gQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZVxuICAgICAqICB0byB0aGUgSUQgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFjZWJvb2tfcHJvZmlsZV9pbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWNlYm9va19wcm9maWxlX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICdmYWNlYm9vaydcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIFR3aXR0ZXIgcHJvZmlsZSBpbWFnZSBieSBJRCBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHdpdHRlcl9wcm9maWxlX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIFR3aXR0ZXIgbnVtZXJpYyBJRC4gQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZVxuICAgICAqICB0byB0aGUgSUQgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHdpdHRlcl9wcm9maWxlX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR3aXR0ZXJfcHJvZmlsZV9pbWFnZShwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAndHdpdHRlcidcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIFR3aXR0ZXIgcHJvZmlsZSBpbWFnZSBieSBuYW1lIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN0d2l0dGVyX25hbWVfcHJvZmlsZV9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBUd2l0dGVyIHNjcmVlbiBuYW1lLiBBZGRpdGlvbmFsbHksIGVpdGhlciBhcHBlbmQgdGhlIGltYWdlIGV4dGVuc2lvbiB0eXBlXG4gICAgICogIHRvIHRoZSBzY3JlZW4gbmFtZSBvciBzZXQgdGhlIGltYWdlIGRlbGl2ZXJ5IGZvcm1hdCBpbiB0aGUgJ29wdGlvbnMnIHBhcmFtZXRlciB1c2luZyB0aGUgJ2Zvcm1hdCcgdHJhbnNmb3JtYXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0d2l0dGVyX25hbWVfcHJvZmlsZV9pbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0d2l0dGVyX25hbWVfcHJvZmlsZV9pbWFnZShwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAndHdpdHRlcl9uYW1lJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgR3JhdmF0YXIgcHJvZmlsZSBpbWFnZSBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjZ3JhdmF0YXJfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgY2FsY3VsYXRlZCBoYXNoIGZvciB0aGUgR3JhdmF0YXIgZW1haWwgYWRkcmVzcy5cbiAgICAgKiAgQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZSB0byB0aGUgc2NyZWVuIG5hbWUgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXRcbiAgICAgKiAgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JhdmF0YXJfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JhdmF0YXJfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ2dyYXZhdGFyJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFuIGltYWdlIGZyb20gYSByZW1vdGUgVVJMIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNmZXRjaF9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBmdWxsIFVSTCBvZiB0aGUgaW1hZ2UgdG8gZmV0Y2gsIGluY2x1ZGluZyB0aGUgZXh0ZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmZXRjaF9pbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmZXRjaF9pbWFnZShwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnZmV0Y2gnXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHZpZGVvIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MVmlkZW9FbGVtZW50fSBBIHZpZGVvIHRhZyBET00gZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlbyhwdWJsaWNJZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMudmlkZW9UYWcocHVibGljSWQsIG9wdGlvbnMpLnRvSHRtbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZpZGVvVGFnIGluc3RhbmNlIHVzaW5nIHRoZSBjb25maWd1cmF0aW9uIGRlZmluZWQgZm9yIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgdmlkZW8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtWaWRlb1RhZ30gQSBWaWRlb1RhZyB0aGF0IGlzIGF0dGFjaGVkIChjaGFpbmVkKSB0byB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb1RhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb1RhZyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLCB0aGlzLmNvbmZpZygpKTtcbiAgICAgIHJldHVybiBuZXcgdmlkZW90YWcocHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBzcHJpdGUgUE5HIGltYWdlIHRoYXQgY29udGFpbnMgYWxsIGltYWdlcyB3aXRoIHRoZSBzcGVjaWZpZWQgdGFnIGFuZCB0aGUgY29ycmVzcG9uZGluZyBjc3MgZmlsZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNzcHJpdGVfY3NzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHRhZyBvbiB3aGljaCB0byBiYXNlIHRoZSBzcHJpdGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgVVJMLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVSTCBvZiB0aGUgZ2VuZXJhdGVkIENTUyBmaWxlLiBUaGUgc3ByaXRlIGltYWdlIGhhcyB0aGUgc2FtZSBVUkwsIGJ1dCB3aXRoIGEgUE5HIGV4dGVuc2lvbi5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc3ByaXRlX2dlbmVyYXRpb25cIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgU3ByaXRlIGdlbmVyYXRpb248L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3ByaXRlX2Nzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcHJpdGVfY3NzKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICdzcHJpdGUnXG4gICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFwdWJsaWNJZC5tYXRjaCgvLmNzcyQvKSkge1xuICAgICAgICBvcHRpb25zLmZvcm1hdCA9ICdjc3MnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyByZXNwb25zaXZlIGltYWdlIGJlaGF2aW9yIGZvciBhbGwgaW1hZ2UgdGFncyB3aXRoIHRoZSAnY2xkLXJlc3BvbnNpdmUnXG4gICAgICogIChvciBvdGhlciBkZWZpbmVkIHtAbGluayBDbG91ZGluYXJ5I3Jlc3BvbnNpdmV8cmVzcG9uc2l2ZX0gY2xhc3MpLjxici8+XG4gICAgICogIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBpbnZva2VkIGFmdGVyIHRoZSBwYWdlIGhhcyBsb2FkZWQuPGJyLz5cbiAgICAgKiAgPGI+Tm90ZTwvYj46IENhbGxzIHtAbGluayBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlfGNsb3VkaW5hcnlfdXBkYXRlfSB0byBtb2RpZnkgaW1hZ2UgdGFncy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNyZXNwb25zaXZlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVzcG9uc2l2ZV9jbGFzcz0nY2xkLXJlc3BvbnNpdmUnXSAtIEFuIGFsdGVybmF0aXZlIGNsYXNzXG4gICAgICogIHRvIGxvY2F0ZSB0aGUgcmVsZXZhbnQgJmx0O2ltZyZndDsgdGFncy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzcG9uc2l2ZV9kZWJvdW5jZT0xMDBdIC0gVGhlIGRlYm91bmNlIGludGVydmFsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib290c3RyYXA9dHJ1ZV0gSWYgdHJ1ZSwgcHJvY2Vzc2VzIHRoZSAmbHQ7aW1nJmd0OyB0YWdzIGJ5IGNhbGxpbmdcbiAgICAgKiAge0BsaW5rIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGV8Y2xvdWRpbmFyeV91cGRhdGV9LiBXaGVuIGZhbHNlLCB0aGUgdGFncyBhcmUgcHJvY2Vzc2VkXG4gICAgICogIG9ubHkgYWZ0ZXIgYSByZXNpemUgZXZlbnQuXG4gICAgICogQHNlZSB7QGxpbmsgQ2xvdWRpbmFyeSNjbG91ZGluYXJ5X3VwZGF0ZXxjbG91ZGluYXJ5X3VwZGF0ZX0gZm9yIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3Jlc3BvbnNpdmVfaW1hZ2VzI2F1dG9tYXRpbmdfcmVzcG9uc2l2ZV9pbWFnZXNfd2l0aF9qYXZhc2NyaXB0XCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXV0b21hdGluZyByZXNwb25zaXZlIGltYWdlcyB3aXRoIEphdmFTY3JpcHQ8L2E+XG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IHRoYXQgd2hlbiBjYWxsZWQsIHJlbW92ZXMgdGhlIHJlc2l6ZSBFdmVudExpc3RlbmVyIGFkZGVkIGJ5IHRoaXMgZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc3BvbnNpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzcG9uc2l2ZShvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYm9vdHN0cmFwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIHJlZiwgcmVmMSwgcmVmMiwgcmVzcG9uc2l2ZUNsYXNzLCByZXNwb25zaXZlUmVzaXplLCB0aW1lb3V0O1xuICAgICAgdGhpcy5yZXNwb25zaXZlQ29uZmlnID0gbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkodGhpcy5yZXNwb25zaXZlQ29uZmlnIHx8IHt9LCBvcHRpb25zKTtcbiAgICAgIHJlc3BvbnNpdmVDbGFzcyA9IChyZWYgPSB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9jbGFzcykgIT0gbnVsbCA/IHJlZiA6IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlX2NsYXNzJyk7XG5cbiAgICAgIGlmIChib290c3RyYXApIHtcbiAgICAgICAgdGhpcy5jbG91ZGluYXJ5X3VwZGF0ZShcImltZy5cIi5jb25jYXQocmVzcG9uc2l2ZUNsYXNzLCBcIiwgaW1nLmNsZC1oaWRwaVwiKSwgdGhpcy5yZXNwb25zaXZlQ29uZmlnKTtcbiAgICAgIH1cblxuICAgICAgcmVzcG9uc2l2ZVJlc2l6ZSA9IChyZWYxID0gKHJlZjIgPSB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9yZXNpemUpICE9IG51bGwgPyByZWYyIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfcmVzaXplJykpICE9IG51bGwgPyByZWYxIDogdHJ1ZTtcblxuICAgICAgaWYgKHJlc3BvbnNpdmVSZXNpemUgJiYgIXRoaXMucmVzcG9uc2l2ZVJlc2l6ZUluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNpemluZyA9IHRoaXMucmVzcG9uc2l2ZVJlc2l6ZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG5cbiAgICAgICAgdmFyIG1ha2VSZXNwb25zaXZlID0gZnVuY3Rpb24gbWFrZVJlc3BvbnNpdmUoKSB7XG4gICAgICAgICAgdmFyIGRlYm91bmNlLCByZWYzLCByZWY0LCByZXNldCwgcnVuLCB3YWl0LCB3YWl0RnVuYztcbiAgICAgICAgICBkZWJvdW5jZSA9IChyZWYzID0gKHJlZjQgPSBfdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfZGVib3VuY2UpICE9IG51bGwgPyByZWY0IDogX3RoaXMuY29uZmlnKCdyZXNwb25zaXZlX2RlYm91bmNlJykpICE9IG51bGwgPyByZWYzIDogMTAwO1xuXG4gICAgICAgICAgcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJ1biA9IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jbG91ZGluYXJ5X3VwZGF0ZShcImltZy5cIi5jb25jYXQocmVzcG9uc2l2ZUNsYXNzKSwgX3RoaXMucmVzcG9uc2l2ZUNvbmZpZyk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHdhaXRGdW5jID0gZnVuY3Rpb24gd2FpdEZ1bmMoKSB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJ1bigpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB3YWl0ID0gZnVuY3Rpb24gd2FpdCgpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWl0RnVuYywgZGVib3VuY2UpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoZGVib3VuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB3YWl0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBydW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG1ha2VSZXNwb25zaXZlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG1ha2VSZXNwb25zaXZlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjY2FsY19icmVha3BvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWxjX2JyZWFrcG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY19icmVha3BvaW50KGVsZW1lbnQsIHdpZHRoLCBzdGVwcykge1xuICAgICAgdmFyIGJyZWFrcG9pbnRzID0gbG9kYXNoX2dldERhdGEoZWxlbWVudCwgJ2JyZWFrcG9pbnRzJykgfHwgbG9kYXNoX2dldERhdGEoZWxlbWVudCwgJ3N0b3Bwb2ludHMnKSB8fCB0aGlzLmNvbmZpZygnYnJlYWtwb2ludHMnKSB8fCB0aGlzLmNvbmZpZygnc3RvcHBvaW50cycpIHx8IGRlZmF1bHRCcmVha3BvaW50cztcblxuICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShicmVha3BvaW50cykpIHtcbiAgICAgICAgcmV0dXJuIGJyZWFrcG9pbnRzKHdpZHRoLCBzdGVwcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoYnJlYWtwb2ludHMpKSB7XG4gICAgICAgICAgYnJlYWtwb2ludHMgPSBicmVha3BvaW50cy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChwb2ludCk7XG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RBYm92ZShicmVha3BvaW50cywgd2lkdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNjYWxjX3N0b3Bwb2ludFxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY2FsY19icmVha3BvaW50fSBpbnN0ZWFkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY19zdG9wcG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY19zdG9wcG9pbnQoZWxlbWVudCwgd2lkdGgsIHN0ZXBzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxjX2JyZWFrcG9pbnQoZWxlbWVudCwgd2lkdGgsIHN0ZXBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjZGV2aWNlX3BpeGVsX3JhdGlvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRldmljZV9waXhlbF9yYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXZpY2VfcGl4ZWxfcmF0aW8ocm91bmREcHIpIHtcbiAgICAgIHJvdW5kRHByID0gcm91bmREcHIgPT0gbnVsbCA/IHRydWUgOiByb3VuZERwcjtcbiAgICAgIHZhciBkcHIgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IHZvaWQgMCkgfHwgMTtcblxuICAgICAgaWYgKHJvdW5kRHByKSB7XG4gICAgICAgIGRwciA9IE1hdGguY2VpbChkcHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZHByIDw9IDAgfHwgZHByID09PSAwIC8gMCkge1xuICAgICAgICBkcHIgPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHByU3RyaW5nID0gZHByLnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmIChkcHJTdHJpbmcubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgIGRwclN0cmluZyArPSAnLjAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZHByU3RyaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFwcGxpZXMgcmVzcG9uc2l2ZW5lc3MgdG8gYWxsIDxjb2RlPiZsdDtpbWcmZ3Q7PC9jb2RlPiB0YWdzIHVuZGVyIGVhY2ggcmVsZXZhbnQgbm9kZVxuICAgICogIChyZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHRhZyBjb250YWlucyB0aGUge0BsaW5rIENsb3VkaW5hcnkjcmVzcG9uc2l2ZXxyZXNwb25zaXZlfSBjbGFzcykuXG4gICAgKiBAcGFyYW0ge0VsZW1lbnRbXX0gbm9kZXMgVGhlIHBhcmVudCBub2RlcyB3aGVyZSB5b3Ugd2FudCB0byBzZWFyY2ggZm9yICZsdDtpbWcmZ3Q7IHRhZ3MuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSB7QGxpbmsgQ2xvdWRpbmFyeSNjbG91ZGluYXJ5X3VwZGF0ZXxjbG91ZGluYXJ5X3VwZGF0ZX0gb3B0aW9ucyB0byBhcHBseS5cbiAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIlxuICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNwcm9jZXNzSW1hZ2VUYWdzXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NJbWFnZVRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0ltYWdlVGFncyhub2Rlcywgb3B0aW9ucykge1xuICAgICAgaWYgKGlzRW1wdHkobm9kZXMpKSB7XG4gICAgICAgIC8vIHNpbWlsYXIgdG8gYCQuZm4uY2xvdWRpbmFyeWBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucyB8fCB7fSwgdGhpcy5jb25maWcoKSk7XG4gICAgICB2YXIgaW1hZ2VzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiAvXmltZyQvaS50ZXN0KG5vZGUudGFnTmFtZSk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGltZ09wdGlvbnMgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgICB3aWR0aDogbm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgICAgaGVpZ2h0OiBub2RlLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksXG4gICAgICAgICAgc3JjOiBub2RlLmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBwdWJsaWNJZCA9IGltZ09wdGlvbnNbJ3NvdXJjZSddIHx8IGltZ09wdGlvbnNbJ3NyYyddO1xuICAgICAgICBkZWxldGUgaW1nT3B0aW9uc1snc291cmNlJ107XG4gICAgICAgIGRlbGV0ZSBpbWdPcHRpb25zWydzcmMnXTtcbiAgICAgICAgdmFyIGF0dHIgPSBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKGltZ09wdGlvbnMpLnRvSHRtbEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgbG9kYXNoX3NldERhdGEobm9kZSwgJ3NyYy1jYWNoZScsIHVybF91cmwocHVibGljSWQsIGltZ09wdGlvbnMpKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgYXR0ci53aWR0aCk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBhdHRyLmhlaWdodCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNsb3VkaW5hcnlfdXBkYXRlKGltYWdlcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBVcGRhdGVzIHRoZSBkcHIgKGZvciBgZHByX2F1dG9gKSBhbmQgcmVzcG9uc2l2ZSAoZm9yIGB3X2F1dG9gKSBmaWVsZHMgYWNjb3JkaW5nIHRvXG4gICAgKiAgdGhlIGN1cnJlbnQgY29udGFpbmVyIHNpemUgYW5kIHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8uPGJyLz5cbiAgICAqICA8Yj5Ob3RlPC9iPjpgd19hdXRvYCBpcyB1cGRhdGVkIG9ubHkgZm9yIGltYWdlcyBtYXJrZWQgd2l0aCB0aGUgYGNsZC1yZXNwb25zaXZlYFxuICAgICogIChvciBvdGhlciBkZWZpbmVkIHtAbGluayBDbG91ZGluYXJ5I3Jlc3BvbnNpdmV8cmVzcG9uc2l2ZX0pIGNsYXNzLlxuICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGVcbiAgICAqIEBwYXJhbSB7KEFycmF5fHN0cmluZ3xOb2RlTGlzdCl9IGVsZW1lbnRzIC0gVGhlIEhUTUwgaW1hZ2UgZWxlbWVudHMgdG8gbW9kaWZ5LlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IFtvcHRpb25zLnJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzPXRydWVdXG4gICAgKiBQb3NzaWJsZSB2YWx1ZXM6PGJyLz5cbiAgICAqICAtIGB0cnVlYDogQWx3YXlzIHVzZSBicmVha3BvaW50cyBmb3Igd2lkdGguPGJyLz5cbiAgICAqICAtIGByZXNpemVgOiBVc2UgZXhhY3Qgd2lkdGggb24gZmlyc3QgcmVuZGVyIGFuZCBicmVha3BvaW50cyBvbiByZXNpemUuPGJyLz5cbiAgICAqICAtIGBmYWxzZWA6IEFsd2F5cyB1c2UgZXhhY3Qgd2lkdGguXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc3BvbnNpdmVdIC0gSWYgYHRydWVgLCBlbmFibGUgcmVzcG9uc2l2ZSBvbiBhbGwgc3BlY2lmaWVkIGVsZW1lbnRzLlxuICAgICogIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gZGVmaW5lIHNwZWNpZmljIEhUTUwgZWxlbWVudHMgdG8gbW9kaWZ5IGJ5IGFkZGluZyB0aGUgYGNsZC1yZXNwb25zaXZlYFxuICAgICogIChvciBvdGhlciBjdXN0b20tZGVmaW5lZCB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmVfY2xhc3N9KSBjbGFzcyB0byB0aG9zZSBlbGVtZW50cy5cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzcG9uc2l2ZV9wcmVzZXJ2ZV9oZWlnaHRdIC0gSWYgYHRydWVgLCBvcmlnaW5hbCBjc3MgaGVpZ2h0IGlzIHByZXNlcnZlZC5cbiAgICAqICBTaG91bGQgYmUgdXNlZCBvbmx5IGlmIHRoZSB0cmFuc2Zvcm1hdGlvbiBzdXBwb3J0cyBkaWZmZXJlbnQgYXNwZWN0IHJhdGlvcy5cbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvdWRpbmFyeV91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvdWRpbmFyeV91cGRhdGUoZWxlbWVudHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgY29udGFpbmVyV2lkdGgsIGRhdGFTcmMsIG1hdGNoLCByZWY0LCByZXF1aXJlZFdpZHRoO1xuXG4gICAgICBpZiAoZWxlbWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzcG9uc2l2ZSA9IG9wdGlvbnMucmVzcG9uc2l2ZSAhPSBudWxsID8gb3B0aW9ucy5yZXNwb25zaXZlIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmUnKTtcbiAgICAgIGVsZW1lbnRzID0gbm9ybWFsaXplVG9BcnJheShlbGVtZW50cyk7XG4gICAgICB2YXIgcmVzcG9uc2l2ZUNsYXNzO1xuXG4gICAgICBpZiAodGhpcy5yZXNwb25zaXZlQ29uZmlnICYmIHRoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX2NsYXNzICE9IG51bGwpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUNsYXNzID0gdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfY2xhc3M7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZV9jbGFzcyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNpdmVDbGFzcyA9IG9wdGlvbnMucmVzcG9uc2l2ZV9jbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbnNpdmVDbGFzcyA9IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlX2NsYXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByb3VuZERwciA9IG9wdGlvbnMucm91bmRfZHByICE9IG51bGwgPyBvcHRpb25zLnJvdW5kX2RwciA6IHRoaXMuY29uZmlnKCdyb3VuZF9kcHInKTtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgICAgICBpZiAoL2ltZy9pLnRlc3QodGFnLnRhZ05hbWUpKSB7XG4gICAgICAgICAgdmFyIHNldFVybCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAocmVzcG9uc2l2ZSkge1xuICAgICAgICAgICAgbG9kYXNoX2FkZENsYXNzKHRhZywgcmVzcG9uc2l2ZUNsYXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhU3JjID0gbG9kYXNoX2dldERhdGEodGFnLCAnc3JjLWNhY2hlJykgfHwgbG9kYXNoX2dldERhdGEodGFnLCAnc3JjJyk7XG5cbiAgICAgICAgICBpZiAoIWlzRW1wdHkoZGF0YVNyYykpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBkcHIgYWNjb3JkaW5nIHRvIHRoZSBkZXZpY2UncyBkZXZpY2VQaXhlbFJhdGlvXG4gICAgICAgICAgICBkYXRhU3JjID0gdXBkYXRlRHByLmNhbGwoX3RoaXMyLCBkYXRhU3JjLCByb3VuZERwcik7XG5cbiAgICAgICAgICAgIGlmIChodG1sdGFnLmlzUmVzcG9uc2l2ZSh0YWcsIHJlc3BvbnNpdmVDbGFzcykpIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyV2lkdGggPSBjbG91ZGluYXJ5X2ZpbmRDb250YWluZXJXaWR0aCh0YWcpO1xuXG4gICAgICAgICAgICAgIGlmIChjb250YWluZXJXaWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgvd19hdXRvOmJyZWFrcG9pbnRzLy50ZXN0KGRhdGFTcmMpKSB7XG4gICAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gY2xvdWRpbmFyeV9tYXhXaWR0aChjb250YWluZXJXaWR0aCwgdGFnKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNyYyA9IGRhdGFTcmMucmVwbGFjZSgvd19hdXRvOmJyZWFrcG9pbnRzKFtfMC05XSopKDpbMC05XSspPy8sIFwid19hdXRvOmJyZWFrcG9pbnRzJDE6XCIuY29uY2F0KHJlcXVpcmVkV2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFVybCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaCA9IC93X2F1dG8oOihcXGQrKSk/Ly5leGVjKGRhdGFTcmMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRXaWR0aCA9IGFwcGx5QnJlYWtwb2ludHMuY2FsbChfdGhpczIsIHRhZywgY29udGFpbmVyV2lkdGgsIG1hdGNoWzJdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRXaWR0aCA9IGNsb3VkaW5hcnlfbWF4V2lkdGgocmVxdWlyZWRXaWR0aCwgdGFnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGFTcmMgPSBkYXRhU3JjLnJlcGxhY2UoL3dfYXV0b1teLFxcL10qL2csIFwid19cIi5jb25jYXQocmVxdWlyZWRXaWR0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHNldFVybCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbG9kYXNoX3JlbW92ZUF0dHJpYnV0ZSh0YWcsICd3aWR0aCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnJlc3BvbnNpdmVfcHJlc2VydmVfaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICBsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlKHRhZywgJ2hlaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb250YWluZXIgZG9lc24ndCBrbm93IHRoZSBzaXplIHlldCAtIHVzdWFsbHkgYmVjYXVzZSB0aGUgaW1hZ2UgaXMgaGlkZGVuIG9yIG91dHNpZGUgdGhlIERPTS5cbiAgICAgICAgICAgICAgICBzZXRVcmwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNMYXp5TG9hZGluZyA9IG9wdGlvbnMubG9hZGluZyA9PT0gJ2xhenknICYmICFfdGhpczIuaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpICYmIF90aGlzMi5pc0xhenlMb2FkU3VwcG9ydGVkKCkgJiYgIWVsZW1lbnRzWzBdLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG5cbiAgICAgICAgICAgIGlmIChzZXRVcmwgfHwgaXNMYXp5TG9hZGluZykge1xuICAgICAgICAgICAgICAvLyBJZiBkYXRhLXdpZHRoIGV4aXN0cywgc2V0IHdpZHRoIHRvIGJlIGRhdGEtd2lkdGhcbiAgICAgICAgICAgICAgX3RoaXMyLnNldEF0dHJpYnV0ZUlmRXhpc3RzKGVsZW1lbnRzWzBdLCAnd2lkdGgnLCAnZGF0YS13aWR0aCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0VXJsICYmICFpc0xhenlMb2FkaW5nKSB7XG4gICAgICAgICAgICAgIGxvZGFzaF9zZXRBdHRyaWJ1dGUodGFnLCAnc3JjJywgZGF0YVNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGVsZW1lbnRbdG9BdHRyaWJ1dGVdID0gZWxlbWVudFtmcm9tQXR0cmlidXRlXSBpZiBlbGVtZW50W2Zyb21BdHRyaWJ1dGVdIGlzIHNldFxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHBhcmFtIHRvQXR0cmlidXRlXG4gICAgICogQHBhcmFtIGZyb21BdHRyaWJ1dGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEF0dHJpYnV0ZUlmRXhpc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZUlmRXhpc3RzKGVsZW1lbnQsIHRvQXR0cmlidXRlLCBmcm9tQXR0cmlidXRlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShmcm9tQXR0cmlidXRlKTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbG9kYXNoX3NldEF0dHJpYnV0ZShlbGVtZW50LCB0b0F0dHJpYnV0ZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgSW50ZXJzZWN0aW9uIE9ic2VydmVyIEFQSSBpcyBzdXBwb3J0ZWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzTGF6eUxvYWRTdXBwb3J0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNMYXp5TG9hZFN1cHBvcnRlZCgpIHtcbiAgICAgIHJldHVybiB3aW5kb3cgJiYgJ0ludGVyc2VjdGlvbk9ic2VydmVyJyBpbiB3aW5kb3c7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB1c2luZyBDaHJvbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpIHtcbiAgICAgIHJldHVybiAnbG9hZGluZycgaW4gSFRNTEltYWdlRWxlbWVudC5wcm90b3R5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IG9iamVjdCwgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIG9wdGlvbnMsIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN0cmFuc2Zvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IG9wdGlvbnMgdG8gYXBwbHkuXG4gICAgICogQHJldHVybiB7VHJhbnNmb3JtYXRpb259XG4gICAgICogQHNlZSBUcmFuc2Zvcm1hdGlvblxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gc3JjX3RyYW5zZm9ybWF0aW9uW1wibmV3XCJdKHRoaXMuY29uZmlnKCkpLmZyb21PcHRpb25zKG9wdGlvbnMpLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gd2lsbCBhcHBlbmQgYSBUcmFuc3BhcmVudFZpZGVvIGVsZW1lbnQgdG8gdGhlIGh0bWxFbENvbnRhaW5lciBwYXNzZWQgdG8gaXQuXG4gICAgICogICAgICAgICAgICAgIFRyYW5zcGFyZW50VmlkZW8gY2FuIGVpdGhlciBiZSBhbiBIVE1MIFZpZGVvIHRhZywgb3IgYW4gSFRNTCBDYW52YXMgVGFnLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxFbENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFRoZSB7QGxpbmsgVHJhbnNwYXJlbnRWaWRlb09wdGlvbnN9IG9wdGlvbnMgdG8gYXBwbHkgLSBFeHRlbmRzIFRyYW5zZm9ybWF0aW9uT3B0aW9uc1xuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb25zLnBsYXlzaW5saW5lICAgIC0gSFRNTCBWaWRlbyBUYWcncyBuYXRpdmUgcGxheXNpbmxpbmUgLSBwYXNzZWQgdG8gdmlkZW8gZWxlbWVudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9ucy5wb3N0ZXIgICAgICAgICAtIEhUTUwgVmlkZW8gVGFnJ3MgbmF0aXZlIHBvc3RlciAtIHBhc3NlZCB0byB2aWRlbyBlbGVtZW50LlxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb25zLmxvb3AgICAgICAgICAgIC0gSFRNTCBWaWRlbyBUYWcncyBuYXRpdmUgbG9vcCAtIHBhc3NlZCB0byB2aWRlbyBlbGVtZW50LlxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb25zPy5leHRlcm5hbExpYnJhcmllcyA9IHsgW2tleTogc3RyaW5nXTogc3RyaW5nfSAtIG1hcCBvZiBleHRlcm5hbCBsaWJyYXJpZXMgdG8gYmUgbG9hZGVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxIVE1MRWxlbWVudCB8IHtzdGF0dXM6c3RyaW5nLCBtZXNzYWdlOnN0cmluZ30+fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5qZWN0VHJhbnNwYXJlbnRWaWRlb0VsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5qZWN0VHJhbnNwYXJlbnRWaWRlb0VsZW1lbnQoaHRtbEVsQ29udGFpbmVyLCBwdWJsaWNJZCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICghaHRtbEVsQ29udGFpbmVyKSB7XG4gICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdFeHBlY3RpbmcgaHRtbEVsQ29udGFpbmVyIHRvIGJlIEhUTUxFbGVtZW50J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNwYXJlbnRWaWRlb19lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8ob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHZpZGVvVVJMID0gX3RoaXMzLnZpZGVvX3VybChwdWJsaWNJZCwgb3B0aW9ucyk7XG5cbiAgICAgICAgdHJhbnNwYXJlbnRWaWRlb19jaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3koKS50aGVuKGZ1bmN0aW9uIChpc05hdGl2ZWx5VHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgbW91bnRQcm9taXNlO1xuXG4gICAgICAgICAgaWYgKGlzTmF0aXZlbHlUcmFuc3BhcmVudCkge1xuICAgICAgICAgICAgbW91bnRQcm9taXNlID0gdHJhbnNwYXJlbnRWaWRlb19tb3VudENsb3VkaW5hcnlWaWRlb1RhZyhodG1sRWxDb250YWluZXIsIF90aGlzMywgcHVibGljSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmVzb2x2ZShodG1sRWxDb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3VudFByb21pc2UgPSB0cmFuc3BhcmVudFZpZGVvX21vdW50U2VlVGhydUNhbnZhc1RhZyhodG1sRWxDb250YWluZXIsIHZpZGVvVVJMLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb3VudFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKGh0bWxFbENvbnRhaW5lcik7XG4gICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IF9yZWYuc3RhdHVzLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmLm1lc3NhZ2U7XG4gICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7IC8vIGNhdGNoIGZvciBjaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3koKVxuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgIHZhciBzdGF0dXMgPSBfcmVmMi5zdGF0dXMsXG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmMi5tZXNzYWdlO1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJuZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25ldyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENsb3VkaW5hcnk7XG59KCk7XG5cbmFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoY2xvdWRpbmFyeV9DbG91ZGluYXJ5LCBjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsb3VkaW5hcnkgPSAoY2xvdWRpbmFyeV9DbG91ZGluYXJ5KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL25hbWVzcGFjZS9jbG91ZGluYXJ5LWNvcmUuanNcbi8qKlxuICogQ3JlYXRlcyB0aGUgbmFtZXNwYWNlIGZvciBDbG91ZGluYXJ5XG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbG91ZGluYXJ5X2NvcmUgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIENsaWVudEhpbnRzTWV0YVRhZzogY2xpZW50aGludHNtZXRhdGFnLFxuICBDbG91ZGluYXJ5OiBjbG91ZGluYXJ5LFxuICBDb25kaXRpb246IGNvbmRpdGlvbixcbiAgQ29uZmlndXJhdGlvbjogc3JjX2NvbmZpZ3VyYXRpb24sXG4gIGNyYzMyOiBzcmNfY3JjMzIsXG4gIEV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gIEZldGNoTGF5ZXI6IGZldGNobGF5ZXIsXG4gIEh0bWxUYWc6IGh0bWx0YWcsXG4gIEltYWdlVGFnOiBpbWFnZXRhZyxcbiAgTGF5ZXI6IGxheWVyX2xheWVyLFxuICBQaWN0dXJlVGFnOiBwaWN0dXJldGFnLFxuICBTdWJ0aXRsZXNMYXllcjogc3VidGl0bGVzbGF5ZXIsXG4gIFRleHRMYXllcjogdGV4dGxheWVyLFxuICBUcmFuc2Zvcm1hdGlvbjogc3JjX3RyYW5zZm9ybWF0aW9uLFxuICB1dGY4X2VuY29kZTogc3JjX3V0ZjhfZW5jb2RlLFxuICBVdGlsOiBsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LFxuICBWaWRlb1RhZzogdmlkZW90YWdcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9hc3NpZ25cIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9hc3NpZ25fXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2Nsb25lRGVlcFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Nsb25lRGVlcF9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvY29tcGFjdFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2NvbXBhY3RfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2RpZmZlcmVuY2VcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9kaWZmZXJlbmNlX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9mdW5jdGlvbnNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9mdW5jdGlvbnNfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lkZW50aXR5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaWRlbnRpdHlfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2luY2x1ZGVzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaW5jbHVkZXNfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lzQXJyYXlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0FycmF5X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc0VsZW1lbnRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0VsZW1lbnRfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lzRnVuY3Rpb25cIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0Z1bmN0aW9uX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc1BsYWluT2JqZWN0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNQbGFpbk9iamVjdF9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNTdHJpbmdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1N0cmluZ19fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvbWVyZ2VcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9tZXJnZV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvdHJpbVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX3RyaW1fXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb3VkaW5hcnktY29yZS5qcy5tYXAiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfYXNzaWduX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jbG9uZURlZXBfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2NvbXBhY3RfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2RpZmZlcmVuY2VfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Z1bmN0aW9uc19fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaWRlbnRpdHlfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2luY2x1ZGVzX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0FycmF5X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0VsZW1lbnRfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRnVuY3Rpb25fXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzUGxhaW5PYmplY3RfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzU3RyaW5nX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9tZXJnZV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfdHJpbV9fIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImNsaWVudGhpbnRzbWV0YXRhZyIsImNsb3VkaW5hcnkiLCJjb25kaXRpb24iLCJzcmNfY29uZmlndXJhdGlvbiIsInNyY19jcmMzMiIsImV4cHJlc3Npb24iLCJmZXRjaGxheWVyIiwiaHRtbHRhZyIsImltYWdldGFnIiwibGF5ZXJfbGF5ZXIiLCJwaWN0dXJldGFnIiwic3VidGl0bGVzbGF5ZXIiLCJ0ZXh0bGF5ZXIiLCJzcmNfdHJhbnNmb3JtYXRpb24iLCJzcmNfdXRmOF9lbmNvZGUiLCJsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0IiwidmlkZW90YWciLCJjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0IiwiVkVSU0lPTiIsIkNGX1NIQVJFRF9DRE4iLCJPTERfQUtBTUFJX1NIQVJFRF9DRE4iLCJBS0FNQUlfU0hBUkVEX0NETiIsIlNIQVJFRF9DRE4iLCJERUZBVUxUX1RJTUVPVVRfTVMiLCJERUZBVUxUX1BPU1RFUl9PUFRJT05TIiwiREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMiLCJTRU9fVFlQRVMiLCJERUZBVUxUX0lNQUdFX1BBUkFNUyIsIkRFRkFVTFRfVklERU9fUEFSQU1TIiwiREVGQVVMVF9WSURFT19TT1VSQ0VTIiwiREVGQVVMVF9FWFRFUk5BTF9MSUJSQVJJRVMiLCJQTEFDRUhPTERFUl9JTUFHRV9NT0RFUyIsIkFDQ0VTU0lCSUxJVFlfTU9ERVMiLCJVUkxfS0VZUyIsImdldFNES0FuYWx5dGljc1NpZ25hdHVyZSIsImdldEFuYWx5dGljc09wdGlvbnMiLCJhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCIsImEiLCJjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCIsImNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQiLCJkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0IiwiZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zX2RlZmF1bHQiLCJpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQiLCJpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQiLCJpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0IiwiaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCIsImlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCIsIm1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCIsImlzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQiLCJpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkIiwiZGV0ZWN0SW50ZXJzZWN0aW9uIiwib21pdCIsImJhc2V1dGlsX2FsbFN0cmluZ3MiLCJ3aXRob3V0IiwiaXNOdW1iZXJMaWtlIiwic21hcnRFc2NhcGUiLCJkZWZhdWx0cyIsIm9iamVjdFByb3RvIiwib2JqVG9TdHJpbmciLCJpc09iamVjdCIsImZ1bmNUYWciLCJyZVdvcmRzIiwiY2FtZWxDYXNlIiwic25ha2VDYXNlIiwiY29udmVydEtleXMiLCJ3aXRoQ2FtZWxDYXNlS2V5cyIsIndpdGhTbmFrZUNhc2VLZXlzIiwiYmFzZTY0RW5jb2RlIiwiYmFzZTY0RW5jb2RlVVJMIiwiZXh0cmFjdFVybFBhcmFtcyIsInBhdGNoRmV0Y2hGb3JtYXQiLCJvcHRpb25Db25zdW1lIiwiaXNFbXB0eSIsImlzQW5kcm9pZCIsImlzRWRnZSIsImlzQ2hyb21lIiwiaXNTYWZhcmkiLCJpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdCIsImlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQiLCJ0cmltX3Jvb3RfdHJpbV9kZWZhdWx0IiwibG9kYXNoX2dldERhdGEiLCJsb2Rhc2hfc2V0RGF0YSIsImxvZGFzaF9nZXRBdHRyaWJ1dGUiLCJsb2Rhc2hfc2V0QXR0cmlidXRlIiwibG9kYXNoX3JlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZXMiLCJsb2Rhc2hfaGFzQ2xhc3MiLCJsb2Rhc2hfYWRkQ2xhc3MiLCJnZXRTdHlsZXMiLCJjc3NFeHBhbmQiLCJkb21TdHlsZSIsImN1ckNTUyIsImNzc1ZhbHVlIiwiYXVnbWVudFdpZHRoT3JIZWlnaHQiLCJnZXRXaWR0aE9ySGVpZ2h0IiwibG9kYXNoX3dpZHRoIiwidXRmOF9lbmNvZGUiLCJhcmdTdHJpbmciLCJjMSIsImVuYyIsImVuZCIsInN0YXJ0Iiwic3RyaW5nIiwic3RyaW5nbCIsInV0ZnRleHQiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic2xpY2UiLCJjcmMzMiIsInN0ciIsImNyYyIsImlUb3AiLCJ0YWJsZSIsIngiLCJ5Iiwic3Vic3RyIiwic3RyaW5nUGFkIiwidGFyZ2V0TGVuZ3RoIiwicGFkU3RyaW5nIiwicmVwZWF0U3RyaW5nTnVtVGltZXMiLCJ0aW1lcyIsInJlcGVhdGVkU3RyaW5nIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIlR5cGVFcnJvciIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJjb25zdHJ1Y3RvciIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJpdGVyIiwiaXRlcmF0b3IiLCJpc0FycmF5IiwibGVuIiwiYXJyMiIsImNoYXJzIiwiYmFzZTY0TWFwX251bSIsIm1hcCIsImZvckVhY2giLCJfY2hhciIsImJhc2U2NE1hcCIsInJldmVyc2VWZXJzaW9uIiwic2VtVmVyIiwic3BsaXQiLCJFcnJvciIsInJldmVyc2UiLCJzZWdtZW50Iiwiam9pbiIsImVuY29kZVZlcnNpb24iLCJzdHJSZXN1bHQiLCJwYXJ0cyIsInBhZGRlZFN0cmluZ0xlbmd0aCIsInBhZGRlZFJldmVyc2VkU2VtdmVyIiwibnVtIiwicGFyc2VJbnQiLCJwYWRkZWRCaW5hcnkiLCJtYXRjaCIsImJpdFN0cmluZyIsImFuYWx5dGljc09wdGlvbnMiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJ0d29QYXJ0VmVyc2lvbiIsInJlbW92ZVBhdGNoRnJvbVNlbXZlciIsInRlY2hWZXJzaW9uIiwiZW5jb2RlZFNES1ZlcnNpb24iLCJzZGtTZW12ZXIiLCJlbmNvZGVkVGVjaFZlcnNpb24iLCJmZWF0dXJlQ29kZSIsImZlYXR1cmUiLCJTREtDb2RlIiwic2RrQ29kZSIsImFsZ29WZXJzaW9uIiwiY29uY2F0IiwiZSIsInNlbVZlclN0ciIsIm9wdGlvbnMiLCJ1cmxBbmFseXRpY3MiLCJhY2Nlc3NpYmlsaXR5IiwibG9hZGluZyIsInJlc3BvbnNpdmUiLCJwbGFjZWhvbGRlciIsImFzc2lnbl9yb290X2Fzc2lnbl8iLCJjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfIiwiY29tcGFjdF9yb290X2NvbXBhY3RfIiwiZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfIiwiZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zXyIsImlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfIiwiaW5jbHVkZXNfcm9vdF9pbmNsdWRlc18iLCJpc0FycmF5X3Jvb3RfaXNBcnJheV8iLCJpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF8iLCJpc1N0cmluZ19yb290X2lzU3RyaW5nXyIsIm1lcmdlX3Jvb3RfbWVyZ2VfIiwiaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50XyIsImlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uXyIsInRyaW1fcm9vdF90cmltXyIsIl90eXBlb2YiLCJvYmoiLCJ3aW5kb3ciLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkhUTUxJbWFnZUVsZW1lbnQiLCJlbCIsIm9uSW50ZXJzZWN0Iiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZW50cnkiLCJpc0ludGVyc2VjdGluZyIsInVub2JzZXJ2ZSIsInRhcmdldCIsInRocmVzaG9sZCIsIm9ic2VydmUiLCJmb3JtYXQiLCJyZXNvdXJjZV90eXBlIiwidHJhbnNmb3JtYXRpb24iLCJ0eXBlIiwiZmFsbGJhY2tfY29udGVudCIsInNvdXJjZV90cmFuc2Zvcm1hdGlvbiIsInNvdXJjZV90eXBlcyIsImNvZGVjcyIsInRyYW5zZm9ybWF0aW9ucyIsInZpZGVvX2NvZGVjIiwic2VlVGhydSIsImVmZmVjdCIsInF1YWxpdHkiLCJmZXRjaF9mb3JtYXQiLCJ3aWR0aCIsImFzcGVjdF9yYXRpbyIsImNyb3AiLCJiYWNrZ3JvdW5kIiwiaGVpZ2h0IiwiZ3Jhdml0eSIsInZhcmlhYmxlcyIsImRhcmttb2RlIiwiYnJpZ2h0bW9kZSIsIm1vbm9jaHJvbWUiLCJjb2xvcmJsaW5kIiwiYmFzZXV0aWxfdHlwZW9mIiwia2V5cyIsInNyY0tleXMiLCJmaWx0ZXIiLCJmaWx0ZXJlZCIsImFsbFN0cmluZ3MiLCJsaXN0IiwiZXZlcnkiLCJhcnJheSIsIml0ZW0iLCJ2IiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwidW5zYWZlIiwicmVwbGFjZSIsInRvVXBwZXJDYXNlIiwiZGVzdGluYXRpb24iLCJfbGVuIiwic291cmNlcyIsIl9rZXkiLCJyZWR1Y2UiLCJkZXN0Iiwic291cmNlIiwiaXNGdW5jdGlvbiIsImxvd2VyIiwidXBwZXIiLCJSZWdFeHAiLCJ3b3JkcyIsIndvcmQiLCJjaGFyQXQiLCJ0b0xvY2FsZVVwcGVyQ2FzZSIsInRvTG9jYWxlTG93ZXJDYXNlIiwiY29udmVydGVyIiwicmVzdWx0IiwiYnRvYSIsIkJ1ZmZlciIsImlucHV0IiwidXJsIiwiZGVjb2RlVVJJIiwiZW5jb2RlVVJJIiwib3B0aW9uX25hbWUiLCJkZWZhdWx0X3ZhbHVlIiwic2l6ZSIsImdldFVzZXJBZ2VudCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm5vZGVDb250YWlucyIsImdldERhdGEiLCJlbGVtZW50IiwiZ2V0QXR0cmlidXRlIiwiZ2V0QXR0ciIsImRhdGEiLCJqUXVlcnkiLCJmbiIsInNldERhdGEiLCJzZXRBdHRyaWJ1dGUiLCJzZXRBdHRyIiwiYXR0ciIsInJlbW92ZUF0dHJpYnV0ZSIsImF0dHJpYnV0ZXMiLCJyZXN1bHRzIiwicHVzaCIsImhhc0NsYXNzIiwiY2xhc3NOYW1lIiwiYWRkQ2xhc3MiLCJlbGVtIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwib3BlbmVyIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImIiLCJhZG93biIsImJ1cCIsIm5vZGVUeXBlIiwiZG9jdW1lbnRFbGVtZW50IiwicGFyZW50Tm9kZSIsImNvbnRhaW5zIiwic3R5bGUiLCJjb21wdXRlZCIsIm1heFdpZHRoIiwibWluV2lkdGgiLCJyZXQiLCJybWFyZ2luIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInJudW1ub25weCIsImNvbnZlcnQiLCJzdHlsZXMiLCJ2YWwiLCJleHRyYSIsImlzQm9yZGVyQm94Iiwic2lkZSIsInNpZGVzIiwicG51bSIsInZhbHVlSXNCb3JkZXJCb3giLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiRXhwcmVzc2lvbiIsImV4cHJlc3Npb25TdHIiLCJleHByZXNzaW9ucyIsIm5vcm1hbGl6ZSIsInNlcmlhbGl6ZSIsImdldFBhcmVudCIsInBhcmVudCIsInNldFBhcmVudCIsInByZWRpY2F0ZSIsIm9wZXJhdG9yIiwiT1BFUkFUT1JTIiwiYW5kIiwib3IiLCJ0aGVuIiwiYXNwZWN0UmF0aW8iLCJwYWdlQ291bnQiLCJmYWNlQ291bnQiLCJfdmFsdWUiLCJfbmV3Iiwib3BlcmF0b3JzIiwib3BlcmF0b3JzUGF0dGVybiIsIm9wZXJhdG9yc1JlcGxhY2VSRSIsInByZWRlZmluZWRWYXJzUGF0dGVybiIsIlBSRURFRklORURfVkFSUyIsInVzZXJWYXJpYWJsZVBhdHRlcm4iLCJ2YXJpYWJsZXNSZXBsYWNlUkUiLCJ2YXJpYWJsZSIsImluaXRpYWxXaWR0aCIsImluaXRpYWxIZWlnaHQiLCJpbml0aWFsQXNwZWN0UmF0aW8iLCJjdXJyZW50UGFnZSIsInRhZ3MiLCJwYWdlWCIsInBhZ2VZIiwiQk9VTkRSWSIsImNvbmRpdGlvbl90eXBlb2YiLCJjb25kaXRpb25fY2xhc3NDYWxsQ2hlY2siLCJjb25kaXRpb25fZGVmaW5lUHJvcGVydGllcyIsImNvbmRpdGlvbl9jcmVhdGVDbGFzcyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIl9zZXRQcm90b3R5cGVPZiIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIl9nZXRQcm90b3R5cGVPZiIsIk5ld1RhcmdldCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJhcHBseSIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJDb25kaXRpb24iLCJfRXhwcmVzc2lvbiIsIl9zdXBlciIsImNvbmRpdGlvblN0ciIsImR1cmF0aW9uIiwiaW5pdGlhbER1cmF0aW9uIiwiX3NsaWNlZFRvQXJyYXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJjb25maWd1cmF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsImNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheSIsIl9pIiwiX2FyciIsIl9uIiwiX2QiLCJfcyIsIl9lIiwibmV4dCIsImRvbmUiLCJlcnIiLCJjb25maWd1cmF0aW9uX2NsYXNzQ2FsbENoZWNrIiwiY29uZmlndXJhdGlvbl9kZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhdGlvbl9jcmVhdGVDbGFzcyIsImNvbmZpZ3VyYXRpb25fQ29uZmlndXJhdGlvbiIsIkNvbmZpZ3VyYXRpb24iLCJjb25maWd1cmF0aW9uIiwiREVGQVVMVF9DT05GSUdVUkFUSU9OX1BBUkFNUyIsImluaXQiLCJmcm9tRW52aXJvbm1lbnQiLCJmcm9tRG9jdW1lbnQiLCJzZXQiLCJtZXJnZSIsImNvbmZpZyIsIm1ldGFfZWxlbWVudHMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJfdGhpcyIsImNsb3VkaW5hcnlfdXJsIiwicXVlcnkiLCJ1cmkiLCJ1cmlSZWdleCIsInByb2Nlc3MiLCJlbnYiLCJDTE9VRElOQVJZX1VSTCIsImV4ZWMiLCJfdmFsdWUkc3BsaXQiLCJfdmFsdWUkc3BsaXQyIiwiayIsIm5ld19jb25maWciLCJuZXdfdmFsdWUiLCJ0b09wdGlvbnMiLCJyZXNwb25zaXZlX2NsYXNzIiwicmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMiLCJyb3VuZF9kcHIiLCJzZWN1cmUiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiQ09ORklHX1BBUkFNUyIsImxheWVyX2NsYXNzQ2FsbENoZWNrIiwibGF5ZXJfZGVmaW5lUHJvcGVydGllcyIsImxheWVyX2NyZWF0ZUNsYXNzIiwibGF5ZXJfTGF5ZXIiLCJMYXllciIsInJlZiIsInJlc291cmNlVHlwZSIsInB1YmxpY0lkIiwiZ2V0UHVibGljSWQiLCJnZXRGdWxsUHVibGljSWQiLCJjb21wb25lbnRzIiwiY2xvbmUiLCJ0ZXh0bGF5ZXJfdHlwZW9mIiwidGV4dGxheWVyX2NsYXNzQ2FsbENoZWNrIiwidGV4dGxheWVyX2RlZmluZVByb3BlcnRpZXMiLCJ0ZXh0bGF5ZXJfY3JlYXRlQ2xhc3MiLCJ0ZXh0bGF5ZXJfaW5oZXJpdHMiLCJ0ZXh0bGF5ZXJfc2V0UHJvdG90eXBlT2YiLCJ0ZXh0bGF5ZXJfY3JlYXRlU3VwZXIiLCJ0ZXh0bGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwidGV4dGxheWVyX2dldFByb3RvdHlwZU9mIiwidGV4dGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJ0ZXh0bGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwidGV4dGxheWVyX1RleHRMYXllciIsIl9MYXllciIsIlRleHRMYXllciIsIl9yZXNvdXJjZVR5cGUiLCJfdHlwZSIsIl9mb3JtYXQiLCJmb250RmFtaWx5IiwiX2ZvbnRGYW1pbHkiLCJmb250U2l6ZSIsIl9mb250U2l6ZSIsImZvbnRXZWlnaHQiLCJfZm9udFdlaWdodCIsImZvbnRTdHlsZSIsIl9mb250U3R5bGUiLCJ0ZXh0RGVjb3JhdGlvbiIsIl90ZXh0RGVjb3JhdGlvbiIsInRleHRBbGlnbiIsIl90ZXh0QWxpZ24iLCJzdHJva2UiLCJfc3Ryb2tlIiwibGV0dGVyU3BhY2luZyIsIl9sZXR0ZXJTcGFjaW5nIiwibGluZVNwYWNpbmciLCJfbGluZVNwYWNpbmciLCJmb250SGludGluZyIsIl9mb250SGludGluZyIsImZvbnRBbnRpYWxpYXNpbmciLCJfZm9udEFudGlhbGlhc2luZyIsInRleHQiLCJfdGV4dCIsInRleHRTdHlsZSIsIl90ZXh0U3R5bGUiLCJoYXNQdWJsaWNJZCIsImhhc1N0eWxlIiwicmUiLCJyZXMiLCJ0ZXh0U291cmNlIiwidGV4dFN0eWxlSWRlbnRpZmllciIsImluZGV4IiwidW5zaGlmdCIsInN1YnRpdGxlc2xheWVyX3R5cGVvZiIsInN1YnRpdGxlc2xheWVyX2RlZmluZVByb3BlcnRpZXMiLCJzdWJ0aXRsZXNsYXllcl9jcmVhdGVDbGFzcyIsInN1YnRpdGxlc2xheWVyX2NsYXNzQ2FsbENoZWNrIiwic3VidGl0bGVzbGF5ZXJfaW5oZXJpdHMiLCJzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZiIsInN1YnRpdGxlc2xheWVyX2NyZWF0ZVN1cGVyIiwic3VidGl0bGVzbGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0Iiwic3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2YiLCJzdWJ0aXRsZXNsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic3VidGl0bGVzbGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiU3VidGl0bGVzTGF5ZXIiLCJfVGV4dExheWVyIiwiZmV0Y2hsYXllcl90eXBlb2YiLCJmZXRjaGxheWVyX2NsYXNzQ2FsbENoZWNrIiwiZmV0Y2hsYXllcl9kZWZpbmVQcm9wZXJ0aWVzIiwiZmV0Y2hsYXllcl9jcmVhdGVDbGFzcyIsImZldGNobGF5ZXJfaW5oZXJpdHMiLCJmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mIiwiZmV0Y2hsYXllcl9jcmVhdGVTdXBlciIsImZldGNobGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZiIsImZldGNobGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImZldGNobGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiZmV0Y2hsYXllcl9GZXRjaExheWVyIiwiRmV0Y2hMYXllciIsIl91cmwiLCJwYXJhbWV0ZXJzX3R5cGVvZiIsIl9nZXQiLCJyZWNlaXZlciIsImJhc2UiLCJfc3VwZXJQcm9wQmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mIiwicGFyYW1ldGVyc19pbmhlcml0cyIsInBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2YiLCJwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyIiwicGFyYW1ldGVyc19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJwYXJhbWV0ZXJzX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJwYXJhbWV0ZXJzX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2siLCJwYXJhbWV0ZXJzX2RlZmluZVByb3BlcnRpZXMiLCJwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzIiwicGFyYW1ldGVyc19QYXJhbSIsIlBhcmFtIiwic2hvcnROYW1lIiwib3JpZ1ZhbHVlIiwidmFsaWQiLCJub3JtX2NvbG9yIiwiYnVpbGRfYXJyYXkiLCJhcmciLCJwcm9jZXNzX3ZpZGVvX3BhcmFtcyIsInBhcmFtIiwidmlkZW8iLCJjb2RlYyIsInByb2ZpbGUiLCJsZXZlbCIsImJfZnJhbWVzIiwicGFyYW1ldGVyc19BcnJheVBhcmFtIiwiX1BhcmFtIiwiQXJyYXlQYXJhbSIsInNlcCIsImFycmF5VmFsdWUiLCJmbGF0IiwiX3RoaXMyIiwicGFyYW1ldGVyc19UcmFuc2Zvcm1hdGlvblBhcmFtIiwiX1BhcmFtMiIsIlRyYW5zZm9ybWF0aW9uUGFyYW0iLCJfc3VwZXIyIiwiX3RoaXMzIiwiX3RoaXM0Iiwiam9pbmVkIiwib3JpZ1ZhbHVlMSIsIm51bWJlcl9wYXR0ZXJuIiwib2Zmc2V0X2FueV9wYXR0ZXJuIiwicGFyYW1ldGVyc19SYW5nZVBhcmFtIiwiX1BhcmFtMyIsIlJhbmdlUGFyYW0iLCJfc3VwZXIzIiwibm9ybV9yYW5nZV92YWx1ZSIsIm9mZnNldCIsIm1vZGlmaWVyIiwicGFyYW1ldGVyc19SYXdQYXJhbSIsIl9QYXJhbTQiLCJSYXdQYXJhbSIsIl9zdXBlcjQiLCJwYXJhbWV0ZXJzX0xheWVyUGFyYW0iLCJfUGFyYW01IiwiTGF5ZXJQYXJhbSIsIl9zdXBlcjUiLCJsYXllck9wdGlvbnMiLCJsYXllciIsInBhcmFtZXRlcnNfRXhwcmVzc2lvblBhcmFtIiwiX1BhcmFtNiIsIkV4cHJlc3Npb25QYXJhbSIsIl9zdXBlcjYiLCJ0cmFuc2Zvcm1hdGlvbl90eXBlb2YiLCJ0cmFuc2Zvcm1hdGlvbl9pbmhlcml0cyIsInRyYW5zZm9ybWF0aW9uX3NldFByb3RvdHlwZU9mIiwidHJhbnNmb3JtYXRpb25fY3JlYXRlU3VwZXIiLCJ0cmFuc2Zvcm1hdGlvbl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJ0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZiIsInRyYW5zZm9ybWF0aW9uX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJ0cmFuc2Zvcm1hdGlvbl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJ0cmFuc2Zvcm1hdGlvbl9zbGljZWRUb0FycmF5IiwidHJhbnNmb3JtYXRpb25fYXJyYXlXaXRoSG9sZXMiLCJ0cmFuc2Zvcm1hdGlvbl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsInRyYW5zZm9ybWF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwidHJhbnNmb3JtYXRpb25fbm9uSXRlcmFibGVSZXN0IiwidHJhbnNmb3JtYXRpb25fYXJyYXlMaWtlVG9BcnJheSIsInRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrIiwidHJhbnNmb3JtYXRpb25fZGVmaW5lUHJvcGVydGllcyIsInRyYW5zZm9ybWF0aW9uX2NyZWF0ZUNsYXNzIiwiYXNzaWduTm90TnVsbCIsInRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uQmFzZSIsIlRyYW5zZm9ybWF0aW9uQmFzZSIsInRyYW5zIiwid2l0aENoYWluIiwib3B0Iiwib3RoZXJPcHRpb25zIiwiY2hhaW5lZCIsInRyIiwiZnJvbU9wdGlvbnMiLCJhYmJyIiwiZGVmYXVsdFZhbHVlIiwicmF3UGFyYW0iLCJsYXN0QXJnQ2FsbGJhY2siLCJyYW5nZVBhcmFtIiwiYXJyYXlQYXJhbSIsInRyYW5zZm9ybWF0aW9uUGFyYW0iLCJsYXllclBhcmFtIiwiZ2V0VmFsdWUiLCJyZW1vdmUiLCJ0ZW1wIiwiVkFSX05BTUVfUkUiLCJzb3J0IiwidG9QbGFpbk9iamVjdCIsImhhc2giLCJjaGFpbiIsIm5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInJlc2V0VHJhbnNmb3JtYXRpb25zIiwiZnJvbVRyYW5zZm9ybWF0aW9uIiwib3RoZXIiLCJjYW1lbEtleSIsIl9sZW4yIiwidmFsdWVzIiwiX2tleTIiLCJ0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbiIsIm1ldGhvZHMiLCJoYXNMYXllciIsImlmUGFyYW0iLCJqIiwicGFyYW1MaXN0IiwicmVmMSIsInJlZjIiLCJyZWYzIiwicmVmNCIsInJlc3VsdEFycmF5IiwidHJhbnNmb3JtYXRpb25MaXN0IiwidHJhbnNmb3JtYXRpb25TdHJpbmciLCJ2YXJzIiwicHJvY2Vzc1ZhciIsImxlbjEiLCJwYXJhbV9zZXBhcmF0b3IiLCJ0cmFuc19zZXBhcmF0b3IiLCJ0b0h0bWxBdHRyaWJ1dGVzIiwiYXR0ck5hbWUiLCJzbmFrZUNhc2VLZXkiLCJQQVJBTV9OQU1FUyIsInRvSHRtbCIsImxpc3ROYW1lcyIsImlzVmFsaWRQYXJhbU5hbWUiLCJpbmRleE9mIiwiYXJncyIsImNhbGxiYWNrIiwidmFyQXJyYXkiLCJfdmFyQXJyYXkkaiIsInByb2Nlc3NDdXN0b21GdW5jdGlvbiIsIl9yZWYiLCJmdW5jdGlvbl90eXBlIiwiX1RyYW5zZm9ybWF0aW9uQmFzZSIsIlRyYW5zZm9ybWF0aW9uIiwiYW5nbGUiLCJhdWRpb0NvZGVjIiwiYXVkaW9GcmVxdWVuY3kiLCJiaXRSYXRlIiwiYm9yZGVyIiwiY29sb3IiLCJjb2xvclNwYWNlIiwiY3VzdG9tRnVuY3Rpb24iLCJjdXN0b21QcmVGdW5jdGlvbiIsImRlZmF1bHRJbWFnZSIsImRlbGF5IiwiZGVuc2l0eSIsImRwciIsIl9lbHNlIiwiZW5kSWYiLCJlbmRPZmZzZXQiLCJmYWxsYmFja0NvbnRlbnQiLCJmZXRjaEZvcm1hdCIsImZsYWdzIiwiZnBzIiwiaHRtbEhlaWdodCIsImh0bWxXaWR0aCIsIl9pZiIsImlmVmFsIiwidHJJZiIsInRyUmVzdCIsImtleWZyYW1lSW50ZXJ2YWwiLCJvY3IiLCJlbmRfbyIsInN0YXJ0X28iLCJfcmVmMiIsIl9yZWYzIiwic3RhcnRPZmZzZXQiLCJvcGFjaXR5Iiwib3ZlcmxheSIsInBhZ2UiLCJwb3N0ZXIiLCJwcmVmaXgiLCJyYWRpdXMiLCJyYXdUcmFuc2Zvcm1hdGlvbiIsInNvdXJjZVR5cGVzIiwic291cmNlVHJhbnNmb3JtYXRpb24iLCJzdHJlYW1pbmdQcm9maWxlIiwidW5kZXJsYXkiLCJ2aWRlb0NvZGVjIiwidmlkZW9TYW1wbGluZyIsInpvb20iLCJodG1sdGFnX2NsYXNzQ2FsbENoZWNrIiwiaHRtbHRhZ19kZWZpbmVQcm9wZXJ0aWVzIiwiaHRtbHRhZ19jcmVhdGVDbGFzcyIsImh0bWx0YWdfSHRtbFRhZyIsIkh0bWxUYWciLCJodG1sQXR0cnMiLCJhdHRycyIsInBhaXJzIiwiZXNjYXBlUXVvdGVzIiwiaHRtbHRhZ190b0F0dHJpYnV0ZSIsImdldE9wdGlvbnMiLCJnZXRPcHRpb24iLCJodG1sQXR0cmlidXRlcyIsInJlbW92ZUF0dHIiLCJjb250ZW50Iiwib3BlblRhZyIsInRhZyIsImNsb3NlVGFnIiwidG9ET00iLCJjcmVhdGVFbGVtZW50IiwiaXNSZXNwb25zaXZlIiwicmVzcG9uc2l2ZUNsYXNzIiwiZGF0YVNyYyIsIl9leGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzb3VyY2VLZXlzIiwibWFrZVVybCIsImhvc3QiLCJwYXRobmFtZSIsImlzVXJsIiwiY2RuU3ViZG9tYWluTnVtYmVyIiwiaGFuZGxlU2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiaXNGb3JtYXR0ZWQiLCJoYW5kbGVQcmVmaXgiLCJjbG91ZF9uYW1lIiwiY2RuUGFydCIsInN1YmRvbWFpbiIsInBhdGgiLCJwcml2YXRlX2NkbiIsImNkbl9zdWJkb21haW4iLCJzZWN1cmVfY2RuX3N1YmRvbWFpbiIsInNlY3VyZV9kaXN0cmlidXRpb24iLCJjbmFtZSIsImhhbmRsZVJlc291cmNlVHlwZSIsIl9yZWYkcmVzb3VyY2VfdHlwZSIsIl9yZWYkdHlwZSIsInVybF9zdWZmaXgiLCJ1c2Vfcm9vdF9wYXRoIiwic2hvcnRlbiIsImVuY29kZVB1YmxpY0lkIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZm9ybWF0UHVibGljSWQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlcnJvciIsInRydXN0X3B1YmxpY19pZCIsInZhbGlkYXRlIiwiaGFuZGxlVmVyc2lvbiIsImlzRm9yY2VWZXJzaW9uIiwiZm9yY2VfdmVyc2lvbiIsImlzVmVyc2lvbkV4aXN0IiwidmVyc2lvbiIsImhhbmRsZVRyYW5zZm9ybWF0aW9uIiwicGxhY2Vob2xkZXJUcmFuc2Zvcm1hdGlvbnMiLCJibHVyIiwicHJlcGFyZVB1YmxpY0lkIiwidXJsU3RyaW5nIiwicHJlcGFyZU9wdGlvbnMiLCJ1cmxfdXJsIiwicmVzdWx0VXJsIiwic2RrQW5hbHl0aWNzU2lnbmF0dXJlIiwiYXBwZW5kZXIiLCJhdXRoX3Rva2VuIiwiX2FwcGVuZGVyIiwiZ2VuZXJhdGVCcmVha3BvaW50c19zbGljZWRUb0FycmF5IiwiZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheVdpdGhIb2xlcyIsImdlbmVyYXRlQnJlYWtwb2ludHNfaXRlcmFibGVUb0FycmF5TGltaXQiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiZ2VuZXJhdGVCcmVha3BvaW50c19ub25JdGVyYWJsZVJlc3QiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5TGlrZVRvQXJyYXkiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzIiwic3Jjc2V0IiwiYnJlYWtwb2ludHMiLCJfbWFwIiwibWluX3dpZHRoIiwibWF4X3dpZHRoIiwibWF4X2ltYWdlcyIsIk51bWJlciIsIl9tYXAyIiwic29tZSIsInN0ZXBTaXplIiwiTWF0aCIsImNlaWwiLCJtYXgiLCJjdXJyZW50Iiwic3Jjc2V0VXRpbHNfaXNFbXB0eSIsInNjYWxlZFVybCIsInB1YmxpY19pZCIsImNvbmZpZ1BhcmFtcyIsInJhd190cmFuc2Zvcm1hdGlvbiIsImdldE9yR2VuZXJhdGVCcmVha3BvaW50cyIsImdlbmVyYXRlU3Jjc2V0QXR0cmlidXRlIiwiZ2VuZXJhdGVTaXplc0F0dHJpYnV0ZSIsImdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyIsInNyY3NldERhdGEiLCJyZXNwb25zaXZlQXR0cmlidXRlcyIsImdlbmVyYXRlU2l6ZXMiLCJzaXplcyIsImdlbmVyYXRlU3Jjc2V0Iiwic3Jjc2V0QXR0ciIsInNpemVzQXR0ciIsImdlbmVyYXRlTWVkaWFBdHRyIiwibWVkaWFRdWVyeSIsInNyY3NldFVybCIsImltYWdldGFnX3R5cGVvZiIsImltYWdldGFnX2NsYXNzQ2FsbENoZWNrIiwiaW1hZ2V0YWdfZGVmaW5lUHJvcGVydGllcyIsImltYWdldGFnX2NyZWF0ZUNsYXNzIiwiaW1hZ2V0YWdfZ2V0IiwiaW1hZ2V0YWdfc3VwZXJQcm9wQmFzZSIsImltYWdldGFnX2dldFByb3RvdHlwZU9mIiwiaW1hZ2V0YWdfaW5oZXJpdHMiLCJpbWFnZXRhZ19zZXRQcm90b3R5cGVPZiIsImltYWdldGFnX2NyZWF0ZVN1cGVyIiwiaW1hZ2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiaW1hZ2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImltYWdldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsImltYWdldGFnX0ltYWdlVGFnIiwiX0h0bWxUYWciLCJJbWFnZVRhZyIsInNyY0F0dHJpYnV0ZSIsInNyY3NldFBhcmFtIiwiY2xpZW50X2hpbnRzIiwic291cmNldGFnX3R5cGVvZiIsInNvdXJjZXRhZ19jbGFzc0NhbGxDaGVjayIsInNvdXJjZXRhZ19kZWZpbmVQcm9wZXJ0aWVzIiwic291cmNldGFnX2NyZWF0ZUNsYXNzIiwic291cmNldGFnX2dldCIsInNvdXJjZXRhZ19zdXBlclByb3BCYXNlIiwic291cmNldGFnX2dldFByb3RvdHlwZU9mIiwic291cmNldGFnX2luaGVyaXRzIiwic291cmNldGFnX3NldFByb3RvdHlwZU9mIiwic291cmNldGFnX2NyZWF0ZVN1cGVyIiwic291cmNldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInNvdXJjZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic291cmNldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNvdXJjZXRhZ19Tb3VyY2VUYWciLCJTb3VyY2VUYWciLCJtZWRpYSIsInNvdXJjZXRhZyIsInBpY3R1cmV0YWdfdHlwZW9mIiwicGljdHVyZXRhZ19jbGFzc0NhbGxDaGVjayIsInBpY3R1cmV0YWdfZGVmaW5lUHJvcGVydGllcyIsInBpY3R1cmV0YWdfY3JlYXRlQ2xhc3MiLCJwaWN0dXJldGFnX2dldCIsInBpY3R1cmV0YWdfc3VwZXJQcm9wQmFzZSIsInBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YiLCJwaWN0dXJldGFnX2luaGVyaXRzIiwicGljdHVyZXRhZ19zZXRQcm90b3R5cGVPZiIsInBpY3R1cmV0YWdfY3JlYXRlU3VwZXIiLCJwaWN0dXJldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInBpY3R1cmV0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInBpY3R1cmV0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwicGljdHVyZXRhZ19QaWN0dXJlVGFnIiwiUGljdHVyZVRhZyIsIndpZHRoTGlzdCIsInZpZGVvdGFnX3R5cGVvZiIsInZpZGVvdGFnX2NsYXNzQ2FsbENoZWNrIiwidmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyIsInZpZGVvdGFnX2NyZWF0ZUNsYXNzIiwidmlkZW90YWdfZ2V0IiwidmlkZW90YWdfc3VwZXJQcm9wQmFzZSIsInZpZGVvdGFnX2dldFByb3RvdHlwZU9mIiwidmlkZW90YWdfaW5oZXJpdHMiLCJ2aWRlb3RhZ19zZXRQcm90b3R5cGVPZiIsInZpZGVvdGFnX2NyZWF0ZVN1cGVyIiwidmlkZW90YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwidmlkZW90YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInZpZGVvdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlZJREVPX1RBR19QQVJBTVMiLCJ2aWRlb3RhZ19ERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyIsInZpZGVvdGFnX0RFRkFVTFRfUE9TVEVSX09QVElPTlMiLCJ2aWRlb3RhZ19WaWRlb1RhZyIsIlZpZGVvVGFnIiwic2V0U291cmNlVHJhbnNmb3JtYXRpb24iLCJzZXRTb3VyY2VUeXBlcyIsInNldFBvc3RlciIsInNldEZhbGxiYWNrQ29udGVudCIsImZhbGxiYWNrIiwiaW5uZXJUYWdzIiwic3JjIiwiY3JlYXRlU291cmNlVGFnIiwic3JjVHlwZSIsImRlZmF1bHRPcHRpb25zIiwiaGFzU291cmNlVGFncyIsInNvdXJjZVR5cGUiLCJtaW1lVHlwZSIsInZpZGVvVHlwZSIsImNvZGVjc1N0ciIsImNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2YiLCJjbGllbnRoaW50c21ldGF0YWdfY2xhc3NDYWxsQ2hlY2siLCJjbGllbnRoaW50c21ldGF0YWdfZGVmaW5lUHJvcGVydGllcyIsImNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyIsImNsaWVudGhpbnRzbWV0YXRhZ19pbmhlcml0cyIsImNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZiIsImNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVTdXBlciIsImNsaWVudGhpbnRzbWV0YXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YiLCJjbGllbnRoaW50c21ldGF0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNsaWVudGhpbnRzbWV0YXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJjbGllbnRoaW50c21ldGF0YWdfQ2xpZW50SGludHNNZXRhVGFnIiwiQ2xpZW50SGludHNNZXRhVGFnIiwibm9ybWFsaXplVG9BcnJheV90b0NvbnN1bWFibGVBcnJheSIsIm5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlXaXRob3V0SG9sZXMiLCJub3JtYWxpemVUb0FycmF5X2l0ZXJhYmxlVG9BcnJheSIsIm5vcm1hbGl6ZVRvQXJyYXlfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJub3JtYWxpemVUb0FycmF5X25vbkl0ZXJhYmxlU3ByZWFkIiwibm9ybWFsaXplVG9BcnJheV9hcnJheUxpa2VUb0FycmF5Iiwibm9ybWFsaXplVG9BcnJheSIsImVsZW1lbnRzIiwibW91bnRDbG91ZGluYXJ5VmlkZW9UYWciLCJodG1sRWxDb250YWluZXIiLCJjbEluc3RhbmNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpbm5lckhUTUwiLCJ2aWRlb1RhZyIsImNsb3VkaW5hcnlWaWRlb0VsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidHJhbnNwYXJlbnRWaWRlb19tb3VudENsb3VkaW5hcnlWaWRlb1RhZyIsImFkZEZsYWdUb09wdGlvbnMiLCJmbGFnIiwiYWRkRmxhZyIsImVuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyIsImF1dG9wbGF5IiwibXV0ZWQiLCJjb250cm9scyIsIm1heF90aW1lb3V0X21zIiwiZXh0ZXJuYWxMaWJyYXJpZXMiLCJ0cmFuc3BhcmVudFZpZGVvX2VuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyIsImxvYWRTY3JpcHQiLCJzY3JpcHRVUkwiLCJpc0FscmVhZHlMb2FkZWQiLCJzY3JpcHRUYWciLCJ0aW1lcklEIiwic2V0VGltZW91dCIsInN0YXR1cyIsIm1lc3NhZ2UiLCJvbmVycm9yIiwiY2xlYXJUaW1lb3V0Iiwib25sb2FkIiwiaGVhZCIsImFwcGVuZENoaWxkIiwieGhyX2xvYWRTY3JpcHQiLCJyZWplY3RPblRpbWVvdXQiLCJtYXhUaW1lb3V0TVMiLCJnZXRCbG9iRnJvbVVSTCIsInVybFRvTG9hZCIsImZldGNoQmxvYiIsImZldGNoIiwibG9hZFVybFVzaW5nRmV0Y2giLCJsb2FkVXJsVXNpbmdYaHIiLCJibG9iIiwicGF5bG9hZCIsImJsb2JVUkwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJyZXNwb25zZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwicmVzcG9uc2VUeXBlIiwib3BlbiIsInNlbmQiLCJ4aHJfZ2V0QmxvYkZyb21VUkwiLCJjcmVhdGVIaWRkZW5WaWRlb1RhZyIsInZpZGVvT3B0aW9ucyIsInBsYXlzaW5saW5lIiwibG9vcCIsInZpZGVvVVJMIiwidmlzaWJpbGl0eSIsInBvc2l0aW9uIiwicmV2b2tlT2JqZWN0VVJMIiwidHJhbnNwYXJlbnRWaWRlb19jcmVhdGVIaWRkZW5WaWRlb1RhZyIsImluc3RhbnRpYXRlU2VlVGhydSIsInZpZGVvRWxlbWVudCIsImN1c3RvbUNsYXNzIiwiYXV0b1BsYXkiLCJfd2luZG93Iiwic2VlVGhydUluc3RhbmNlIiwicmVhZHkiLCJjYW52YXNFbGVtZW50IiwiZ2V0Q2FudmFzIiwicGxheSIsInRyYW5zcGFyZW50VmlkZW9faW5zdGFudGlhdGVTZWVUaHJ1IiwibW91bnRTZWVUaHJ1Q2FudmFzVGFnIiwidHJhbnNwYXJlbnRWaWRlb19tb3VudFNlZVRocnVDYW52YXNUYWciLCJjaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kiLCJjYW5QbGF5IiwiY2FuUGxheVR5cGUiLCJ0cmFuc3BhcmVudFZpZGVvX2NoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSIsImNsb3VkaW5hcnlfY2xhc3NDYWxsQ2hlY2siLCJjbG91ZGluYXJ5X2RlZmluZVByb3BlcnRpZXMiLCJjbG91ZGluYXJ5X2NyZWF0ZUNsYXNzIiwiYXBwbHlCcmVha3BvaW50cyIsImNsb3Nlc3RBYm92ZSIsImRlZmF1bHRCcmVha3BvaW50cyIsImNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoIiwiY2xvdWRpbmFyeV9tYXhXaWR0aCIsInVwZGF0ZURwciIsInN0ZXBzIiwicmVzaXppbmciLCJjYWxjX2JyZWFrcG9pbnQiLCJmaW5kQ29udGFpbmVyV2lkdGgiLCJjb250YWluZXJXaWR0aCIsIkVsZW1lbnQiLCJkaXNwbGF5Iiwicm91bmREcHIiLCJkZXZpY2VfcGl4ZWxfcmF0aW8iLCJyZXF1aXJlZFdpZHRoIiwiaW1hZ2VXaWR0aCIsImNsb3VkaW5hcnlfQ2xvdWRpbmFyeSIsIkNsb3VkaW5hcnkiLCJkZXZpY2VQaXhlbFJhdGlvQ2FjaGUiLCJyZXNwb25zaXZlQ29uZmlnIiwicmVzcG9uc2l2ZVJlc2l6ZUluaXRpYWxpemVkIiwibmV3Q29uZmlnIiwibmV3VmFsdWUiLCJ2aWRlb191cmwiLCJ2aWRlb190aHVtYm5haWxfdXJsIiwidHJhbnNmb3JtYXRpb25fc3RyaW5nIiwiaW1hZ2UiLCJpbWciLCJpbWFnZVRhZyIsImNsb3VkaW5hcnlfdXBkYXRlIiwicGljdHVyZVRhZyIsInNvdXJjZVRhZyIsInZpZGVvX3RodW1ibmFpbCIsImZhY2Vib29rX3Byb2ZpbGVfaW1hZ2UiLCJ0d2l0dGVyX3Byb2ZpbGVfaW1hZ2UiLCJ0d2l0dGVyX25hbWVfcHJvZmlsZV9pbWFnZSIsImdyYXZhdGFyX2ltYWdlIiwiZmV0Y2hfaW1hZ2UiLCJzcHJpdGVfY3NzIiwiYm9vdHN0cmFwIiwicmVzcG9uc2l2ZVJlc2l6ZSIsInRpbWVvdXQiLCJyZXNwb25zaXZlX3Jlc2l6ZSIsIm1ha2VSZXNwb25zaXZlIiwiZGVib3VuY2UiLCJyZXNldCIsInJ1biIsIndhaXQiLCJ3YWl0RnVuYyIsInJlc3BvbnNpdmVfZGVib3VuY2UiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBvaW50IiwiY2FsY19zdG9wcG9pbnQiLCJkZXZpY2VQaXhlbFJhdGlvIiwiZHByU3RyaW5nIiwicHJvY2Vzc0ltYWdlVGFncyIsIm5vZGVzIiwiaW1hZ2VzIiwibm9kZSIsInRhZ05hbWUiLCJpbWdPcHRpb25zIiwic2V0VXJsIiwicmVzcG9uc2l2ZV9wcmVzZXJ2ZV9oZWlnaHQiLCJpc0xhenlMb2FkaW5nIiwiaXNMYXp5TG9hZFN1cHBvcnRlZCIsInNldEF0dHJpYnV0ZUlmRXhpc3RzIiwidG9BdHRyaWJ1dGUiLCJmcm9tQXR0cmlidXRlIiwiYXR0cmlidXRlVmFsdWUiLCJpbmplY3RUcmFuc3BhcmVudFZpZGVvRWxlbWVudCIsImlzTmF0aXZlbHlUcmFuc3BhcmVudCIsIm1vdW50UHJvbWlzZSIsImNsb3VkaW5hcnlfY29yZSIsIlV0aWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/cloudinary-core/cloudinary-core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cloudinary-core/cloudinary-core.js":
/*!*********************************************************!*\
  !*** ./node_modules/cloudinary-core/cloudinary-core.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n   * cloudinary-core.js\n   * Cloudinary's JavaScript library - Version 2.13.0\n   * Copyright Cloudinary\n   * see https://github.com/cloudinary/cloudinary_js\n   *\n   */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! lodash/assign */ \"lodash/assign\"), __webpack_require__(/*! lodash/cloneDeep */ \"lodash/cloneDeep\"), __webpack_require__(/*! lodash/compact */ \"lodash/compact\"), __webpack_require__(/*! lodash/difference */ \"lodash/difference\"), __webpack_require__(/*! lodash/functions */ \"lodash/functions\"), __webpack_require__(/*! lodash/identity */ \"lodash/identity\"), __webpack_require__(/*! lodash/includes */ \"lodash/includes\"), __webpack_require__(/*! lodash/isArray */ \"lodash/isArray\"), __webpack_require__(/*! lodash/isElement */ \"lodash/isElement\"), __webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"), __webpack_require__(/*! lodash/isPlainObject */ \"lodash/isPlainObject\"), __webpack_require__(/*! lodash/isString */ \"lodash/isString\"), __webpack_require__(/*! lodash/merge */ \"lodash/merge\"), __webpack_require__(/*! lodash/trim */ \"lodash/trim\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_lodash_assign__, __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__, __WEBPACK_EXTERNAL_MODULE_lodash_compact__, __WEBPACK_EXTERNAL_MODULE_lodash_difference__, __WEBPACK_EXTERNAL_MODULE_lodash_functions__, __WEBPACK_EXTERNAL_MODULE_lodash_identity__, __WEBPACK_EXTERNAL_MODULE_lodash_includes__, __WEBPACK_EXTERNAL_MODULE_lodash_isArray__, __WEBPACK_EXTERNAL_MODULE_lodash_isElement__, __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__, __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__, __WEBPACK_EXTERNAL_MODULE_lodash_isString__, __WEBPACK_EXTERNAL_MODULE_lodash_merge__, __WEBPACK_EXTERNAL_MODULE_lodash_trim__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_2864__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_2864__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_2864__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_2864__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_2864__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_2864__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_2864__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_2864__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_2864__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_2864__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_2864__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_2864__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_2864__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_2864__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_2864__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_2864__(__nested_webpack_require_2864__.s = \"./src/namespace/cloudinary-core.js\");\n    /******/ }({\n        /***/ \"./src/namespace/cloudinary-core.js\": /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_7160__) {\n            \"use strict\";\n            // ESM COMPAT FLAG\n            __nested_webpack_require_7160__.r(__nested_webpack_exports__);\n            // EXPORTS\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ClientHintsMetaTag\", function() {\n                return /* reexport */ clienthintsmetatag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Cloudinary\", function() {\n                return /* reexport */ cloudinary;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Condition\", function() {\n                return /* reexport */ condition;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Configuration\", function() {\n                return /* reexport */ src_configuration;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"crc32\", function() {\n                return /* reexport */ src_crc32;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Expression\", function() {\n                return /* reexport */ expression;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"FetchLayer\", function() {\n                return /* reexport */ fetchlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"HtmlTag\", function() {\n                return /* reexport */ htmltag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ImageTag\", function() {\n                return /* reexport */ imagetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Layer\", function() {\n                return /* reexport */ layer_layer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"PictureTag\", function() {\n                return /* reexport */ picturetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"SubtitlesLayer\", function() {\n                return /* reexport */ subtitleslayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"TextLayer\", function() {\n                return /* reexport */ textlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Transformation\", function() {\n                return /* reexport */ src_transformation;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"utf8_encode\", function() {\n                return /* reexport */ src_utf8_encode;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Util\", function() {\n                return /* reexport */ lodash_namespaceObject;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"VideoTag\", function() {\n                return /* reexport */ videotag;\n            });\n            // NAMESPACE OBJECT: ./src/constants.js\n            var constants_namespaceObject = {};\n            __nested_webpack_require_7160__.r(constants_namespaceObject);\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"VERSION\", function() {\n                return VERSION;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"CF_SHARED_CDN\", function() {\n                return CF_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"OLD_AKAMAI_SHARED_CDN\", function() {\n                return OLD_AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"AKAMAI_SHARED_CDN\", function() {\n                return AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SHARED_CDN\", function() {\n                return SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_TIMEOUT_MS\", function() {\n                return DEFAULT_TIMEOUT_MS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_POSTER_OPTIONS\", function() {\n                return DEFAULT_POSTER_OPTIONS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCE_TYPES\", function() {\n                return DEFAULT_VIDEO_SOURCE_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SEO_TYPES\", function() {\n                return SEO_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_IMAGE_PARAMS\", function() {\n                return DEFAULT_IMAGE_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_PARAMS\", function() {\n                return DEFAULT_VIDEO_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCES\", function() {\n                return DEFAULT_VIDEO_SOURCES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_EXTERNAL_LIBRARIES\", function() {\n                return DEFAULT_EXTERNAL_LIBRARIES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"PLACEHOLDER_IMAGE_MODES\", function() {\n                return PLACEHOLDER_IMAGE_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"ACCESSIBILITY_MODES\", function() {\n                return ACCESSIBILITY_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"URL_KEYS\", function() {\n                return URL_KEYS;\n            });\n            // NAMESPACE OBJECT: ./src/util/lodash.js\n            var lodash_namespaceObject = {};\n            __nested_webpack_require_7160__.r(lodash_namespaceObject);\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getSDKAnalyticsSignature\", function() {\n                return getSDKAnalyticsSignature;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAnalyticsOptions\", function() {\n                return getAnalyticsOptions;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"assign\", function() {\n                return assign_root_assign_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cloneDeep\", function() {\n                return cloneDeep_root_cloneDeep_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"compact\", function() {\n                return compact_root_compact_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"difference\", function() {\n                return difference_root_difference_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"functions\", function() {\n                return functions_root_functions_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"identity\", function() {\n                return identity_root_identity_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"includes\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isArray\", function() {\n                return isArray_root_isArray_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isPlainObject\", function() {\n                return isPlainObject_root_isPlainObject_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isString\", function() {\n                return isString_root_isString_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"merge\", function() {\n                return merge_root_merge_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"contains\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isIntersectionObserverSupported\", function() {\n                return isIntersectionObserverSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNativeLazyLoadSupported\", function() {\n                return isNativeLazyLoadSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"detectIntersection\", function() {\n                return detectIntersection;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"omit\", function() {\n                return omit;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"allStrings\", function() {\n                return baseutil_allStrings;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"without\", function() {\n                return without;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNumberLike\", function() {\n                return isNumberLike;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"smartEscape\", function() {\n                return smartEscape;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"defaults\", function() {\n                return defaults;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objectProto\", function() {\n                return objectProto;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objToString\", function() {\n                return objToString;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isObject\", function() {\n                return isObject;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"funcTag\", function() {\n                return funcTag;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"reWords\", function() {\n                return reWords;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"camelCase\", function() {\n                return camelCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"snakeCase\", function() {\n                return snakeCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"convertKeys\", function() {\n                return convertKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withCamelCaseKeys\", function() {\n                return withCamelCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withSnakeCaseKeys\", function() {\n                return withSnakeCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64Encode\", function() {\n                return base64Encode;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64EncodeURL\", function() {\n                return base64EncodeURL;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"extractUrlParams\", function() {\n                return extractUrlParams;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"patchFetchFormat\", function() {\n                return patchFetchFormat;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"optionConsume\", function() {\n                return optionConsume;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEmpty\", function() {\n                return isEmpty;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isAndroid\", function() {\n                return isAndroid;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEdge\", function() {\n                return isEdge;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isChrome\", function() {\n                return isChrome;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isSafari\", function() {\n                return isSafari;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isElement\", function() {\n                return isElement_root_isElement_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isFunction\", function() {\n                return isFunction_root_isFunction_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"trim\", function() {\n                return trim_root_trim_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getData\", function() {\n                return lodash_getData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setData\", function() {\n                return lodash_setData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAttribute\", function() {\n                return lodash_getAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttribute\", function() {\n                return lodash_setAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"removeAttribute\", function() {\n                return lodash_removeAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttributes\", function() {\n                return setAttributes;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"hasClass\", function() {\n                return lodash_hasClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"addClass\", function() {\n                return lodash_addClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getStyles\", function() {\n                return getStyles;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssExpand\", function() {\n                return cssExpand;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"domStyle\", function() {\n                return domStyle;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"curCSS\", function() {\n                return curCSS;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssValue\", function() {\n                return cssValue;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"augmentWidthOrHeight\", function() {\n                return augmentWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getWidthOrHeight\", function() {\n                return getWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"width\", function() {\n                return lodash_width;\n            });\n            // CONCATENATED MODULE: ./src/utf8_encode.js\n            /**\n * UTF8 encoder\n * @private\n */ var utf8_encode;\n            /* harmony default export */ var src_utf8_encode = utf8_encode = function utf8_encode(argString) {\n                var c1, enc, end, n, start, string, stringl, utftext; // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n                // +   improved by: sowberry\n                // +    tweaked by: Jack\n                // +   bugfixed by: Onno Marsman\n                // +   improved by: Yves Sucaet\n                // +   bugfixed by: Onno Marsman\n                // +   bugfixed by: Ulrich\n                // +   bugfixed by: Rafal Kukawski\n                // +   improved by: kirilloid\n                // *     example 1: utf8_encode('Kevin van Zonneveld');\n                // *     returns 1: 'Kevin van Zonneveld'\n                if (argString === null || typeof argString === \"undefined\") {\n                    return \"\";\n                }\n                string = argString + \"\"; // .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                utftext = \"\";\n                start = void 0;\n                end = void 0;\n                stringl = 0;\n                start = end = 0;\n                stringl = string.length;\n                n = 0;\n                while(n < stringl){\n                    c1 = string.charCodeAt(n);\n                    enc = null;\n                    if (c1 < 128) {\n                        end++;\n                    } else if (c1 > 127 && c1 < 2048) {\n                        enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);\n                    } else {\n                        enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);\n                    }\n                    if (enc !== null) {\n                        if (end > start) {\n                            utftext += string.slice(start, end);\n                        }\n                        utftext += enc;\n                        start = end = n + 1;\n                    }\n                    n++;\n                }\n                if (end > start) {\n                    utftext += string.slice(start, stringl);\n                }\n                return utftext;\n            };\n            // CONCATENATED MODULE: ./src/crc32.js\n            /**\n * CRC32 calculator\n * Depends on 'utf8_encode'\n * @private\n * @param {string} str - The string to calculate the CRC32 for.\n * @return {number}\n */ function crc32(str) {\n                var crc, i, iTop, table, x, y; // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: T0bsn\n                // +   improved by: http://stackoverflow.com/questions/2647935/javascript-crc32-function-and-php-crc32-not-matching\n                // -    depends on: utf8_encode\n                // *     example 1: crc32('Kevin van Zonneveld');\n                // *     returns 1: 1249991249\n                str = src_utf8_encode(str);\n                table = \"00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D\";\n                crc = 0;\n                x = 0;\n                y = 0;\n                crc = crc ^ -1;\n                i = 0;\n                iTop = str.length;\n                while(i < iTop){\n                    y = (crc ^ str.charCodeAt(i)) & 0xFF;\n                    x = \"0x\" + table.substr(y * 9, 8);\n                    crc = crc >>> 8 ^ x;\n                    i++;\n                }\n                crc = crc ^ -1; //convert to unsigned 32-bit int if needed\n                if (crc < 0) {\n                    crc += 4294967296;\n                }\n                return crc;\n            }\n            /* harmony default export */ var src_crc32 = crc32;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/stringPad.js\n            function stringPad(value, targetLength, padString) {\n                targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\n                padString = String(typeof padString !== \"undefined\" ? padString : \" \");\n                if (value.length > targetLength) {\n                    return String(value);\n                } else {\n                    targetLength = targetLength - value.length;\n                    if (targetLength > padString.length) {\n                        padString += repeatStringNumTimes(padString, targetLength / padString.length);\n                    }\n                    return padString.slice(0, targetLength) + String(value);\n                }\n            }\n            function repeatStringNumTimes(string, times) {\n                var repeatedString = \"\";\n                while(times > 0){\n                    repeatedString += string;\n                    times--;\n                }\n                return repeatedString;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/base64Map.js\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            var base64Map_num = 0;\n            var map = {};\n            _toConsumableArray(chars).forEach(function(_char) {\n                var key = base64Map_num.toString(2);\n                key = stringPad(key, 6, \"0\");\n                map[key] = _char;\n                base64Map_num++;\n            });\n            /**\n * Map of six-bit binary codes to Base64 characters\n */ /* harmony default export */ var base64Map = map;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/reverseVersion.js\n            /**\n * @description A semVer like string, x.y.z or x.y is allowed\n *              Reverses the version positions, x.y.z turns to z.y.x\n *              Pads each segment with '0' so they have length of 2\n *              Example: 1.2.3 -> 03.02.01\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} in the form of zz.yy.xx (\n */ function reverseVersion(semVer) {\n                if (semVer.split(\".\").length < 2) {\n                    throw new Error(\"invalid semVer, must have at least two segments\");\n                } // Split by '.', reverse, create new array with padded values and concat it together\n                return semVer.split(\".\").reverse().map(function(segment) {\n                    return stringPad(segment, 2, \"0\");\n                }).join(\".\");\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/encodeVersion.js\n            /**\n * @description Encodes a semVer-like version string\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} A string built from 3 characters of the base64 table that encode the semVer\n */ function encodeVersion(semVer) {\n                var strResult = \"\"; // support x.y or x.y.z by using 'parts' as a variable\n                var parts = semVer.split(\".\").length;\n                var paddedStringLength = parts * 6; // we pad to either 12 or 18 characters\n                // reverse (but don't mirror) the version. 1.5.15 -> 15.5.1\n                // Pad to two spaces, 15.5.1 -> 15.05.01\n                var paddedReversedSemver = reverseVersion(semVer); // turn 15.05.01 to a string '150501' then to a number 150501\n                var num = parseInt(paddedReversedSemver.split(\".\").join(\"\")); // Represent as binary, add left padding to 12 or 18 characters.\n                // 150,501 -> 100100101111100101\n                var paddedBinary = num.toString(2);\n                paddedBinary = stringPad(paddedBinary, paddedStringLength, \"0\"); // Stop in case an invalid version number was provided\n                // paddedBinary must be built from sections of 6 bits\n                if (paddedBinary.length % 6 !== 0) {\n                    throw \"Version must be smaller than 43.21.26)\";\n                } // turn every 6 bits into a character using the base64Map\n                paddedBinary.match(/.{1,6}/g).forEach(function(bitString) {\n                    // console.log(bitString);\n                    strResult += base64Map[bitString];\n                });\n                return strResult;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getSDKAnalyticsSignature.js\n            /**\n * @description Gets the SDK signature by encoding the SDK version and tech version\n * @param {{\n *    [techVersion]:string,\n *    [sdkSemver]: string,\n *    [sdkCode]: string,\n *    [feature]: string\n * }} analyticsOptions\n * @return {string} sdkAnalyticsSignature\n */ function getSDKAnalyticsSignature() {\n                var analyticsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                try {\n                    var twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n                    var encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n                    var encodedTechVersion = encodeVersion(twoPartVersion);\n                    var featureCode = analyticsOptions.feature;\n                    var SDKCode = analyticsOptions.sdkCode;\n                    var algoVersion = \"A\"; // The algo version is determined here, it should not be an argument\n                    return \"\".concat(algoVersion).concat(SDKCode).concat(encodedSDKVersion).concat(encodedTechVersion).concat(featureCode);\n                } catch (e) {\n                    // Either SDK or Node versions were unparsable\n                    return \"E\";\n                }\n            }\n            /**\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' || 'x.y' || string} semVerStr\n */ function removePatchFromSemver(semVerStr) {\n                var parts = semVerStr.split(\".\");\n                return \"\".concat(parts[0], \".\").concat(parts[1]);\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getAnalyticsOptions.js\n            /**\n * @description Gets the analyticsOptions from options- should include sdkSemver, techVersion, sdkCode, and feature\n * @param options\n * @returns {{sdkSemver: (string), sdkCode, feature: string, techVersion: (string)} || {}}\n */ function getAnalyticsOptions(options) {\n                var analyticsOptions = {\n                    sdkSemver: options.sdkSemver,\n                    techVersion: options.techVersion,\n                    sdkCode: options.sdkCode,\n                    feature: \"0\"\n                };\n                if (options.urlAnalytics) {\n                    if (options.accessibility) {\n                        analyticsOptions.feature = \"D\";\n                    }\n                    if (options.loading === \"lazy\") {\n                        analyticsOptions.feature = \"C\";\n                    }\n                    if (options.responsive) {\n                        analyticsOptions.feature = \"A\";\n                    }\n                    if (options.placeholder) {\n                        analyticsOptions.feature = \"B\";\n                    }\n                    return analyticsOptions;\n                } else {\n                    return {};\n                }\n            }\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/assign\",\"commonjs2\":\"lodash/assign\",\"amd\":\"lodash/assign\",\"root\":[\"_\",\"assign\"]}\n            var assign_root_assign_ = __nested_webpack_require_7160__(\"lodash/assign\");\n            var assign_root_assign_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(assign_root_assign_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/cloneDeep\",\"commonjs2\":\"lodash/cloneDeep\",\"amd\":\"lodash/cloneDeep\",\"root\":[\"_\",\"cloneDeep\"]}\n            var cloneDeep_root_cloneDeep_ = __nested_webpack_require_7160__(\"lodash/cloneDeep\");\n            var cloneDeep_root_cloneDeep_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(cloneDeep_root_cloneDeep_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/compact\",\"commonjs2\":\"lodash/compact\",\"amd\":\"lodash/compact\",\"root\":[\"_\",\"compact\"]}\n            var compact_root_compact_ = __nested_webpack_require_7160__(\"lodash/compact\");\n            var compact_root_compact_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(compact_root_compact_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/difference\",\"commonjs2\":\"lodash/difference\",\"amd\":\"lodash/difference\",\"root\":[\"_\",\"difference\"]}\n            var difference_root_difference_ = __nested_webpack_require_7160__(\"lodash/difference\");\n            var difference_root_difference_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(difference_root_difference_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/functions\",\"commonjs2\":\"lodash/functions\",\"amd\":\"lodash/functions\",\"root\":[\"_\",\"functions\"]}\n            var functions_root_functions_ = __nested_webpack_require_7160__(\"lodash/functions\");\n            var functions_root_functions_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(functions_root_functions_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/identity\",\"commonjs2\":\"lodash/identity\",\"amd\":\"lodash/identity\",\"root\":[\"_\",\"identity\"]}\n            var identity_root_identity_ = __nested_webpack_require_7160__(\"lodash/identity\");\n            var identity_root_identity_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(identity_root_identity_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/includes\",\"commonjs2\":\"lodash/includes\",\"amd\":\"lodash/includes\",\"root\":[\"_\",\"includes\"]}\n            var includes_root_includes_ = __nested_webpack_require_7160__(\"lodash/includes\");\n            var includes_root_includes_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(includes_root_includes_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isArray\",\"commonjs2\":\"lodash/isArray\",\"amd\":\"lodash/isArray\",\"root\":[\"_\",\"isArray\"]}\n            var isArray_root_isArray_ = __nested_webpack_require_7160__(\"lodash/isArray\");\n            var isArray_root_isArray_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isArray_root_isArray_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isPlainObject\",\"commonjs2\":\"lodash/isPlainObject\",\"amd\":\"lodash/isPlainObject\",\"root\":[\"_\",\"isPlainObject\"]}\n            var isPlainObject_root_isPlainObject_ = __nested_webpack_require_7160__(\"lodash/isPlainObject\");\n            var isPlainObject_root_isPlainObject_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isPlainObject_root_isPlainObject_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isString\",\"commonjs2\":\"lodash/isString\",\"amd\":\"lodash/isString\",\"root\":[\"_\",\"isString\"]}\n            var isString_root_isString_ = __nested_webpack_require_7160__(\"lodash/isString\");\n            var isString_root_isString_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isString_root_isString_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/merge\",\"commonjs2\":\"lodash/merge\",\"amd\":\"lodash/merge\",\"root\":[\"_\",\"merge\"]}\n            var merge_root_merge_ = __nested_webpack_require_7160__(\"lodash/merge\");\n            var merge_root_merge_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(merge_root_merge_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isElement\",\"commonjs2\":\"lodash/isElement\",\"amd\":\"lodash/isElement\",\"root\":[\"_\",\"isElement\"]}\n            var isElement_root_isElement_ = __nested_webpack_require_7160__(\"lodash/isElement\");\n            var isElement_root_isElement_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isElement_root_isElement_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isFunction\",\"commonjs2\":\"lodash/isFunction\",\"amd\":\"lodash/isFunction\",\"root\":[\"_\",\"isFunction\"]}\n            var isFunction_root_isFunction_ = __nested_webpack_require_7160__(\"lodash/isFunction\");\n            var isFunction_root_isFunction_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isFunction_root_isFunction_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/trim\",\"commonjs2\":\"lodash/trim\",\"amd\":\"lodash/trim\",\"root\":[\"_\",\"trim\"]}\n            var trim_root_trim_ = __nested_webpack_require_7160__(\"lodash/trim\");\n            var trim_root_trim_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(trim_root_trim_);\n            // CONCATENATED MODULE: ./src/util/lazyLoad.js\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, _typeof(obj);\n            }\n            /*\n * Includes utility methods for lazy loading media\n */ /**\n * Check if IntersectionObserver is supported\n * @return {boolean} true if window.IntersectionObserver is defined\n */ function isIntersectionObserverSupported() {\n                // Check that 'IntersectionObserver' property is defined on window\n                return  false && 0;\n            }\n            /**\n * Check if native lazy loading is supported\n * @return {boolean} true if 'loading' property is defined for HTMLImageElement\n */ function isNativeLazyLoadSupported() {\n                return (typeof HTMLImageElement === \"undefined\" ? \"undefined\" : _typeof(HTMLImageElement)) === \"object\" && HTMLImageElement.prototype.loading;\n            }\n            /**\n * Calls onIntersect() when intersection is detected, or when\n * no native lazy loading or when IntersectionObserver isn't supported.\n * @param {Element} el - the element to observe\n * @param {function} onIntersect - called when the given element is in view\n */ function detectIntersection(el, onIntersect) {\n                try {\n                    if (isNativeLazyLoadSupported() || !isIntersectionObserverSupported()) {\n                        // Return if there's no need or possibility to detect intersection\n                        onIntersect();\n                        return;\n                    } // Detect intersection with given element using IntersectionObserver\n                    var observer = new IntersectionObserver(function(entries) {\n                        entries.forEach(function(entry) {\n                            if (entry.isIntersecting) {\n                                onIntersect();\n                                observer.unobserve(entry.target);\n                            }\n                        });\n                    }, {\n                        threshold: [\n                            0,\n                            0.01\n                        ]\n                    });\n                    observer.observe(el);\n                } catch (e) {\n                    onIntersect();\n                }\n            }\n            // CONCATENATED MODULE: ./src/constants.js\n            var VERSION = \"2.5.0\";\n            var CF_SHARED_CDN = \"d3jpl91pxevbkh.cloudfront.net\";\n            var OLD_AKAMAI_SHARED_CDN = \"cloudinary-a.akamaihd.net\";\n            var AKAMAI_SHARED_CDN = \"res.cloudinary.com\";\n            var SHARED_CDN = AKAMAI_SHARED_CDN;\n            var DEFAULT_TIMEOUT_MS = 10000;\n            var DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            var DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var SEO_TYPES = {\n                \"image/upload\": \"images\",\n                \"image/private\": \"private_images\",\n                \"image/authenticated\": \"authenticated_images\",\n                \"raw/upload\": \"files\",\n                \"video/upload\": \"videos\"\n            };\n            /**\n* @const {Object} Cloudinary.DEFAULT_IMAGE_PARAMS\n* Defaults values for image parameters.\n*\n* (Previously defined using option_consume() )\n */ var DEFAULT_IMAGE_PARAMS = {\n                resource_type: \"image\",\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n* Defaults values for video parameters.\n* @const {Object} Cloudinary.DEFAULT_VIDEO_PARAMS\n* (Previously defined using option_consume() )\n */ var DEFAULT_VIDEO_PARAMS = {\n                fallback_content: \"\",\n                resource_type: \"video\",\n                source_transformation: {},\n                source_types: DEFAULT_VIDEO_SOURCE_TYPES,\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n * Recommended sources for video tag\n * @const {Object} Cloudinary.DEFAULT_VIDEO_SOURCES\n */ var DEFAULT_VIDEO_SOURCES = [\n                {\n                    type: \"mp4\",\n                    codecs: \"hev1\",\n                    transformations: {\n                        video_codec: \"h265\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    codecs: \"vp9\",\n                    transformations: {\n                        video_codec: \"vp9\"\n                    }\n                },\n                {\n                    type: \"mp4\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                }\n            ];\n            var DEFAULT_EXTERNAL_LIBRARIES = {\n                seeThru: \"https://unpkg.com/seethru@4/dist/seeThru.min.js\"\n            };\n            /**\n * Predefined placeholder transformations\n * @const {Object} Cloudinary.PLACEHOLDER_IMAGE_MODES\n */ var PLACEHOLDER_IMAGE_MODES = {\n                \"blur\": [\n                    {\n                        effect: \"blur:2000\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Default\n                \"pixelate\": [\n                    {\n                        effect: \"pixelate\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Generates a pixel size image which color is the predominant color of the original image.\n                \"predominant-color-pixel\": [\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 1,\n                        height: 1,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                // Generates an image which color is the predominant color of the original image.\n                \"predominant-color\": [\n                    {\n                        variables: [\n                            [\n                                \"$currWidth\",\n                                \"w\"\n                            ],\n                            [\n                                \"$currHeight\",\n                                \"h\"\n                            ]\n                        ]\n                    },\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 10,\n                        height: 10,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        width: \"$currWidth\",\n                        height: \"$currHeight\",\n                        crop: \"fill\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                \"vectorize\": [\n                    {\n                        effect: \"vectorize:3:0.1\",\n                        fetch_format: \"svg\"\n                    }\n                ]\n            };\n            /**\n * Predefined accessibility transformations\n * @const {Object} Cloudinary.ACCESSIBILITY_MODES\n */ var ACCESSIBILITY_MODES = {\n                darkmode: \"tint:75:black\",\n                brightmode: \"tint:50:white\",\n                monochrome: \"grayscale\",\n                colorblind: \"assist_colorblind\"\n            };\n            /**\n * A list of keys used by the url() function.\n * @private\n */ var URL_KEYS = [\n                \"accessibility\",\n                \"api_secret\",\n                \"auth_token\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"format\",\n                \"placeholder\",\n                \"private_cdn\",\n                \"resource_type\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"sign_url\",\n                \"signature\",\n                \"ssl_detected\",\n                \"type\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\"\n            ];\n            /**\n * The resource storage type\n * @typedef type\n * @enum {string}\n * @property  {string} 'upload' A resource uploaded directly to Cloudinary\n * @property  {string} 'fetch' A resource fetched by Cloudinary from a 3rd party storage\n * @property  {string} 'private'\n * @property  {string} 'authenticated'\n * @property  {string} 'sprite'\n * @property  {string} 'facebook'\n * @property  {string} 'twitter'\n * @property  {string} 'youtube'\n * @property  {string} 'vimeo'\n *\n */ /**\n * The resource type\n * @typedef resourceType\n * @enum {string}\n * @property {string} 'image' An image file\n * @property {string} 'video' A video file\n * @property {string} 'raw'   A raw file\n */ // CONCATENATED MODULE: ./src/util/baseutil.js\n            function baseutil_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return baseutil_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, baseutil_typeof(obj);\n            }\n            /*\n * Includes common utility methods and shims\n */ function omit(obj, keys) {\n                obj = obj || {};\n                var srcKeys = Object.keys(obj).filter(function(key) {\n                    return !includes_root_includes_default()(keys, key);\n                });\n                var filtered = {};\n                srcKeys.forEach(function(key) {\n                    return filtered[key] = obj[key];\n                });\n                return filtered;\n            }\n            /**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */ var baseutil_allStrings = function allStrings(list) {\n                return list.length && list.every(isString_root_isString_default.a);\n            };\n            /**\n* Creates a new array without the given item.\n* @function Util.without\n* @param {Array} array - original array\n* @param {*} item - the item to exclude from the new array\n* @return {Array} a new array made of the original array's items except for `item`\n */ var without = function without(array, item) {\n                return array.filter(function(v) {\n                    return v !== item;\n                });\n            };\n            /**\n* Return true is value is a number or a string representation of a number.\n* @function Util.isNumberLike\n* @param {*} value\n* @returns {boolean} true if value is a number\n* @example\n*    Util.isNumber(0) // true\n*    Util.isNumber(\"1.3\") // true\n*    Util.isNumber(\"\") // false\n*    Util.isNumber(undefined) // false\n */ var isNumberLike = function isNumberLike(value) {\n                return value != null && !isNaN(parseFloat(value));\n            };\n            /**\n * Escape all characters matching unsafe in the given string\n * @function Util.smartEscape\n * @param {string} string - source string to escape\n * @param {RegExp} unsafe - characters that must be escaped\n * @return {string} escaped string\n */ var smartEscape = function smartEscape(string) {\n                var unsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /([^a-zA-Z0-9_.\\-\\/:]+)/g;\n                return string.replace(unsafe, function(match) {\n                    return match.split(\"\").map(function(c) {\n                        return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n                    }).join(\"\");\n                });\n            };\n            /**\n * Assign values from sources if they are not defined in the destination.\n * Once a value is set it does not change\n * @function Util.defaults\n * @param {Object} destination - the object to assign defaults to\n * @param {...Object} source - the source object(s) to assign defaults from\n * @return {Object} destination after it was modified\n */ var defaults = function defaults(destination) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                return sources.reduce(function(dest, source) {\n                    var key, value;\n                    for(key in source){\n                        value = source[key];\n                        if (dest[key] === void 0) {\n                            dest[key] = value;\n                        }\n                    }\n                    return dest;\n                }, destination);\n            };\n            /*********** lodash functions */ var objectProto = Object.prototype;\n            /**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */ var objToString = objectProto.toString;\n            /**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n#isObject({});\n * // => true\n *\n#isObject([1, 2, 3]);\n * // => true\n *\n#isObject(1);\n * // => false\n */ var isObject = function isObject(value) {\n                var type; // Avoid a V8 JIT bug in Chrome 19-20.\n                // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n                type = baseutil_typeof(value);\n                return !!value && (type === \"object\" || type === \"function\");\n            };\n            var funcTag = \"[object Function]\";\n            /**\n* Checks if `value` is classified as a `Function` object.\n* @function Util.isFunction\n* @param {*} value The value to check.\n* @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n* @example\n*\n* function Foo(){};\n* isFunction(Foo);\n* // => true\n*\n* isFunction(/abc/);\n* // => false\n */ var isFunction = function isFunction(value) {\n                // The use of `Object#toString` avoids issues with the `typeof` operator\n                // in older versions of Chrome and Safari which return 'function' for regexes\n                // and Safari 8 which returns 'object' for typed array constructors.\n                return isObject(value) && objToString.call(value) === funcTag;\n            };\n            /*********** lodash functions */ /** Used to match words to create compound words. */ var reWords = function() {\n                var lower, upper;\n                upper = \"[A-Z]\";\n                lower = \"[a-z]+\";\n                return RegExp(upper + \"+(?=\" + upper + lower + \")|\" + upper + \"?\" + lower + \"|\" + upper + \"+|[0-9]+\", \"g\");\n            }();\n            /**\n* Convert string to camelCase\n* @function Util.camelCase\n* @param {string} source - the string to convert\n* @return {string} in camelCase format\n */ var camelCase = function camelCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.charAt(0).toLocaleUpperCase() + word.slice(1).toLocaleLowerCase();\n                });\n                words[0] = words[0].toLocaleLowerCase();\n                return words.join(\"\");\n            };\n            /**\n * Convert string to snake_case\n * @function Util.snakeCase\n * @param {string} source - the string to convert\n * @return {string} in snake_case format\n */ var snakeCase = function snakeCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.toLocaleLowerCase();\n                });\n                return words.join(\"_\");\n            };\n            /**\n * Creates a new object from source, with the keys transformed using the converter.\n * @param {object} source\n * @param {function|null} converter\n * @returns {object}\n */ var convertKeys = function convertKeys(source, converter) {\n                var result, value;\n                result = {};\n                for(var key in source){\n                    value = source[key];\n                    if (converter) {\n                        key = converter(key);\n                    }\n                    if (!isEmpty(key)) {\n                        result[key] = value;\n                    }\n                }\n                return result;\n            };\n            /**\n * Create a copy of the source object with all keys in camelCase\n * @function Util.withCamelCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withCamelCaseKeys = function withCamelCaseKeys(source) {\n                return convertKeys(source, camelCase);\n            };\n            /**\n * Create a copy of the source object with all keys in snake_case\n * @function Util.withSnakeCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withSnakeCaseKeys = function withSnakeCaseKeys(source) {\n                return convertKeys(source, snakeCase);\n            }; // Browser\n            // Node.js\n            var base64Encode = typeof btoa !== \"undefined\" && isFunction(btoa) ? btoa : typeof Buffer !== \"undefined\" && isFunction(Buffer) ? function(input) {\n                if (!(input instanceof Buffer)) {\n                    input = new Buffer.from(String(input), \"binary\");\n                }\n                return input.toString(\"base64\");\n            } : function(input) {\n                throw new Error(\"No base64 encoding function found\");\n            };\n            /**\n* Returns the Base64-decoded version of url.<br>\n* This method delegates to `btoa` if present. Otherwise it tries `Buffer`.\n* @function Util.base64EncodeURL\n* @param {string} url - the url to encode. the value is URIdecoded and then re-encoded before converting to base64 representation\n* @return {string} the base64 representation of the URL\n */ var base64EncodeURL = function base64EncodeURL(url) {\n                try {\n                    url = decodeURI(url);\n                } finally{\n                    url = encodeURI(url);\n                }\n                return base64Encode(url);\n            };\n            /**\n * Create a new object with only URL parameters\n * @param {object} options The source object\n * @return {Object} An object containing only URL parameters\n */ function extractUrlParams(options) {\n                return URL_KEYS.reduce(function(obj, key) {\n                    if (options[key] != null) {\n                        obj[key] = options[key];\n                    }\n                    return obj;\n                }, {});\n            }\n            /**\n * Handle the format parameter for fetch urls\n * @private\n * @param options url and transformation options. This argument may be changed by the function!\n */ function patchFetchFormat(options) {\n                if (options == null) {\n                    options = {};\n                }\n                if (options.type === \"fetch\") {\n                    if (options.fetch_format == null) {\n                        options.fetch_format = optionConsume(options, \"format\");\n                    }\n                }\n            }\n            /**\n * Deletes `option_name` from `options` and return the value if present.\n * If `options` doesn't contain `option_name` the default value is returned.\n * @param {Object} options a collection\n * @param {String} option_name the name (key) of the desired value\n * @param {*} [default_value] the value to return is option_name is missing\n */ function optionConsume(options, option_name, default_value) {\n                var result = options[option_name];\n                delete options[option_name];\n                if (result != null) {\n                    return result;\n                } else {\n                    return default_value;\n                }\n            }\n            /**\n * Returns true if value is empty:\n * <ul>\n *   <li>value is null or undefined</li>\n *   <li>value is an array or string of length 0</li>\n *   <li>value is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param value\n * @returns {boolean} true if value is empty\n */ function isEmpty(value) {\n                if (value == null) {\n                    return true;\n                }\n                if (typeof value.length == \"number\") {\n                    return value.length === 0;\n                }\n                if (typeof value.size == \"number\") {\n                    return value.size === 0;\n                }\n                if (baseutil_typeof(value) == \"object\") {\n                    for(var key in value){\n                        if (value.hasOwnProperty(key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return true;\n            }\n            // CONCATENATED MODULE: ./src/util/browser.js\n            /**\n * Based on video.js implementation:\n * https://github.com/videojs/video.js/blob/4238f5c1d88890547153e7e1de7bd0d1d8e0b236/src/js/utils/browser.js\n */ /**\n* Retrieve from the navigator the user agent property.\n* @returns user agent property.\n*/ function getUserAgent() {\n                return navigator && navigator.userAgent || \"\";\n            }\n            /**\n * Detect if current browser is any Android\n * @returns true if current browser is Android, false otherwise.\n */ function isAndroid() {\n                var userAgent = getUserAgent();\n                return /Android/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is any Edge\n * @returns true if current browser is Edge, false otherwise.\n */ function isEdge() {\n                var userAgent = getUserAgent();\n                return /Edg/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is chrome.\n * @returns true if current browser is Chrome, false otherwise.\n */ function isChrome() {\n                var userAgent = getUserAgent();\n                return !isEdge() && (/Chrome/i.test(userAgent) || /CriOS/i.test(userAgent));\n            }\n            /**\n * Detect if current browser is Safari.\n * @returns true if current browser is Safari, false otherwise.\n */ function isSafari() {\n                // User agents for other browsers might include \"Safari\" so we must exclude them.\n                // For example - this is the chrome user agent on windows 10:\n                // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\n                var userAgent = getUserAgent();\n                return /Safari/i.test(userAgent) && !isChrome() && !isAndroid() && !isEdge();\n            }\n            // CONCATENATED MODULE: ./src/util/lodash.js\n            var nodeContains;\n            /*\n * Includes utility methods and lodash / jQuery shims\n */ /**\n * Get data from the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will get the `data-` attribute\n * @param {Element} element - the element to get the data from\n * @param {string} name - the name of the data item\n * @returns the value associated with the `name`\n * @function Util.getData\n */ var lodash_getData = function getData(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name);\n                }\n            };\n            /**\n * Set data in the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will set the `data-` attribute\n * @function Util.setData\n * @param {Element} element - the element to set the data in\n * @param {string} name - the name of the data item\n * @param {*} value - the value to be set\n *\n */ var lodash_setData = function setData(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name, value);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name, value);\n                }\n            };\n            /**\n * Get attribute from the DOM element.\n *\n * @function Util.getAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @returns {*} the value of the attribute\n *\n */ var lodash_getAttribute = function getAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(name);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name);\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(name);\n                }\n            };\n            /**\n * Set attribute in the DOM element.\n *\n * @function Util.setAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @param {*} value - the value to be set\n */ var lodash_setAttribute = function setAttribute(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(name, value);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name, value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(name, value);\n                }\n            };\n            /**\n * Remove an attribute in the DOM element.\n *\n * @function Util.removeAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n */ var lodash_removeAttribute = function removeAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.removeAttribute):\n                        return element.removeAttribute(name);\n                    default:\n                        return lodash_setAttribute(element, void 0);\n                }\n            };\n            /**\n * Set a group of attributes to the element\n * @function Util.setAttributes\n * @param {Element} element - the element to set the attributes for\n * @param {Object} attributes - a hash of attribute names and values\n */ var setAttributes = function setAttributes(element, attributes) {\n                var name, results, value;\n                results = [];\n                for(name in attributes){\n                    value = attributes[name];\n                    if (value != null) {\n                        results.push(lodash_setAttribute(element, name, value));\n                    } else {\n                        results.push(lodash_removeAttribute(element, name));\n                    }\n                }\n                return results;\n            };\n            /**\n * Checks if element has a css class\n * @function Util.hasClass\n * @param {Element} element - the element to check\n * @param {string} name - the class name\n @returns {boolean} true if the element has the class\n */ var lodash_hasClass = function hasClass(element, name) {\n                if (isElement_root_isElement_default()(element)) {\n                    return element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")));\n                }\n            };\n            /**\n * Add class to the element\n * @function Util.addClass\n * @param {Element} element - the element\n * @param {string} name - the class name to add\n */ var lodash_addClass = function addClass(element, name) {\n                if (!element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")))) {\n                    return element.className = trim_root_trim_default()(\"\".concat(element.className, \" \").concat(name));\n                }\n            }; // The following code is taken from jQuery\n            var getStyles = function getStyles(elem) {\n                // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n                // IE throws on elements created in popups\n                // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n                if (elem.ownerDocument.defaultView.opener) {\n                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n                }\n                return window.getComputedStyle(elem, null);\n            };\n            var cssExpand = [\n                \"Top\",\n                \"Right\",\n                \"Bottom\",\n                \"Left\"\n            ];\n            nodeContains = function nodeContains(a, b) {\n                var adown, bup;\n                adown = a.nodeType === 9 ? a.documentElement : a;\n                bup = b && b.parentNode;\n                return a === bup || !!(bup && bup.nodeType === 1 && adown.contains(bup));\n            }; // Truncated version of jQuery.style(elem, name)\n            var domStyle = function domStyle(elem, name) {\n                if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n                    return elem.style[name];\n                }\n            };\n            var curCSS = function curCSS(elem, name, computed) {\n                var maxWidth, minWidth, ret, rmargin, style, width;\n                rmargin = /^margin/;\n                width = void 0;\n                minWidth = void 0;\n                maxWidth = void 0;\n                ret = void 0;\n                style = elem.style;\n                computed = computed || getStyles(elem);\n                if (computed) {\n                    // Support: IE9\n                    // getPropertyValue is only needed for .css('filter') (#12537)\n                    ret = computed.getPropertyValue(name) || computed[name];\n                }\n                if (computed) {\n                    if (ret === \"\" && !nodeContains(elem.ownerDocument, elem)) {\n                        ret = domStyle(elem, name);\n                    } // Support: iOS < 6\n                    // A tribute to the \"awesome hack by Dean Edwards\"\n                    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n                    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n                    if (rnumnonpx.test(ret) && rmargin.test(name)) {\n                        // Remember the original values\n                        width = style.width;\n                        minWidth = style.minWidth;\n                        maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n                        style.minWidth = style.maxWidth = style.width = ret;\n                        ret = computed.width; // Revert the changed values\n                        style.width = width;\n                        style.minWidth = minWidth;\n                        style.maxWidth = maxWidth;\n                    }\n                } // Support: IE\n                // IE returns zIndex value as an integer.\n                if (ret !== undefined) {\n                    return ret + \"\";\n                } else {\n                    return ret;\n                }\n            };\n            var cssValue = function cssValue(elem, name, convert, styles) {\n                var val;\n                val = curCSS(elem, name, styles);\n                if (convert) {\n                    return parseFloat(val);\n                } else {\n                    return val;\n                }\n            };\n            var augmentWidthOrHeight = function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n                var i, len, side, sides, val; // If we already have the right measurement, avoid augmentation\n                // Otherwise initialize for horizontal or vertical properties\n                if (extra === (isBorderBox ? \"border\" : \"content\")) {\n                    return 0;\n                } else {\n                    sides = name === \"width\" ? [\n                        \"Right\",\n                        \"Left\"\n                    ] : [\n                        \"Top\",\n                        \"Bottom\"\n                    ];\n                    val = 0;\n                    for(i = 0, len = sides.length; i < len; i++){\n                        side = sides[i];\n                        if (extra === \"margin\") {\n                            // Both box models exclude margin, so add it if we want it\n                            val += cssValue(elem, extra + side, true, styles);\n                        }\n                        if (isBorderBox) {\n                            if (extra === \"content\") {\n                                // border-box includes padding, so remove it if we want content\n                                val -= cssValue(elem, \"padding\".concat(side), true, styles);\n                            }\n                            if (extra !== \"margin\") {\n                                // At this point, extra isn't border nor margin, so remove border\n                                val -= cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        } else {\n                            // At this point, extra isn't content, so add padding\n                            val += cssValue(elem, \"padding\".concat(side), true, styles);\n                            if (extra !== \"padding\") {\n                                // At this point, extra isn't content nor padding, so add border\n                                val += cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        }\n                    }\n                    return val;\n                }\n            };\n            var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n            var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n            var getWidthOrHeight = function getWidthOrHeight(elem, name, extra) {\n                var isBorderBox, styles, val, valueIsBorderBox; // Start with offset property, which is equivalent to the border-box value\n                valueIsBorderBox = true;\n                val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight;\n                styles = getStyles(elem);\n                isBorderBox = cssValue(elem, \"boxSizing\", false, styles) === \"border-box\"; // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n                if (val <= 0 || val == null) {\n                    // Fall back to computed then uncomputed css if necessary\n                    val = curCSS(elem, name, styles);\n                    if (val < 0 || val == null) {\n                        val = elem.style[name];\n                    }\n                    if (rnumnonpx.test(val)) {\n                        // Computed unit is not pixels. Stop here and return.\n                        return val;\n                    } // Check for style in case a browser which returns unreliable values\n                    // for getComputedStyle silently falls back to the reliable elem.style\n                    //    valueIsBorderBox = isBorderBox and (support.boxSizingReliable() or val is elem.style[name])\n                    valueIsBorderBox = isBorderBox && val === elem.style[name]; // Normalize \"\", auto, and prepare for extra\n                    val = parseFloat(val) || 0;\n                } // Use the active box-sizing model to add/subtract irrelevant styles\n                return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles);\n            };\n            var lodash_width = function width(element) {\n                return getWidthOrHeight(element, \"width\", \"content\");\n            };\n            /**\n * @class Util\n */ /**\n * Returns true if item is a string\n * @function Util.isString\n * @param item\n * @returns {boolean} true if item is a string\n */ /**\n * Returns true if item is empty:\n * <ul>\n *   <li>item is null or undefined</li>\n *   <li>item is an array or string of length 0</li>\n *   <li>item is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param item\n * @returns {boolean} true if item is empty\n */ /**\n * Assign source properties to destination.\n * If the property is an object it is assigned as a whole, overriding the destination object.\n * @function Util.assign\n * @param {Object} destination - the object to assign to\n */ /**\n * Recursively assign source properties to destination\n * @function Util.merge\n * @param {Object} destination - the object to assign to\n * @param {...Object} [sources] The source objects.\n */ /**\n * Create a new copy of the given object, including all internal objects.\n * @function Util.cloneDeep\n * @param {Object} value - the object to clone\n * @return {Object} a new deep copy of the object\n */ /**\n * Creates a new array from the parameter with \"falsey\" values removed\n * @function Util.compact\n * @param {Array} array - the array to remove values from\n * @return {Array} a new array without falsey values\n */ /**\n * Check if a given item is included in the given array\n * @function Util.contains\n * @param {Array} array - the array to search in\n * @param {*} item - the item to search for\n * @return {boolean} true if the item is included in the array\n */ /**\n * Returns values in the given array that are not included in the other array\n * @function Util.difference\n * @param {Array} arr - the array to select from\n * @param {Array} values - values to filter from arr\n * @return {Array} the filtered values\n */ /**\n * Returns a list of all the function names in obj\n * @function Util.functions\n * @param {Object} object - the object to inspect\n * @return {Array} a list of functions of object\n */ /**\n * Returns the provided value. This functions is used as a default predicate function.\n * @function Util.identity\n * @param {*} value\n * @return {*} the provided value\n */ /**\n * Remove leading or trailing spaces from text\n * @function Util.trim\n * @param {string} text\n * @return {string} the `text` without leading or trailing spaces\n */ // CONCATENATED MODULE: ./src/expression.js\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Represents a transformation expression.\n * @param {string} expressionStr - An expression in string format.\n * @class Expression\n * Normally this class is not instantiated directly\n */ var Expression = /*#__PURE__*/ function() {\n                function Expression(expressionStr) {\n                    _classCallCheck(this, Expression);\n                    /**\n     * @protected\n     * @inner Expression-expressions\n     */ this.expressions = [];\n                    if (expressionStr != null) {\n                        this.expressions.push(Expression.normalize(expressionStr));\n                    }\n                }\n                /**\n   * Convenience constructor method\n   * @function Expression.new\n   */ _createClass(Expression, [\n                    {\n                        key: \"serialize\",\n                        value: /**\n     * Serialize the expression\n     * @return {string} the expression as a string\n     */ function serialize() {\n                            return Expression.normalize(this.expressions.join(\"_\"));\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"getParent\",\n                        value: function getParent() {\n                            return this.parent;\n                        }\n                    },\n                    {\n                        key: \"setParent\",\n                        value: function setParent(parent) {\n                            this.parent = parent;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"predicate\",\n                        value: function predicate(name, operator, value) {\n                            if (Expression.OPERATORS[operator] != null) {\n                                operator = Expression.OPERATORS[operator];\n                            }\n                            this.expressions.push(\"\".concat(name, \"_\").concat(operator, \"_\").concat(value));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"and\",\n                        value: function and() {\n                            this.expressions.push(\"and\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"or\",\n                        value: function or() {\n                            this.expressions.push(\"or\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"then\",\n                        value: function then() {\n                            return this.getParent()[\"if\"](this.toString());\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(_value) {\n                            this.expressions.push(_value);\n                            return this;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(expressionStr) {\n                            return new this(expressionStr);\n                        }\n                    },\n                    {\n                        key: \"normalize\",\n                        value: function normalize(expression) {\n                            if (expression == null) {\n                                return expression;\n                            }\n                            expression = String(expression);\n                            var operators = \"\\\\|\\\\||>=|<=|&&|!=|>|=|<|/|-|\\\\+|\\\\*|\\\\^\"; // operators\n                            var operatorsPattern = \"((\" + operators + \")(?=[ _]))\";\n                            var operatorsReplaceRE = new RegExp(operatorsPattern, \"g\");\n                            expression = expression.replace(operatorsReplaceRE, function(match) {\n                                return Expression.OPERATORS[match];\n                            }); // predefined variables\n                            // The :${v} part is to prevent normalization of vars with a preceding colon (such as :duration),\n                            // It won't be found in PREDEFINED_VARS and so won't be normalized.\n                            // It is done like this because ie11 does not support regex lookbehind\n                            var predefinedVarsPattern = \"(\" + Object.keys(Expression.PREDEFINED_VARS).map(function(v) {\n                                return \":\".concat(v, \"|\").concat(v);\n                            }).join(\"|\") + \")\";\n                            var userVariablePattern = \"(\\\\$_*[^_ ]+)\";\n                            var variablesReplaceRE = new RegExp(\"\".concat(userVariablePattern, \"|\").concat(predefinedVarsPattern), \"g\");\n                            expression = expression.replace(variablesReplaceRE, function(match) {\n                                return Expression.PREDEFINED_VARS[match] || match;\n                            });\n                            return expression.replace(/[ _]+/g, \"_\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return new this(name).value(value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width() {\n                            return new this(\"width\");\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height() {\n                            return new this(\"height\");\n                        }\n                    },\n                    {\n                        key: \"initialWidth\",\n                        value: function initialWidth() {\n                            return new this(\"initialWidth\");\n                        }\n                    },\n                    {\n                        key: \"initialHeight\",\n                        value: function initialHeight() {\n                            return new this(\"initialHeight\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio() {\n                            return new this(\"aspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"initialAspectRatio\",\n                        value: function initialAspectRatio() {\n                            return new this(\"initialAspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount() {\n                            return new this(\"pageCount\");\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount() {\n                            return new this(\"faceCount\");\n                        }\n                    },\n                    {\n                        key: \"currentPage\",\n                        value: function currentPage() {\n                            return new this(\"currentPage\");\n                        }\n                    },\n                    {\n                        key: \"tags\",\n                        value: function tags() {\n                            return new this(\"tags\");\n                        }\n                    },\n                    {\n                        key: \"pageX\",\n                        value: function pageX() {\n                            return new this(\"pageX\");\n                        }\n                    },\n                    {\n                        key: \"pageY\",\n                        value: function pageY() {\n                            return new this(\"pageY\");\n                        }\n                    }\n                ]);\n                return Expression;\n            }();\n            /**\n * @internal\n */ Expression.OPERATORS = {\n                \"=\": \"eq\",\n                \"!=\": \"ne\",\n                \"<\": \"lt\",\n                \">\": \"gt\",\n                \"<=\": \"lte\",\n                \">=\": \"gte\",\n                \"&&\": \"and\",\n                \"||\": \"or\",\n                \"*\": \"mul\",\n                \"/\": \"div\",\n                \"+\": \"add\",\n                \"-\": \"sub\",\n                \"^\": \"pow\"\n            };\n            /**\n * @internal\n */ Expression.PREDEFINED_VARS = {\n                \"aspect_ratio\": \"ar\",\n                \"aspectRatio\": \"ar\",\n                \"current_page\": \"cp\",\n                \"currentPage\": \"cp\",\n                \"duration\": \"du\",\n                \"face_count\": \"fc\",\n                \"faceCount\": \"fc\",\n                \"height\": \"h\",\n                \"initial_aspect_ratio\": \"iar\",\n                \"initial_duration\": \"idu\",\n                \"initial_height\": \"ih\",\n                \"initial_width\": \"iw\",\n                \"initialAspectRatio\": \"iar\",\n                \"initialDuration\": \"idu\",\n                \"initialHeight\": \"ih\",\n                \"initialWidth\": \"iw\",\n                \"page_count\": \"pc\",\n                \"page_x\": \"px\",\n                \"page_y\": \"py\",\n                \"pageCount\": \"pc\",\n                \"pageX\": \"px\",\n                \"pageY\": \"py\",\n                \"tags\": \"tags\",\n                \"width\": \"w\"\n            };\n            /**\n * @internal\n */ Expression.BOUNDRY = \"[ _]+\";\n            /* harmony default export */ var expression = Expression;\n            // CONCATENATED MODULE: ./src/condition.js\n            function condition_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return condition_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, condition_typeof(obj);\n            }\n            function condition_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function condition_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function condition_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) condition_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) condition_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) _setPrototypeOf(subClass, superClass);\n            }\n            function _setPrototypeOf(o, p) {\n                _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return _setPrototypeOf(o, p);\n            }\n            function _createSuper(Derived) {\n                var hasNativeReflectConstruct = _isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = _getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = _getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return _possibleConstructorReturn(this, result);\n                };\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (call && (condition_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return _assertThisInitialized(self);\n            }\n            function _assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function _isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function _getPrototypeOf(o) {\n                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return _getPrototypeOf(o);\n            }\n            /**\n * Represents a transformation condition.\n * @param {string} conditionStr - a condition in string format\n * @class Condition\n * @example\n * // normally this class is not instantiated directly\n * var tr = cloudinary.Transformation.new()\n *    .if().width( \">\", 1000).and().aspectRatio(\"<\", \"3:4\").then()\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n * var tr = cloudinary.Transformation.new()\n *    .if(\"w > 1000 and aspectRatio < 3:4\")\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n */ var Condition = /*#__PURE__*/ function(_Expression) {\n                _inherits(Condition, _Expression);\n                var _super = _createSuper(Condition);\n                function Condition(conditionStr) {\n                    condition_classCallCheck(this, Condition);\n                    return _super.call(this, conditionStr);\n                }\n                /**\n   * @function Condition#height\n   * @param {string} operator the comparison operator (e.g. \"<\", \"lt\")\n   * @param {string|number} value the right hand side value\n   * @return {Condition} this condition\n   */ condition_createClass(Condition, [\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(operator, value) {\n                            return this.predicate(\"du\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"initialDuration\",\n                        value: function initialDuration(operator, value) {\n                            return this.predicate(\"idu\", operator, value);\n                        }\n                    }\n                ]);\n                return Condition;\n            }(expression);\n            /* harmony default export */ var condition = Condition;\n            // CONCATENATED MODULE: ./src/configuration.js\n            function _slicedToArray(arr, i) {\n                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || configuration_unsupportedIterableToArray(arr, i) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function configuration_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return configuration_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return configuration_arrayLikeToArray(o, minLen);\n            }\n            function configuration_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function _iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function _arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function configuration_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function configuration_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function configuration_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) configuration_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) configuration_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Class for defining account configuration options.\n * Depends on 'utils'\n */ /**\n * Class for defining account configuration options.\n * @constructor Configuration\n * @param {Object} options - The account configuration parameters to set.\n * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\"\n *  target=\"_new\">Available configuration options</a>\n */ var configuration_Configuration = /*#__PURE__*/ function() {\n                function Configuration(options) {\n                    configuration_classCallCheck(this, Configuration);\n                    this.configuration = options == null ? {} : cloneDeep_root_cloneDeep_default()(options);\n                    defaults(this.configuration, DEFAULT_CONFIGURATION_PARAMS);\n                }\n                /**\n   * Initializes the configuration. This method is a convenience method that invokes both\n   *  {@link Configuration#fromEnvironment|fromEnvironment()} (Node.js environment only)\n   *  and {@link Configuration#fromDocument|fromDocument()}.\n   *  It first tries to retrieve the configuration from the environment variable.\n   *  If not available, it tries from the document meta tags.\n   * @function Configuration#init\n   * @return {Configuration} returns `this` for chaining\n   * @see fromDocument\n   * @see fromEnvironment\n   */ configuration_createClass(Configuration, [\n                    {\n                        key: \"init\",\n                        value: function init() {\n                            this.fromEnvironment();\n                            this.fromDocument();\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(name, value) {\n                            this.configuration[name] = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"get\",\n                        value: function get(name) {\n                            return this.configuration[name];\n                        }\n                    },\n                    {\n                        key: \"merge\",\n                        value: function merge(config) {\n                            assign_root_assign_default()(this.configuration, cloneDeep_root_cloneDeep_default()(config));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromDocument\",\n                        value: function fromDocument() {\n                            var el, i, len, meta_elements;\n                            meta_elements = typeof document !== \"undefined\" && document !== null ? document.querySelectorAll('meta[name^=\"cloudinary_\"]') : void 0;\n                            if (meta_elements) {\n                                for(i = 0, len = meta_elements.length; i < len; i++){\n                                    el = meta_elements[i];\n                                    this.configuration[el.getAttribute(\"name\").replace(\"cloudinary_\", \"\")] = el.getAttribute(\"content\");\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromEnvironment\",\n                        value: function fromEnvironment() {\n                            var _this = this;\n                            var cloudinary_url, query, uri, uriRegex;\n                            if (typeof process !== \"undefined\" && process !== null && process.env && process.env.CLOUDINARY_URL) {\n                                cloudinary_url = process.env.CLOUDINARY_URL;\n                                uriRegex = /cloudinary:\\/\\/(?:(\\w+)(?:\\:([\\w-]+))?@)?([\\w\\.-]+)(?:\\/([^?]*))?(?:\\?(.+))?/;\n                                uri = uriRegex.exec(cloudinary_url);\n                                if (uri) {\n                                    if (uri[3] != null) {\n                                        this.configuration[\"cloud_name\"] = uri[3];\n                                    }\n                                    if (uri[1] != null) {\n                                        this.configuration[\"api_key\"] = uri[1];\n                                    }\n                                    if (uri[2] != null) {\n                                        this.configuration[\"api_secret\"] = uri[2];\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"private_cdn\"] = uri[4] != null;\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"secure_distribution\"] = uri[4];\n                                    }\n                                    query = uri[5];\n                                    if (query != null) {\n                                        query.split(\"&\").forEach(function(value) {\n                                            var _value$split = value.split(\"=\"), _value$split2 = _slicedToArray(_value$split, 2), k = _value$split2[0], v = _value$split2[1];\n                                            if (v == null) {\n                                                v = true;\n                                            }\n                                            _this.configuration[k] = v;\n                                        });\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"config\",\n                        value: function config(new_config, new_value) {\n                            switch(false){\n                                case new_value === void 0:\n                                    this.set(new_config, new_value);\n                                    return this.configuration;\n                                case !isString_root_isString_default()(new_config):\n                                    return this.get(new_config);\n                                case !isPlainObject_root_isPlainObject_default()(new_config):\n                                    this.merge(new_config);\n                                    return this.configuration;\n                                default:\n                                    // Backward compatibility - return the internal object\n                                    return this.configuration;\n                            }\n                        }\n                    },\n                    {\n                        key: \"toOptions\",\n                        value: function toOptions() {\n                            return cloneDeep_root_cloneDeep_default()(this.configuration);\n                        }\n                    }\n                ]);\n                return Configuration;\n            }();\n            var DEFAULT_CONFIGURATION_PARAMS = {\n                responsive_class: \"cld-responsive\",\n                responsive_use_breakpoints: true,\n                round_dpr: true,\n                secure: ( false ? 0 : void 0) === \"https:\"\n            };\n            configuration_Configuration.CONFIG_PARAMS = [\n                \"api_key\",\n                \"api_secret\",\n                \"callback\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"private_cdn\",\n                \"protocol\",\n                \"resource_type\",\n                \"responsive\",\n                \"responsive_class\",\n                \"responsive_use_breakpoints\",\n                \"responsive_width\",\n                \"round_dpr\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"type\",\n                \"upload_preset\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\",\n                \"externalLibraries\",\n                \"max_timeout_ms\"\n            ];\n            /* harmony default export */ var src_configuration = configuration_Configuration;\n            // CONCATENATED MODULE: ./src/layer/layer.js\n            function layer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function layer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function layer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) layer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) layer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            var layer_Layer = /*#__PURE__*/ function() {\n                /**\n   * Layer\n   * @constructor Layer\n   * @param {Object} options - layer parameters\n   */ function Layer1(options) {\n                    var _this = this;\n                    layer_classCallCheck(this, Layer1);\n                    this.options = {};\n                    if (options != null) {\n                        [\n                            \"resourceType\",\n                            \"type\",\n                            \"publicId\",\n                            \"format\"\n                        ].forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                }\n                layer_createClass(Layer1, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(value) {\n                            this.options.resourceType = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(value) {\n                            this.options.type = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"publicId\",\n                        value: function publicId(value) {\n                            this.options.publicId = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getPublicId\",\n                        value: function getPublicId() {\n                            var ref;\n                            return (ref = this.options.publicId) != null ? ref.replace(/\\//g, \":\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"getFullPublicId\",\n                        value: function getFullPublicId() {\n                            if (this.options.format != null) {\n                                return this.getPublicId() + \".\" + this.options.format;\n                            } else {\n                                return this.getPublicId();\n                            }\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            this.options.format = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components;\n                            components = [];\n                            if (this.options.publicId == null) {\n                                throw \"Must supply publicId\";\n                            }\n                            if (!(this.options.resourceType === \"image\")) {\n                                components.push(this.options.resourceType);\n                            }\n                            if (!(this.options.type === \"upload\")) {\n                                components.push(this.options.type);\n                            }\n                            components.push(this.getFullPublicId());\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.options);\n                        }\n                    }\n                ]);\n                return Layer1;\n            }();\n            /* harmony default export */ var layer_layer = layer_Layer;\n            // CONCATENATED MODULE: ./src/layer/textlayer.js\n            function textlayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return textlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, textlayer_typeof(obj);\n            }\n            function textlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function textlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function textlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) textlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) textlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function textlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) textlayer_setPrototypeOf(subClass, superClass);\n            }\n            function textlayer_setPrototypeOf(o, p) {\n                textlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return textlayer_setPrototypeOf(o, p);\n            }\n            function textlayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = textlayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = textlayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = textlayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return textlayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function textlayer_possibleConstructorReturn(self, call) {\n                if (call && (textlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return textlayer_assertThisInitialized(self);\n            }\n            function textlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function textlayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function textlayer_getPrototypeOf(o) {\n                textlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return textlayer_getPrototypeOf(o);\n            }\n            var textlayer_TextLayer = /*#__PURE__*/ function(_Layer) {\n                textlayer_inherits(TextLayer, _Layer);\n                var _super = textlayer_createSuper(TextLayer);\n                /**\n   * @constructor TextLayer\n   * @param {Object} options - layer parameters\n   */ function TextLayer(options) {\n                    var _this;\n                    textlayer_classCallCheck(this, TextLayer);\n                    var keys;\n                    _this = _super.call(this, options);\n                    keys = [\n                        \"resourceType\",\n                        \"resourceType\",\n                        \"fontFamily\",\n                        \"fontSize\",\n                        \"fontWeight\",\n                        \"fontStyle\",\n                        \"textDecoration\",\n                        \"textAlign\",\n                        \"stroke\",\n                        \"letterSpacing\",\n                        \"lineSpacing\",\n                        \"fontHinting\",\n                        \"fontAntialiasing\",\n                        \"text\",\n                        \"textStyle\"\n                    ];\n                    if (options != null) {\n                        keys.forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                    _this.options.resourceType = \"text\";\n                    return _this;\n                }\n                textlayer_createClass(TextLayer, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(_resourceType) {\n                            throw \"Cannot modify resourceType for text layers\";\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(_type) {\n                            throw \"Cannot modify type for text layers\";\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(_format) {\n                            throw \"Cannot modify format for text layers\";\n                        }\n                    },\n                    {\n                        key: \"fontFamily\",\n                        value: function fontFamily(_fontFamily) {\n                            this.options.fontFamily = _fontFamily;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontSize\",\n                        value: function fontSize(_fontSize) {\n                            this.options.fontSize = _fontSize;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontWeight\",\n                        value: function fontWeight(_fontWeight) {\n                            this.options.fontWeight = _fontWeight;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontStyle\",\n                        value: function fontStyle(_fontStyle) {\n                            this.options.fontStyle = _fontStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textDecoration\",\n                        value: function textDecoration(_textDecoration) {\n                            this.options.textDecoration = _textDecoration;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textAlign\",\n                        value: function textAlign(_textAlign) {\n                            this.options.textAlign = _textAlign;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"stroke\",\n                        value: function stroke(_stroke) {\n                            this.options.stroke = _stroke;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"letterSpacing\",\n                        value: function letterSpacing(_letterSpacing) {\n                            this.options.letterSpacing = _letterSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"lineSpacing\",\n                        value: function lineSpacing(_lineSpacing) {\n                            this.options.lineSpacing = _lineSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontHinting\",\n                        value: function fontHinting(_fontHinting) {\n                            this.options.fontHinting = _fontHinting;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontAntialiasing\",\n                        value: function fontAntialiasing(_fontAntialiasing) {\n                            this.options.fontAntialiasing = _fontAntialiasing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"text\",\n                        value: function text(_text) {\n                            this.options.text = _text;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(_textStyle) {\n                            this.options.textStyle = _textStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components, hasPublicId, hasStyle, publicId, re, res, start, style, text, textSource;\n                            style = this.textStyleIdentifier();\n                            if (this.options.publicId != null) {\n                                publicId = this.getFullPublicId();\n                            }\n                            if (this.options.text != null) {\n                                hasPublicId = !isEmpty(publicId);\n                                hasStyle = !isEmpty(style);\n                                if (hasPublicId && hasStyle || !hasPublicId && !hasStyle) {\n                                    throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay, but not both!\";\n                                }\n                                re = /\\$\\([a-zA-Z]\\w*\\)/g;\n                                start = 0; //        textSource = text.replace(new RegExp(\"[,/]\", 'g'), (c)-> \"%#{c.charCodeAt(0).toString(16).toUpperCase()}\")\n                                textSource = smartEscape(this.options.text, /[,\\/]/g);\n                                text = \"\";\n                                while(res = re.exec(textSource)){\n                                    text += smartEscape(textSource.slice(start, res.index));\n                                    text += res[0];\n                                    start = res.index + res[0].length;\n                                }\n                                text += smartEscape(textSource.slice(start));\n                            }\n                            components = [\n                                this.options.resourceType,\n                                style,\n                                publicId,\n                                text\n                            ];\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"textStyleIdentifier\",\n                        value: function textStyleIdentifier() {\n                            // Note: if a text-style argument is provided as a whole, it overrides everything else, no mix and match.\n                            if (!isEmpty(this.options.textStyle)) {\n                                return this.options.textStyle;\n                            }\n                            var components;\n                            components = [];\n                            if (this.options.fontWeight !== \"normal\") {\n                                components.push(this.options.fontWeight);\n                            }\n                            if (this.options.fontStyle !== \"normal\") {\n                                components.push(this.options.fontStyle);\n                            }\n                            if (this.options.textDecoration !== \"none\") {\n                                components.push(this.options.textDecoration);\n                            }\n                            components.push(this.options.textAlign);\n                            if (this.options.stroke !== \"none\") {\n                                components.push(this.options.stroke);\n                            }\n                            if (!(isEmpty(this.options.letterSpacing) && !isNumberLike(this.options.letterSpacing))) {\n                                components.push(\"letter_spacing_\" + this.options.letterSpacing);\n                            }\n                            if (!(isEmpty(this.options.lineSpacing) && !isNumberLike(this.options.lineSpacing))) {\n                                components.push(\"line_spacing_\" + this.options.lineSpacing);\n                            }\n                            if (!isEmpty(this.options.fontAntialiasing)) {\n                                components.push(\"antialias_\" + this.options.fontAntialiasing);\n                            }\n                            if (!isEmpty(this.options.fontHinting)) {\n                                components.push(\"hinting_\" + this.options.fontHinting);\n                            }\n                            if (!isEmpty(compact_root_compact_default()(components))) {\n                                if (isEmpty(this.options.fontFamily)) {\n                                    throw \"Must supply fontFamily. \".concat(components);\n                                }\n                                if (isEmpty(this.options.fontSize) && !isNumberLike(this.options.fontSize)) {\n                                    throw \"Must supply fontSize.\";\n                                }\n                            }\n                            components.unshift(this.options.fontFamily, this.options.fontSize);\n                            components = compact_root_compact_default()(components).join(\"_\");\n                            return components;\n                        }\n                    }\n                ]);\n                return TextLayer;\n            }(layer_layer);\n            ;\n            /* harmony default export */ var textlayer = textlayer_TextLayer;\n            // CONCATENATED MODULE: ./src/layer/subtitleslayer.js\n            function subtitleslayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return subtitleslayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, subtitleslayer_typeof(obj);\n            }\n            function subtitleslayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function subtitleslayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) subtitleslayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) subtitleslayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function subtitleslayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function subtitleslayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) subtitleslayer_setPrototypeOf(subClass, superClass);\n            }\n            function subtitleslayer_setPrototypeOf(o, p) {\n                subtitleslayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return subtitleslayer_setPrototypeOf(o, p);\n            }\n            function subtitleslayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = subtitleslayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = subtitleslayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = subtitleslayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return subtitleslayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function subtitleslayer_possibleConstructorReturn(self, call) {\n                if (call && (subtitleslayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return subtitleslayer_assertThisInitialized(self);\n            }\n            function subtitleslayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function subtitleslayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function subtitleslayer_getPrototypeOf(o) {\n                subtitleslayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return subtitleslayer_getPrototypeOf(o);\n            }\n            var SubtitlesLayer = /*#__PURE__*/ function(_TextLayer) {\n                subtitleslayer_inherits(SubtitlesLayer, _TextLayer);\n                var _super = subtitleslayer_createSuper(SubtitlesLayer);\n                /**\n   * Represent a subtitles layer\n   * @constructor SubtitlesLayer\n   * @param {Object} options - layer parameters\n   */ function SubtitlesLayer(options) {\n                    var _this;\n                    subtitleslayer_classCallCheck(this, SubtitlesLayer);\n                    _this = _super.call(this, options);\n                    _this.options.resourceType = \"subtitles\";\n                    return _this;\n                }\n                return subtitleslayer_createClass(SubtitlesLayer);\n            }(textlayer);\n            /* harmony default export */ var subtitleslayer = SubtitlesLayer;\n            // CONCATENATED MODULE: ./src/layer/fetchlayer.js\n            function fetchlayer_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return fetchlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, fetchlayer_typeof(obj);\n            }\n            function fetchlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function fetchlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function fetchlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) fetchlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) fetchlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function fetchlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) fetchlayer_setPrototypeOf(subClass, superClass);\n            }\n            function fetchlayer_setPrototypeOf(o, p) {\n                fetchlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return fetchlayer_setPrototypeOf(o, p);\n            }\n            function fetchlayer_createSuper(Derived) {\n                var hasNativeReflectConstruct = fetchlayer_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = fetchlayer_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = fetchlayer_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return fetchlayer_possibleConstructorReturn(this, result);\n                };\n            }\n            function fetchlayer_possibleConstructorReturn(self, call) {\n                if (call && (fetchlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return fetchlayer_assertThisInitialized(self);\n            }\n            function fetchlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function fetchlayer_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function fetchlayer_getPrototypeOf(o) {\n                fetchlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return fetchlayer_getPrototypeOf(o);\n            }\n            var fetchlayer_FetchLayer = /*#__PURE__*/ function(_Layer) {\n                fetchlayer_inherits(FetchLayer, _Layer);\n                var _super = fetchlayer_createSuper(FetchLayer);\n                /**\n   * @class FetchLayer\n   * @classdesc Creates an image layer using a remote URL.\n   * @param {Object|string} options - layer parameters or a url\n   * @param {string} options.url the url of the image to fetch\n   */ function FetchLayer(options) {\n                    var _this;\n                    fetchlayer_classCallCheck(this, FetchLayer);\n                    _this = _super.call(this, options);\n                    if (isString_root_isString_default()(options)) {\n                        _this.options.url = options;\n                    } else if (options != null ? options.url : void 0) {\n                        _this.options.url = options.url;\n                    }\n                    return _this;\n                }\n                fetchlayer_createClass(FetchLayer, [\n                    {\n                        key: \"url\",\n                        value: function url(_url) {\n                            this.options.url = _url;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return \"fetch:\".concat(base64EncodeURL(this.options.url));\n                        }\n                    }\n                ]);\n                return FetchLayer;\n            }(layer_layer);\n            /* harmony default export */ var fetchlayer = fetchlayer_FetchLayer;\n            // CONCATENATED MODULE: ./src/parameters.js\n            function parameters_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return parameters_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, parameters_typeof(obj);\n            }\n            function _get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    _get = Reflect.get.bind();\n                } else {\n                    _get = function _get(target, property, receiver) {\n                        var base = _superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return _get.apply(this, arguments);\n            }\n            function _superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = parameters_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function parameters_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) parameters_setPrototypeOf(subClass, superClass);\n            }\n            function parameters_setPrototypeOf(o, p) {\n                parameters_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return parameters_setPrototypeOf(o, p);\n            }\n            function parameters_createSuper(Derived) {\n                var hasNativeReflectConstruct = parameters_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = parameters_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = parameters_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return parameters_possibleConstructorReturn(this, result);\n                };\n            }\n            function parameters_possibleConstructorReturn(self, call) {\n                if (call && (parameters_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return parameters_assertThisInitialized(self);\n            }\n            function parameters_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function parameters_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function parameters_getPrototypeOf(o) {\n                parameters_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return parameters_getPrototypeOf(o);\n            }\n            function parameters_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function parameters_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function parameters_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) parameters_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) parameters_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */ var parameters_Param = /*#__PURE__*/ function() {\n                /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */ function Param(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, Param);\n                    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */ this.name = name;\n                    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */ this.shortName = shortName;\n                    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */ this.process = process1;\n                }\n                /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */ parameters_createClass(Param, [\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            this.origValue = origValue;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var val, valid;\n                            val = this.value();\n                            valid = isArray_root_isArray_default()(val) || isPlainObject_root_isPlainObject_default()(val) || isString_root_isString_default()(val) ? !isEmpty(val) : val != null;\n                            if (this.shortName != null && valid) {\n                                return \"\".concat(this.shortName, \"_\").concat(val);\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return this.process(this.origValue);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"norm_color\",\n                        value: function norm_color(value) {\n                            return value != null ? value.replace(/^#/, \"rgb:\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"build_array\",\n                        value: function build_array(arg) {\n                            if (arg == null) {\n                                return [];\n                            } else if (isArray_root_isArray_default()(arg)) {\n                                return arg;\n                            } else {\n                                return [\n                                    arg\n                                ];\n                            }\n                        }\n                    },\n                    {\n                        key: \"process_video_params\",\n                        value: function process_video_params(param) {\n                            var video;\n                            switch(param.constructor){\n                                case Object:\n                                    video = \"\";\n                                    if (\"codec\" in param) {\n                                        video = param.codec;\n                                        if (\"profile\" in param) {\n                                            video += \":\" + param.profile;\n                                            if (\"level\" in param) {\n                                                video += \":\" + param.level;\n                                                if (\"b_frames\" in param && param.b_frames === false) {\n                                                    video += \":bframes_no\";\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return video;\n                                case String:\n                                    return param;\n                                default:\n                                    return null;\n                            }\n                        }\n                    }\n                ]);\n                return Param;\n            }();\n            var parameters_ArrayParam = /*#__PURE__*/ function(_Param) {\n                parameters_inherits(ArrayParam, _Param);\n                var _super = parameters_createSuper(ArrayParam);\n                /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */ function ArrayParam(name, shortName) {\n                    var _this;\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, ArrayParam);\n                    _this = _super.call(this, name, shortName, process1);\n                    _this.sep = sep;\n                    return _this;\n                }\n                parameters_createClass(ArrayParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            if (this.shortName != null) {\n                                var arrayValue = this.value();\n                                if (isEmpty(arrayValue)) {\n                                    return \"\";\n                                } else if (isString_root_isString_default()(arrayValue)) {\n                                    return \"\".concat(this.shortName, \"_\").concat(arrayValue);\n                                } else {\n                                    var flat = arrayValue.map(function(t) {\n                                        return isFunction_root_isFunction_default()(t.serialize) ? t.serialize() : t;\n                                    }).join(this.sep);\n                                    return \"\".concat(this.shortName, \"_\").concat(flat);\n                                }\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            var _this2 = this;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return this.origValue.map(function(v) {\n                                    return _this2.process(v);\n                                });\n                            } else {\n                                return this.process(this.origValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            if (origValue == null || isArray_root_isArray_default()(origValue)) {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, [\n                                    origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n                return ArrayParam;\n            }(parameters_Param);\n            var parameters_TransformationParam = /*#__PURE__*/ function(_Param2) {\n                parameters_inherits(TransformationParam, _Param2);\n                var _super2 = parameters_createSuper(TransformationParam);\n                /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */ function TransformationParam(name) {\n                    var _this3;\n                    var shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, TransformationParam);\n                    _this3 = _super2.call(this, name, shortName, process1);\n                    _this3.sep = sep;\n                    return _this3;\n                }\n                /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */ parameters_createClass(TransformationParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var _this4 = this;\n                            var result = \"\";\n                            var val = this.value();\n                            if (isEmpty(val)) {\n                                return result;\n                            } // val is an array of strings so join them\n                            if (baseutil_allStrings(val)) {\n                                var joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n                                if (!isEmpty(joined)) {\n                                    // in case options.transformation was not set with an empty string (val != ['']);\n                                    result = \"\".concat(this.shortName, \"_\").concat(joined);\n                                }\n                            } else {\n                                // Convert val to an array of strings\n                                result = val.map(function(t) {\n                                    if (isString_root_isString_default()(t) && !isEmpty(t)) {\n                                        return \"\".concat(_this4.shortName, \"_\").concat(t);\n                                    }\n                                    if (isFunction_root_isFunction_default()(t.serialize)) {\n                                        return t.serialize();\n                                    }\n                                    if (isPlainObject_root_isPlainObject_default()(t) && !isEmpty(t)) {\n                                        return new src_transformation(t).serialize();\n                                    }\n                                    return undefined;\n                                }).filter(function(t) {\n                                    return t;\n                                });\n                            }\n                            return result;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue1) {\n                            this.origValue = origValue1;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, this.origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, [\n                                    this.origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n                return TransformationParam;\n            }(parameters_Param);\n            var number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\n            var offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\n            var parameters_RangeParam = /*#__PURE__*/ function(_Param3) {\n                parameters_inherits(RangeParam, _Param3);\n                var _super3 = parameters_createSuper(RangeParam);\n                /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */ function RangeParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n                    parameters_classCallCheck(this, RangeParam);\n                    return _super3.call(this, name, shortName, process1);\n                }\n                parameters_createClass(RangeParam, null, [\n                    {\n                        key: \"norm_range_value\",\n                        value: function norm_range_value(value) {\n                            var offset = String(value).match(new RegExp(\"^\" + offset_any_pattern + \"$\"));\n                            if (offset) {\n                                var modifier = offset[5] != null ? \"p\" : \"\";\n                                value = (offset[1] || offset[4]) + modifier;\n                            }\n                            return expression.normalize(value);\n                        }\n                    }\n                ]);\n                return RangeParam;\n            }(parameters_Param);\n            var parameters_RawParam = /*#__PURE__*/ function(_Param4) {\n                parameters_inherits(RawParam, _Param4);\n                var _super4 = parameters_createSuper(RawParam);\n                function RawParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, RawParam);\n                    return _super4.call(this, name, shortName, process1);\n                }\n                parameters_createClass(RawParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return this.value();\n                        }\n                    }\n                ]);\n                return RawParam;\n            }(parameters_Param);\n            var parameters_LayerParam = /*#__PURE__*/ function(_Param5) {\n                parameters_inherits(LayerParam, _Param5);\n                var _super5 = parameters_createSuper(LayerParam);\n                function LayerParam() {\n                    parameters_classCallCheck(this, LayerParam);\n                    return _super5.apply(this, arguments);\n                }\n                parameters_createClass(LayerParam, [\n                    {\n                        key: \"value\",\n                        value: // @return [string] layer transformation string\n                        // @private\n                        function value() {\n                            if (this.origValue == null) {\n                                return \"\";\n                            }\n                            var result;\n                            if (this.origValue instanceof layer_layer) {\n                                result = this.origValue;\n                            } else if (isPlainObject_root_isPlainObject_default()(this.origValue)) {\n                                var layerOptions = withCamelCaseKeys(this.origValue);\n                                if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n                                    result = new textlayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"subtitles\") {\n                                    result = new subtitleslayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n                                    result = new fetchlayer(layerOptions);\n                                } else {\n                                    result = new layer_layer(layerOptions);\n                                }\n                            } else if (isString_root_isString_default()(this.origValue)) {\n                                if (/^fetch:.+/.test(this.origValue)) {\n                                    result = new fetchlayer(this.origValue.substr(6));\n                                } else {\n                                    result = this.origValue;\n                                }\n                            } else {\n                                result = \"\";\n                            }\n                            return result.toString();\n                        }\n                    }\n                ], [\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(layer) {\n                            return new textlayer(layer).textStyleIdentifier();\n                        }\n                    }\n                ]);\n                return LayerParam;\n            }(parameters_Param);\n            var parameters_ExpressionParam = /*#__PURE__*/ function(_Param6) {\n                parameters_inherits(ExpressionParam, _Param6);\n                var _super6 = parameters_createSuper(ExpressionParam);\n                function ExpressionParam() {\n                    parameters_classCallCheck(this, ExpressionParam);\n                    return _super6.apply(this, arguments);\n                }\n                parameters_createClass(ExpressionParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return expression.normalize(_get(parameters_getPrototypeOf(ExpressionParam.prototype), \"serialize\", this).call(this));\n                        }\n                    }\n                ]);\n                return ExpressionParam;\n            }(parameters_Param);\n            // CONCATENATED MODULE: ./src/transformation.js\n            function transformation_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return transformation_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, transformation_typeof(obj);\n            }\n            function transformation_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) transformation_setPrototypeOf(subClass, superClass);\n            }\n            function transformation_setPrototypeOf(o, p) {\n                transformation_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return transformation_setPrototypeOf(o, p);\n            }\n            function transformation_createSuper(Derived) {\n                var hasNativeReflectConstruct = transformation_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = transformation_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = transformation_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return transformation_possibleConstructorReturn(this, result);\n                };\n            }\n            function transformation_possibleConstructorReturn(self, call) {\n                if (call && (transformation_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return transformation_assertThisInitialized(self);\n            }\n            function transformation_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function transformation_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function transformation_getPrototypeOf(o) {\n                transformation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return transformation_getPrototypeOf(o);\n            }\n            function transformation_slicedToArray(arr, i) {\n                return transformation_arrayWithHoles(arr) || transformation_iterableToArrayLimit(arr, i) || transformation_unsupportedIterableToArray(arr, i) || transformation_nonIterableRest();\n            }\n            function transformation_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function transformation_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return transformation_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transformation_arrayLikeToArray(o, minLen);\n            }\n            function transformation_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function transformation_iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function transformation_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function transformation_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function transformation_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function transformation_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) transformation_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) transformation_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */ function assignNotNull(target) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                sources.forEach(function(source) {\n                    Object.keys(source).forEach(function(key) {\n                        if (source[key] != null) {\n                            target[key] = source[key];\n                        }\n                    });\n                });\n                return target;\n            }\n            /**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */ var transformation_TransformationBase = /*#__PURE__*/ function() {\n                /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */ function TransformationBase(options) {\n                    transformation_classCallCheck(this, TransformationBase);\n                    /** @private */ /** @private */ var parent, trans;\n                    parent = void 0;\n                    trans = {};\n                    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */ this.toOptions = function(withChain) {\n                        var opt = {};\n                        if (withChain == null) {\n                            withChain = true;\n                        }\n                        Object.keys(trans).forEach(function(key) {\n                            return opt[key] = trans[key].origValue;\n                        });\n                        assignNotNull(opt, this.otherOptions);\n                        if (withChain && !isEmpty(this.chained)) {\n                            var list = this.chained.map(function(tr) {\n                                return tr.toOptions();\n                            });\n                            list.push(opt);\n                            opt = {};\n                            assignNotNull(opt, this.otherOptions);\n                            opt.transformation = list;\n                        }\n                        return opt;\n                    };\n                    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */ this.setParent = function(object) {\n                        parent = object;\n                        if (object != null) {\n                            this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n                        }\n                        return this;\n                    };\n                    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */ this.getParent = function() {\n                        return parent;\n                    }; // Helper methods to create parameter methods\n                    // These methods are defined here because they access `trans` which is\n                    // a private member of `TransformationBase`\n                    /** @protected */ this.param = function(value, name, abbr, defaultValue, process1) {\n                        if (process1 == null) {\n                            if (isFunction_root_isFunction_default()(defaultValue)) {\n                                process1 = defaultValue;\n                            } else {\n                                process1 = identity_root_identity_default.a;\n                            }\n                        }\n                        trans[name] = new parameters_Param(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rawParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RawParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rangeParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RangeParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.arrayParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_ArrayParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.transformationParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_TransformationParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    this.layerParam = function(value, name, abbr) {\n                        trans[name] = new parameters_LayerParam(name, abbr).set(value);\n                        return this;\n                    }; // End Helper methods\n                    /**\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */ this.getValue = function(name) {\n                        var value = trans[name] && trans[name].value();\n                        return value != null ? value : this.otherOptions[name];\n                    };\n                    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */ this.get = function(name) {\n                        return trans[name];\n                    };\n                    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */ this.remove = function(name) {\n                        var temp;\n                        switch(false){\n                            case trans[name] == null:\n                                temp = trans[name];\n                                delete trans[name];\n                                return temp.origValue;\n                            case this.otherOptions[name] == null:\n                                temp = this.otherOptions[name];\n                                delete this.otherOptions[name];\n                                return temp;\n                            default:\n                                return null;\n                        }\n                    };\n                    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */ this.keys = function() {\n                        var key;\n                        return (function() {\n                            var results;\n                            results = [];\n                            for(key in trans){\n                                if (key != null) {\n                                    results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n                                }\n                            }\n                            return results;\n                        })().sort();\n                    };\n                    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */ this.toPlainObject = function() {\n                        var hash, key, list;\n                        hash = {};\n                        for(key in trans){\n                            hash[key] = trans[key].value();\n                            if (isPlainObject_root_isPlainObject_default()(hash[key])) {\n                                hash[key] = cloneDeep_root_cloneDeep_default()(hash[key]);\n                            }\n                        }\n                        if (!isEmpty(this.chained)) {\n                            list = this.chained.map(function(tr) {\n                                return tr.toPlainObject();\n                            });\n                            list.push(hash);\n                            hash = {\n                                transformation: list\n                            };\n                        }\n                        return hash;\n                    };\n                    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */ this.chain = function() {\n                        var names, tr;\n                        names = Object.getOwnPropertyNames(trans);\n                        if (names.length !== 0) {\n                            tr = new this.constructor(this.toOptions(false));\n                            this.resetTransformations();\n                            this.chained.push(tr);\n                        }\n                        return this;\n                    };\n                    this.resetTransformations = function() {\n                        trans = {};\n                        return this;\n                    };\n                    this.otherOptions = {};\n                    this.chained = [];\n                    this.fromOptions(options);\n                }\n                /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */ transformation_createClass(TransformationBase, [\n                    {\n                        key: \"fromOptions\",\n                        value: function fromOptions() {\n                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                            if (options instanceof TransformationBase) {\n                                this.fromTransformation(options);\n                            } else {\n                                if (isString_root_isString_default()(options) || isArray_root_isArray_default()(options)) {\n                                    options = {\n                                        transformation: options\n                                    };\n                                }\n                                options = cloneDeep_root_cloneDeep_default()(options, function(value) {\n                                    if (value instanceof TransformationBase || value instanceof Layer) {\n                                        return new value.clone();\n                                    }\n                                }); // Handling of \"if\" statements precedes other options as it creates a chained transformation\n                                if (options[\"if\"]) {\n                                    this.set(\"if\", options[\"if\"]);\n                                    delete options[\"if\"];\n                                }\n                                for(var key in options){\n                                    var opt = options[key];\n                                    if (opt != null) {\n                                        if (key.match(VAR_NAME_RE)) {\n                                            if (key !== \"$attr\") {\n                                                this.set(\"variable\", key, opt);\n                                            }\n                                        } else {\n                                            this.set(key, opt);\n                                        }\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromTransformation\",\n                        value: function fromTransformation(other) {\n                            var _this = this;\n                            if (other instanceof TransformationBase) {\n                                other.keys().forEach(function(key) {\n                                    return _this.set(key, other.get(key).origValue);\n                                });\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(key) {\n                            var camelKey;\n                            camelKey = camelCase(key);\n                            for(var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                                values[_key2 - 1] = arguments[_key2];\n                            }\n                            if (includes_root_includes_default()(transformation_Transformation.methods, camelKey)) {\n                                this[camelKey].apply(this, values);\n                            } else {\n                                this.otherOptions[key] = values[0];\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"hasLayer\",\n                        value: function hasLayer() {\n                            return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n                            resultArray = this.chained.map(function(tr) {\n                                return tr.serialize();\n                            });\n                            paramList = this.keys();\n                            transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n                            ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n                            variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n                            paramList = difference_root_difference_default()(paramList, [\n                                \"transformation\",\n                                \"if\",\n                                \"variables\"\n                            ]);\n                            vars = [];\n                            transformationList = [];\n                            for(j = 0, len = paramList.length; j < len; j++){\n                                t = paramList[j];\n                                if (t.match(VAR_NAME_RE)) {\n                                    vars.push(t + \"_\" + expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n                                } else {\n                                    transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n                                }\n                            }\n                            switch(false){\n                                case !isString_root_isString_default()(transformations):\n                                    transformationList.push(transformations);\n                                    break;\n                                case !isArray_root_isArray_default()(transformations):\n                                    resultArray = resultArray.concat(transformations);\n                            }\n                            transformationList = function() {\n                                var k, len1, results;\n                                results = [];\n                                for(k = 0, len1 = transformationList.length; k < len1; k++){\n                                    value = transformationList[k];\n                                    if (isArray_root_isArray_default()(value) && !isEmpty(value) || !isArray_root_isArray_default()(value) && value) {\n                                        results.push(value);\n                                    }\n                                }\n                                return results;\n                            }();\n                            transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n                            if (ifParam === \"if_end\") {\n                                transformationList.push(ifParam);\n                            } else if (!isEmpty(ifParam)) {\n                                transformationList.unshift(ifParam);\n                            }\n                            transformationString = compact_root_compact_default()(transformationList).join(this.param_separator);\n                            if (!isEmpty(transformationString)) {\n                                resultArray.push(transformationString);\n                            }\n                            return compact_root_compact_default()(resultArray).join(this.trans_separator);\n                        }\n                    },\n                    {\n                        key: \"toHtmlAttributes\",\n                        value: /**\n     * Returns the attributes for an HTML tag.\n     * @function Cloudinary.toHtmlAttributes\n     * @return PlainObject\n     */ function toHtmlAttributes() {\n                            var _this2 = this;\n                            var attrName, height, options, ref2, ref3, value, width;\n                            options = {};\n                            var snakeCaseKey;\n                            Object.keys(this.otherOptions).forEach(function(key) {\n                                value = _this2.otherOptions[key];\n                                snakeCaseKey = snakeCase(key);\n                                if (!includes_root_includes_default()(transformation_Transformation.PARAM_NAMES, snakeCaseKey) && !includes_root_includes_default()(URL_KEYS, snakeCaseKey)) {\n                                    attrName = /^html_/.test(key) ? key.slice(5) : key;\n                                    options[attrName] = value;\n                                }\n                            }); // convert all \"html_key\" to \"key\" with the same value\n                            this.keys().forEach(function(key) {\n                                if (/^html_/.test(key)) {\n                                    options[camelCase(key.slice(5))] = _this2.getValue(key);\n                                }\n                            });\n                            if (!(this.hasLayer() || this.getValue(\"angle\") || includes_root_includes_default()([\n                                \"fit\",\n                                \"limit\",\n                                \"lfill\"\n                            ], this.getValue(\"crop\")))) {\n                                width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n                                height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n                                if (parseFloat(width) >= 1.0) {\n                                    if (options.width == null) {\n                                        options.width = width;\n                                    }\n                                }\n                                if (parseFloat(height) >= 1.0) {\n                                    if (options.height == null) {\n                                        options.height = height;\n                                    }\n                                }\n                            }\n                            return options;\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: /**\n     * Delegate to the parent (up the call chain) to produce HTML\n     * @function Transformation#toHtml\n     * @return {string} HTML representation of the parent if possible.\n     * @example\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\n     * tag.toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n     */ function toHtml() {\n                            var ref;\n                            return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.toOptions(true));\n                        }\n                    }\n                ], [\n                    {\n                        key: \"listNames\",\n                        value: function listNames() {\n                            return transformation_Transformation.methods;\n                        }\n                    },\n                    {\n                        key: \"isValidParamName\",\n                        value: function isValidParamName(name) {\n                            return transformation_Transformation.methods.indexOf(camelCase(name)) >= 0;\n                        }\n                    }\n                ]);\n                return TransformationBase;\n            }();\n            var VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\n            transformation_TransformationBase.prototype.trans_separator = \"/\";\n            transformation_TransformationBase.prototype.param_separator = \",\";\n            function lastArgCallback(args) {\n                var callback;\n                callback = args != null ? args[args.length - 1] : void 0;\n                if (isFunction_root_isFunction_default()(callback)) {\n                    return callback;\n                } else {\n                    return void 0;\n                }\n            }\n            function processVar(varArray) {\n                var j, len, name, results, v;\n                if (isArray_root_isArray_default()(varArray)) {\n                    results = [];\n                    for(j = 0, len = varArray.length; j < len; j++){\n                        var _varArray$j = transformation_slicedToArray(varArray[j], 2);\n                        name = _varArray$j[0];\n                        v = _varArray$j[1];\n                        results.push(\"\".concat(name, \"_\").concat(expression.normalize(v)));\n                    }\n                    return results;\n                } else {\n                    return varArray;\n                }\n            }\n            function processCustomFunction(_ref) {\n                var function_type = _ref.function_type, source = _ref.source;\n                if (function_type === \"remote\") {\n                    return [\n                        function_type,\n                        btoa(source)\n                    ].join(\":\");\n                } else if (function_type === \"wasm\") {\n                    return [\n                        function_type,\n                        source\n                    ].join(\":\");\n                }\n            }\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */ /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */ var transformation_Transformation = /*#__PURE__*/ function(_TransformationBase) {\n                transformation_inherits(Transformation, _TransformationBase);\n                var _super = transformation_createSuper(Transformation);\n                /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */ function Transformation(options) {\n                    transformation_classCallCheck(this, Transformation);\n                    return _super.call(this, options);\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */ transformation_createClass(Transformation, [\n                    {\n                        key: \"angle\",\n                        value: /*\n      Transformation Parameters\n    */ function angle(value) {\n                            return this.arrayParam(value, \"angle\", \"a\", \".\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"audioCodec\",\n                        value: function audioCodec(value) {\n                            return this.param(value, \"audio_codec\", \"ac\");\n                        }\n                    },\n                    {\n                        key: \"audioFrequency\",\n                        value: function audioFrequency(value) {\n                            return this.param(value, \"audio_frequency\", \"af\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(value) {\n                            return this.param(value, \"aspect_ratio\", \"ar\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"background\",\n                        value: function background(value) {\n                            return this.param(value, \"background\", \"b\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"bitRate\",\n                        value: function bitRate(value) {\n                            return this.param(value, \"bit_rate\", \"br\");\n                        }\n                    },\n                    {\n                        key: \"border\",\n                        value: function border(value) {\n                            return this.param(value, \"border\", \"bo\", function(border) {\n                                if (isPlainObject_root_isPlainObject_default()(border)) {\n                                    border = assign_root_assign_default()({}, {\n                                        color: \"black\",\n                                        width: 2\n                                    }, border);\n                                    return \"\".concat(border.width, \"px_solid_\").concat(parameters_Param.norm_color(border.color));\n                                } else {\n                                    return border;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"color\",\n                        value: function color(value) {\n                            return this.param(value, \"color\", \"co\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"colorSpace\",\n                        value: function colorSpace(value) {\n                            return this.param(value, \"color_space\", \"cs\");\n                        }\n                    },\n                    {\n                        key: \"crop\",\n                        value: function crop(value) {\n                            return this.param(value, \"crop\", \"c\");\n                        }\n                    },\n                    {\n                        key: \"customFunction\",\n                        value: function customFunction(value) {\n                            return this.param(value, \"custom_function\", \"fn\", function() {\n                                return processCustomFunction(value);\n                            });\n                        }\n                    },\n                    {\n                        key: \"customPreFunction\",\n                        value: function customPreFunction(value) {\n                            if (this.get(\"custom_function\")) {\n                                return;\n                            }\n                            return this.rawParam(value, \"custom_function\", \"\", function() {\n                                value = processCustomFunction(value);\n                                return value ? \"fn_pre:\".concat(value) : value;\n                            });\n                        }\n                    },\n                    {\n                        key: \"defaultImage\",\n                        value: function defaultImage(value) {\n                            return this.param(value, \"default_image\", \"d\");\n                        }\n                    },\n                    {\n                        key: \"delay\",\n                        value: function delay(value) {\n                            return this.param(value, \"delay\", \"dl\");\n                        }\n                    },\n                    {\n                        key: \"density\",\n                        value: function density(value) {\n                            return this.param(value, \"density\", \"dn\");\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(value) {\n                            return this.rangeParam(value, \"duration\", \"du\");\n                        }\n                    },\n                    {\n                        key: \"dpr\",\n                        value: function dpr(value) {\n                            return this.param(value, \"dpr\", \"dpr\", function(dpr) {\n                                dpr = dpr.toString();\n                                if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n                                    return dpr + \".0\";\n                                } else {\n                                    return expression.normalize(dpr);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"effect\",\n                        value: function effect(value) {\n                            return this.arrayParam(value, \"effect\", \"e\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"else\",\n                        value: function _else() {\n                            return this[\"if\"](\"else\");\n                        }\n                    },\n                    {\n                        key: \"endIf\",\n                        value: function endIf() {\n                            return this[\"if\"](\"end\");\n                        }\n                    },\n                    {\n                        key: \"endOffset\",\n                        value: function endOffset(value) {\n                            return this.rangeParam(value, \"end_offset\", \"eo\");\n                        }\n                    },\n                    {\n                        key: \"fallbackContent\",\n                        value: function fallbackContent(value) {\n                            return this.param(value, \"fallback_content\");\n                        }\n                    },\n                    {\n                        key: \"fetchFormat\",\n                        value: function fetchFormat(value) {\n                            return this.param(value, \"fetch_format\", \"f\");\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            return this.param(value, \"format\");\n                        }\n                    },\n                    {\n                        key: \"flags\",\n                        value: function flags(value) {\n                            return this.arrayParam(value, \"flags\", \"fl\", \".\");\n                        }\n                    },\n                    {\n                        key: \"gravity\",\n                        value: function gravity(value) {\n                            return this.param(value, \"gravity\", \"g\");\n                        }\n                    },\n                    {\n                        key: \"fps\",\n                        value: function fps(value) {\n                            return this.param(value, \"fps\", \"fps\", function(fps) {\n                                if (isString_root_isString_default()(fps)) {\n                                    return fps;\n                                } else if (isArray_root_isArray_default()(fps)) {\n                                    return fps.join(\"-\");\n                                } else {\n                                    return fps;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(value) {\n                            var _this3 = this;\n                            return this.param(value, \"height\", \"h\", function() {\n                                if (_this3.getValue(\"crop\") || _this3.getValue(\"overlay\") || _this3.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"htmlHeight\",\n                        value: function htmlHeight(value) {\n                            return this.param(value, \"html_height\");\n                        }\n                    },\n                    {\n                        key: \"htmlWidth\",\n                        value: function htmlWidth(value) {\n                            return this.param(value, \"html_width\");\n                        }\n                    },\n                    {\n                        key: \"if\",\n                        value: function _if() {\n                            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n                            var i, ifVal, j, ref, trIf, trRest;\n                            switch(value){\n                                case \"else\":\n                                    this.chain();\n                                    return this.param(value, \"if\", \"if\");\n                                case \"end\":\n                                    this.chain();\n                                    for(i = j = ref = this.chained.length - 1; j >= 0; i = j += -1){\n                                        ifVal = this.chained[i].getValue(\"if\");\n                                        if (ifVal === \"end\") {\n                                            break;\n                                        } else if (ifVal != null) {\n                                            trIf = Transformation[\"new\"]()[\"if\"](ifVal);\n                                            this.chained[i].remove(\"if\");\n                                            trRest = this.chained[i];\n                                            this.chained[i] = Transformation[\"new\"]().transformation([\n                                                trIf,\n                                                trRest\n                                            ]);\n                                            if (ifVal !== \"else\") {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    return this.param(value, \"if\", \"if\");\n                                case \"\":\n                                    return condition[\"new\"]().setParent(this);\n                                default:\n                                    return this.param(value, \"if\", \"if\", function(value) {\n                                        return condition[\"new\"](value).toString();\n                                    });\n                            }\n                        }\n                    },\n                    {\n                        key: \"keyframeInterval\",\n                        value: function keyframeInterval(value) {\n                            return this.param(value, \"keyframe_interval\", \"ki\");\n                        }\n                    },\n                    {\n                        key: \"ocr\",\n                        value: function ocr(value) {\n                            return this.param(value, \"ocr\", \"ocr\");\n                        }\n                    },\n                    {\n                        key: \"offset\",\n                        value: function offset(value) {\n                            var end_o, start_o;\n                            var _ref2 = isFunction_root_isFunction_default()(value != null ? value.split : void 0) ? value.split(\"..\") : isArray_root_isArray_default()(value) ? value : [\n                                null,\n                                null\n                            ];\n                            var _ref3 = transformation_slicedToArray(_ref2, 2);\n                            start_o = _ref3[0];\n                            end_o = _ref3[1];\n                            if (start_o != null) {\n                                this.startOffset(start_o);\n                            }\n                            if (end_o != null) {\n                                return this.endOffset(end_o);\n                            }\n                        }\n                    },\n                    {\n                        key: \"opacity\",\n                        value: function opacity(value) {\n                            return this.param(value, \"opacity\", \"o\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"overlay\",\n                        value: function overlay(value) {\n                            return this.layerParam(value, \"overlay\", \"l\");\n                        }\n                    },\n                    {\n                        key: \"page\",\n                        value: function page(value) {\n                            return this.param(value, \"page\", \"pg\");\n                        }\n                    },\n                    {\n                        key: \"poster\",\n                        value: function poster(value) {\n                            return this.param(value, \"poster\");\n                        }\n                    },\n                    {\n                        key: \"prefix\",\n                        value: function prefix(value) {\n                            return this.param(value, \"prefix\", \"p\");\n                        }\n                    },\n                    {\n                        key: \"quality\",\n                        value: function quality(value) {\n                            return this.param(value, \"quality\", \"q\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"radius\",\n                        value: function radius(value) {\n                            return this.arrayParam(value, \"radius\", \"r\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"rawTransformation\",\n                        value: function rawTransformation(value) {\n                            return this.rawParam(value, \"raw_transformation\");\n                        }\n                    },\n                    {\n                        key: \"size\",\n                        value: function size(value) {\n                            var height, width;\n                            if (isFunction_root_isFunction_default()(value != null ? value.split : void 0)) {\n                                var _value$split = value.split(\"x\");\n                                var _value$split2 = transformation_slicedToArray(_value$split, 2);\n                                width = _value$split2[0];\n                                height = _value$split2[1];\n                                this.width(width);\n                                return this.height(height);\n                            }\n                        }\n                    },\n                    {\n                        key: \"sourceTypes\",\n                        value: function sourceTypes(value) {\n                            return this.param(value, \"source_types\");\n                        }\n                    },\n                    {\n                        key: \"sourceTransformation\",\n                        value: function sourceTransformation(value) {\n                            return this.param(value, \"source_transformation\");\n                        }\n                    },\n                    {\n                        key: \"startOffset\",\n                        value: function startOffset(value) {\n                            return this.rangeParam(value, \"start_offset\", \"so\");\n                        }\n                    },\n                    {\n                        key: \"streamingProfile\",\n                        value: function streamingProfile(value) {\n                            return this.param(value, \"streaming_profile\", \"sp\");\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(value) {\n                            return this.transformationParam(value, \"transformation\", \"t\");\n                        }\n                    },\n                    {\n                        key: \"underlay\",\n                        value: function underlay(value) {\n                            return this.layerParam(value, \"underlay\", \"u\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return this.param(value, name, name);\n                        }\n                    },\n                    {\n                        key: \"variables\",\n                        value: function variables(values) {\n                            return this.arrayParam(values, \"variables\");\n                        }\n                    },\n                    {\n                        key: \"videoCodec\",\n                        value: function videoCodec(value) {\n                            return this.param(value, \"video_codec\", \"vc\", parameters_Param.process_video_params);\n                        }\n                    },\n                    {\n                        key: \"videoSampling\",\n                        value: function videoSampling(value) {\n                            return this.param(value, \"video_sampling\", \"vs\");\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(value) {\n                            var _this4 = this;\n                            return this.param(value, \"width\", \"w\", function() {\n                                if (_this4.getValue(\"crop\") || _this4.getValue(\"overlay\") || _this4.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"x\",\n                        value: function x(value) {\n                            return this.param(value, \"x\", \"x\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"y\",\n                        value: function y(value) {\n                            return this.param(value, \"y\", \"y\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"zoom\",\n                        value: function zoom(value) {\n                            return this.param(value, \"zoom\", \"z\", expression.normalize);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new Transformation(options);\n                        }\n                    }\n                ]);\n                return Transformation;\n            }(transformation_TransformationBase);\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */ transformation_Transformation.methods = [\n                \"angle\",\n                \"audioCodec\",\n                \"audioFrequency\",\n                \"aspectRatio\",\n                \"background\",\n                \"bitRate\",\n                \"border\",\n                \"color\",\n                \"colorSpace\",\n                \"crop\",\n                \"customFunction\",\n                \"customPreFunction\",\n                \"defaultImage\",\n                \"delay\",\n                \"density\",\n                \"duration\",\n                \"dpr\",\n                \"effect\",\n                \"else\",\n                \"endIf\",\n                \"endOffset\",\n                \"fallbackContent\",\n                \"fetchFormat\",\n                \"format\",\n                \"flags\",\n                \"gravity\",\n                \"fps\",\n                \"height\",\n                \"htmlHeight\",\n                \"htmlWidth\",\n                \"if\",\n                \"keyframeInterval\",\n                \"ocr\",\n                \"offset\",\n                \"opacity\",\n                \"overlay\",\n                \"page\",\n                \"poster\",\n                \"prefix\",\n                \"quality\",\n                \"radius\",\n                \"rawTransformation\",\n                \"size\",\n                \"sourceTypes\",\n                \"sourceTransformation\",\n                \"startOffset\",\n                \"streamingProfile\",\n                \"transformation\",\n                \"underlay\",\n                \"variable\",\n                \"variables\",\n                \"videoCodec\",\n                \"videoSampling\",\n                \"width\",\n                \"x\",\n                \"y\",\n                \"zoom\"\n            ];\n            /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */ transformation_Transformation.PARAM_NAMES = transformation_Transformation.methods.map(snakeCase).concat(src_configuration.CONFIG_PARAMS);\n            /* harmony default export */ var src_transformation = transformation_Transformation;\n            // CONCATENATED MODULE: ./src/tags/htmltag.js\n            function htmltag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function htmltag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function htmltag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) htmltag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) htmltag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            /**\n * Generic HTML tag\n * Depends on 'transformation', 'util'\n */ /**\n * Represents an HTML (DOM) tag\n * @constructor HtmlTag\n * @param {string} name - the name of the tag\n * @param {string} [publicId]\n * @param {Object} options\n * @example tag = new HtmlTag( 'div', { 'width': 10})\n */ var htmltag_HtmlTag = /*#__PURE__*/ function() {\n                function HtmlTag(name, publicId, options) {\n                    htmltag_classCallCheck(this, HtmlTag);\n                    var transformation;\n                    this.name = name;\n                    this.publicId = publicId;\n                    if (options == null) {\n                        if (isPlainObject_root_isPlainObject_default()(publicId)) {\n                            options = publicId;\n                            this.publicId = void 0;\n                        } else {\n                            options = {};\n                        }\n                    }\n                    transformation = new src_transformation(options);\n                    transformation.setParent(this);\n                    this.transformation = function() {\n                        return transformation;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * Creates a new instance of an HTML (DOM) tag\n   * @function HtmlTag.new\n   * @param {string} name - the name of the tag\n   * @param {string} [publicId]\n   * @param {Object} options\n   * @return {HtmlTag}\n   * @example tag = HtmlTag.new( 'div', { 'width': 10})\n   */ htmltag_createClass(HtmlTag, [\n                    {\n                        key: \"htmlAttrs\",\n                        value: /**\n     * combine key and value from the `attr` to generate an HTML tag attributes string.\n     * `Transformation::toHtmlTagOptions` is used to filter out transformation and configuration keys.\n     * @protected\n     * @param {Object} attrs\n     * @return {string} the attributes in the format `'key1=\"value1\" key2=\"value2\"'`\n     * @ignore\n     */ function htmlAttrs(attrs) {\n                            var key, pairs, value;\n                            return pairs = (function() {\n                                var results;\n                                results = [];\n                                for(key in attrs){\n                                    value = escapeQuotes(attrs[key]);\n                                    if (value) {\n                                        results.push(htmltag_toAttribute(key, value));\n                                    }\n                                }\n                                return results;\n                            })().sort().join(\" \");\n                        }\n                    },\n                    {\n                        key: \"getOptions\",\n                        value: function getOptions() {\n                            return this.transformation().toOptions();\n                        }\n                    },\n                    {\n                        key: \"getOption\",\n                        value: function getOption(name) {\n                            return this.transformation().getValue(name);\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            // The attributes are be computed from the options every time this method is invoked.\n                            var htmlAttributes = this.transformation().toHtmlAttributes();\n                            Object.keys(htmlAttributes).forEach(function(key) {\n                                if (isPlainObject_root_isPlainObject_default()(htmlAttributes[key])) {\n                                    delete htmlAttributes[key];\n                                }\n                            });\n                            if (htmlAttributes.attributes) {\n                                // Currently HTML attributes are defined both at the top level and under 'attributes'\n                                merge_root_merge_default()(htmlAttributes, htmlAttributes.attributes);\n                                delete htmlAttributes.attributes;\n                            }\n                            return htmlAttributes;\n                        }\n                    },\n                    {\n                        key: \"setAttr\",\n                        value: function setAttr(name, value) {\n                            this.transformation().set(\"html_\".concat(name), value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getAttr\",\n                        value: function getAttr(name) {\n                            return this.attributes()[\"html_\".concat(name)] || this.attributes()[name];\n                        }\n                    },\n                    {\n                        key: \"removeAttr\",\n                        value: function removeAttr(name) {\n                            var ref;\n                            return (ref = this.transformation().remove(\"html_\".concat(name))) != null ? ref : this.transformation().remove(name);\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"openTag\",\n                        value: function openTag() {\n                            var tag = \"<\" + this.name;\n                            var htmlAttrs = this.htmlAttrs(this.attributes());\n                            if (htmlAttrs && htmlAttrs.length > 0) {\n                                tag += \" \" + htmlAttrs;\n                            }\n                            return tag + \">\";\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\".concat(this.name, \">\");\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: function toHtml() {\n                            return this.openTag() + this.content() + this.closeTag();\n                        }\n                    },\n                    {\n                        key: \"toDOM\",\n                        value: function toDOM() {\n                            var element, name, ref, value;\n                            if (!isFunction_root_isFunction_default()(typeof document !== \"undefined\" && document !== null ? document.createElement : void 0)) {\n                                throw \"Can't create DOM if document is not present!\";\n                            }\n                            element = document.createElement(this.name);\n                            ref = this.attributes();\n                            for(name in ref){\n                                value = ref[name];\n                                element.setAttribute(name, value);\n                            }\n                            return element;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(name, publicId, options) {\n                            return new this(name, publicId, options);\n                        }\n                    },\n                    {\n                        key: \"isResponsive\",\n                        value: function isResponsive(tag, responsiveClass) {\n                            var dataSrc;\n                            dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                            return lodash_hasClass(tag, responsiveClass) && /\\bw_auto\\b/.exec(dataSrc);\n                        }\n                    }\n                ]);\n                return HtmlTag;\n            }();\n            ;\n            /**\n * Represent the given key and value as an HTML attribute.\n * @function toAttribute\n * @protected\n * @param {string} key - attribute name\n * @param {*|boolean} value - the value of the attribute. If the value is boolean `true`, return the key only.\n * @returns {string} the attribute\n *\n */ function htmltag_toAttribute(key, value) {\n                if (!value) {\n                    return void 0;\n                } else if (value === true) {\n                    return key;\n                } else {\n                    return \"\".concat(key, '=\"').concat(value, '\"');\n                }\n            }\n            /**\n * If given value is a string, replaces quotes with character entities (&#34;, &#39;)\n * @param value - value to change\n * @returns {*} changed value\n */ function escapeQuotes(value) {\n                return isString_root_isString_default()(value) ? value.replace('\"', \"&#34;\").replace(\"'\", \"&#39;\") : value;\n            }\n            /* harmony default export */ var htmltag = htmltag_HtmlTag;\n            // CONCATENATED MODULE: ./src/url.js\n            var _excluded = [\n                \"placeholder\",\n                \"accessibility\"\n            ];\n            function _objectWithoutProperties(source, excluded) {\n                if (source == null) return {};\n                var target = _objectWithoutPropertiesLoose(source, excluded);\n                var key, i;\n                if (Object.getOwnPropertySymbols) {\n                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n                    for(i = 0; i < sourceSymbolKeys.length; i++){\n                        key = sourceSymbolKeys[i];\n                        if (excluded.indexOf(key) >= 0) continue;\n                        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                        target[key] = source[key];\n                    }\n                }\n                return target;\n            }\n            function _objectWithoutPropertiesLoose(source, excluded) {\n                if (source == null) return {};\n                var target = {};\n                var sourceKeys = Object.keys(source);\n                var key, i;\n                for(i = 0; i < sourceKeys.length; i++){\n                    key = sourceKeys[i];\n                    if (excluded.indexOf(key) >= 0) continue;\n                    target[key] = source[key];\n                }\n                return target;\n            }\n            /**\n * Adds protocol, host, pathname prefixes to given string\n * @param str\n * @returns {string}\n */ function makeUrl(str) {\n                var prefix = document.location.protocol + \"//\" + document.location.host;\n                if (str[0] === \"?\") {\n                    prefix += document.location.pathname;\n                } else if (str[0] !== \"/\") {\n                    prefix += document.location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n                }\n                return prefix + str;\n            }\n            /**\n * Check is given string is a url\n * @param str\n * @returns {boolean}\n */ function isUrl(str) {\n                return str ? !!str.match(/^https?:\\//) : false;\n            } // Produce a number between 1 and 5 to be used for cdn sub domains designation\n            function cdnSubdomainNumber(publicId) {\n                return src_crc32(publicId) % 5 + 1;\n            }\n            /**\n * Removes signature from options and returns the signature\n * Makes sure signature is empty or of this format: s--signature--\n * @param {object} options\n * @returns {string} the formatted signature\n */ function handleSignature(options) {\n                var signature = options.signature;\n                var isFormatted = !signature || signature.indexOf(\"s--\") === 0 && signature.substr(-2) === \"--\";\n                delete options.signature;\n                return isFormatted ? signature : \"s--\".concat(signature, \"--\");\n            }\n            /**\n * Create the URL prefix for Cloudinary resources.\n * @param {string} publicId the resource public ID\n * @param {object} options additional options\n * @param {string} options.cloud_name - the cloud name.\n * @param {boolean} [options.cdn_subdomain=false] - Whether to automatically build URLs with\n *  multiple CDN sub-domains.\n * @param {string} [options.private_cdn] - Boolean (default: false). Should be set to true for Advanced plan's users\n *  that have a private CDN distribution.\n * @param {string} [options.protocol=\"http://\"] - the URI protocol to use. If options.secure is true,\n *  the value is overridden to \"https://\"\n * @param {string} [options.secure_distribution] - The domain name of the CDN distribution to use for building HTTPS URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution.\n * @param {string} [options.cname] - Custom domain name to use for building HTTP URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution and a custom CNAME.\n * @param {boolean} [options.secure_cdn_subdomain=true] - When options.secure is true and this parameter is false,\n *  the subdomain is set to \"res\".\n * @param {boolean} [options.secure=false] - Force HTTPS URLs of images even if embedded in non-secure HTTP pages.\n *  When this value is true, options.secure_distribution will be used as host if provided, and options.protocol is set\n *  to \"https://\".\n * @returns {string} the URL prefix for the resource.\n * @private\n */ function handlePrefix(publicId, options) {\n                if (options.cloud_name && options.cloud_name[0] === \"/\") {\n                    return \"/res\" + options.cloud_name;\n                } // defaults\n                var protocol = \"http://\";\n                var cdnPart = \"\";\n                var subdomain = \"res\";\n                var host = \".cloudinary.com\";\n                var path = \"/\" + options.cloud_name; // modifications\n                if (options.protocol) {\n                    protocol = options.protocol + \"//\";\n                }\n                if (options.private_cdn) {\n                    cdnPart = options.cloud_name + \"-\";\n                    path = \"\";\n                }\n                if (options.cdn_subdomain) {\n                    subdomain = \"res-\" + cdnSubdomainNumber(publicId);\n                }\n                if (options.secure) {\n                    protocol = \"https://\";\n                    if (options.secure_cdn_subdomain === false) {\n                        subdomain = \"res\";\n                    }\n                    if (options.secure_distribution != null && options.secure_distribution !== OLD_AKAMAI_SHARED_CDN && options.secure_distribution !== SHARED_CDN) {\n                        cdnPart = \"\";\n                        subdomain = \"\";\n                        host = options.secure_distribution;\n                    }\n                } else if (options.cname) {\n                    protocol = \"http://\";\n                    cdnPart = \"\";\n                    subdomain = options.cdn_subdomain ? \"a\" + (src_crc32(publicId) % 5 + 1) + \".\" : \"\";\n                    host = options.cname;\n                }\n                return [\n                    protocol,\n                    cdnPart,\n                    subdomain,\n                    host,\n                    path\n                ].join(\"\");\n            }\n            /**\n * Return the resource type and action type based on the given configuration\n * @function Cloudinary#handleResourceType\n * @param {Object|string} resource_type\n * @param {string} [type='upload']\n * @param {string} [url_suffix]\n * @param {boolean} [use_root_path]\n * @param {boolean} [shorten]\n * @returns {string} resource_type/type\n * @ignore\n */ function handleResourceType(_ref) {\n                var _ref$resource_type = _ref.resource_type, resource_type = _ref$resource_type === void 0 ? \"image\" : _ref$resource_type, _ref$type = _ref.type, type = _ref$type === void 0 ? \"upload\" : _ref$type, url_suffix = _ref.url_suffix, use_root_path = _ref.use_root_path, shorten = _ref.shorten;\n                var options, resourceType = resource_type;\n                if (isPlainObject_root_isPlainObject_default()(resourceType)) {\n                    options = resourceType;\n                    resourceType = options.resource_type;\n                    type = options.type;\n                    shorten = options.shorten;\n                }\n                if (type == null) {\n                    type = \"upload\";\n                }\n                if (url_suffix != null) {\n                    resourceType = SEO_TYPES[\"\".concat(resourceType, \"/\").concat(type)];\n                    type = null;\n                    if (resourceType == null) {\n                        throw new Error(\"URL Suffix only supported for \".concat(Object.keys(SEO_TYPES).join(\", \")));\n                    }\n                }\n                if (use_root_path) {\n                    if (resourceType === \"image\" && type === \"upload\" || resourceType === \"images\") {\n                        resourceType = null;\n                        type = null;\n                    } else {\n                        throw new Error(\"Root path only supported for image/upload\");\n                    }\n                }\n                if (shorten && resourceType === \"image\" && type === \"upload\") {\n                    resourceType = \"iu\";\n                    type = null;\n                }\n                return [\n                    resourceType,\n                    type\n                ].join(\"/\");\n            }\n            /**\n * Encode publicId\n * @param publicId\n * @returns {string} encoded publicId\n */ function encodePublicId(publicId) {\n                return encodeURIComponent(publicId).replace(/%3A/g, \":\").replace(/%2F/g, \"/\");\n            }\n            /**\n * Encode and format publicId\n * @param publicId\n * @param options\n * @returns {string} publicId\n */ function formatPublicId(publicId, options) {\n                if (isUrl(publicId)) {\n                    publicId = encodePublicId(publicId);\n                } else {\n                    try {\n                        // Make sure publicId is URI encoded.\n                        publicId = decodeURIComponent(publicId);\n                    } catch (error) {}\n                    publicId = encodePublicId(publicId);\n                    if (options.url_suffix) {\n                        publicId = publicId + \"/\" + options.url_suffix;\n                    }\n                    if (options.format) {\n                        if (!options.trust_public_id) {\n                            publicId = publicId.replace(/\\.(jpg|png|gif|webp)$/, \"\");\n                        }\n                        publicId = publicId + \".\" + options.format;\n                    }\n                }\n                return publicId;\n            }\n            /**\n * Get any error with url options\n * @param options\n * @returns {string} if error, otherwise return undefined\n */ function validate(options) {\n                var cloud_name = options.cloud_name, url_suffix = options.url_suffix;\n                if (!cloud_name) {\n                    return \"Unknown cloud_name\";\n                }\n                if (url_suffix && url_suffix.match(/[\\.\\/]/)) {\n                    return \"url_suffix should not include . or /\";\n                }\n            }\n            /**\n * Get version part of the url\n * @param publicId\n * @param options\n * @returns {string}\n */ function handleVersion(publicId, options) {\n                // force_version param means to make sure there is a version in the url (Default is true)\n                var isForceVersion = options.force_version || typeof options.force_version === \"undefined\"; // Is version included in publicId or in options, or publicId is a url (doesn't need version)\n                var isVersionExist = publicId.indexOf(\"/\") < 0 || publicId.match(/^v[0-9]+/) || isUrl(publicId) || options.version;\n                if (isForceVersion && !isVersionExist) {\n                    options.version = 1;\n                }\n                return options.version ? \"v\".concat(options.version) : \"\";\n            }\n            /**\n * Get final transformation component for url string\n * @param options\n * @returns {string}\n */ function handleTransformation(options) {\n                var _ref2 = options || {}, placeholder = _ref2.placeholder, accessibility = _ref2.accessibility, otherOptions = _objectWithoutProperties(_ref2, _excluded);\n                var result = new src_transformation(otherOptions); // Append accessibility transformations\n                if (accessibility && ACCESSIBILITY_MODES[accessibility]) {\n                    result.chain().effect(ACCESSIBILITY_MODES[accessibility]);\n                } // Append placeholder transformations\n                if (placeholder) {\n                    if (placeholder === \"predominant-color\" && result.getValue(\"width\") && result.getValue(\"height\")) {\n                        placeholder += \"-pixel\";\n                    }\n                    var placeholderTransformations = PLACEHOLDER_IMAGE_MODES[placeholder] || PLACEHOLDER_IMAGE_MODES.blur;\n                    placeholderTransformations.forEach(function(t) {\n                        return result.chain().transformation(t);\n                    });\n                }\n                return result.serialize();\n            }\n            /**\n * If type is 'fetch', update publicId to be a url\n * @param publicId\n * @param type\n * @returns {string}\n */ function preparePublicId(publicId, _ref3) {\n                var type = _ref3.type;\n                return !isUrl(publicId) && type === \"fetch\" ? makeUrl(publicId) : publicId;\n            }\n            /**\n * Generate url string\n * @param publicId\n * @param options\n * @returns {string} final url\n */ function urlString(publicId, options) {\n                if (isUrl(publicId) && (options.type === \"upload\" || options.type === \"asset\")) {\n                    return publicId;\n                }\n                var version = handleVersion(publicId, options);\n                var transformationString = handleTransformation(options);\n                var prefix = handlePrefix(publicId, options);\n                var signature = handleSignature(options);\n                var resourceType = handleResourceType(options);\n                publicId = formatPublicId(publicId, options);\n                return compact_root_compact_default()([\n                    prefix,\n                    resourceType,\n                    signature,\n                    transformationString,\n                    version,\n                    publicId\n                ]).join(\"/\").replace(/([^:])\\/+/g, \"$1/\") // replace '///' with '//'\n                .replace(\" \", \"%20\");\n            }\n            /**\n * Merge options and config with defaults\n * update options fetch_format according to 'type' param\n * @param options\n * @param config\n * @returns {*} updated options\n */ function prepareOptions(options, config) {\n                if (options instanceof src_transformation) {\n                    options = options.toOptions();\n                }\n                options = defaults({}, options, config, DEFAULT_IMAGE_PARAMS);\n                if (options.type === \"fetch\") {\n                    options.fetch_format = options.fetch_format || options.format;\n                }\n                return options;\n            }\n            /**\n * Generates a URL for any asset in your Media library.\n * @function url\n * @ignore\n * @param {string} publicId - The public ID of the media asset.\n * @param {Object} [options={}] - The {@link Transformation} parameters to include in the URL.\n * @param {object} [config={}] - URL configuration parameters\n * @param {type} [options.type='upload'] - The asset's storage type.\n *  For details on all fetch types, see\n * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n *  target=\"_blank\">Fetch types</a>.\n * @param {Object} [options.resource_type='image'] - The type of asset. <p>Possible values:<br/>\n *  - `image`<br/>\n *  - `video`<br/>\n *  - `raw`\n * @param {signature} [options.signature='s--12345678--'] - The signature component of a\n *  signed delivery URL of the format: /s--SIGNATURE--/.\n *  For details on signatures, see\n * <a href=\"https://cloudinary.com/documentation/signatures\" target=\"_blank\">Signatures</a>.\n * @return {string} The media asset URL.\n * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n *  Available image transformations</a>\n * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n *  Available video transformations</a>\n */ function url_url(publicId) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                if (!publicId) {\n                    return publicId;\n                }\n                options = prepareOptions(options, config);\n                publicId = preparePublicId(publicId, options);\n                var error = validate(options);\n                if (error) {\n                    throw error;\n                }\n                var resultUrl = urlString(publicId, options);\n                if (options.urlAnalytics) {\n                    var analyticsOptions = getAnalyticsOptions(options);\n                    var sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions); // url might already have a '?' query param\n                    var appender = \"?\";\n                    if (resultUrl.indexOf(\"?\") >= 0) {\n                        appender = \"&\";\n                    }\n                    resultUrl = \"\".concat(resultUrl).concat(appender, \"_a=\").concat(sdkAnalyticsSignature);\n                }\n                if (options.auth_token) {\n                    var _appender = resultUrl.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\n                    resultUrl = \"\".concat(resultUrl).concat(_appender, \"__cld_token__=\").concat(options.auth_token);\n                }\n                return resultUrl;\n            }\n            ;\n            // CONCATENATED MODULE: ./src/util/generateBreakpoints.js\n            function generateBreakpoints_slicedToArray(arr, i) {\n                return generateBreakpoints_arrayWithHoles(arr) || generateBreakpoints_iterableToArrayLimit(arr, i) || generateBreakpoints_unsupportedIterableToArray(arr, i) || generateBreakpoints_nonIterableRest();\n            }\n            function generateBreakpoints_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function generateBreakpoints_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return generateBreakpoints_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return generateBreakpoints_arrayLikeToArray(o, minLen);\n            }\n            function generateBreakpoints_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function generateBreakpoints_iterableToArrayLimit(arr, i) {\n                var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n                if (_i == null) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _s, _e;\n                try {\n                    for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function generateBreakpoints_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            /**\n * Helper function. Gets or populates srcset breakpoints using provided parameters\n * Either the breakpoints or min_width, max_width, max_images must be provided.\n *\n * @private\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\n *\n * @return {number[]} Array of breakpoints\n *\n */ function generateBreakpoints(srcset) {\n                var breakpoints = srcset.breakpoints || [];\n                if (breakpoints.length) {\n                    return breakpoints;\n                }\n                var _map = [\n                    srcset.min_width,\n                    srcset.max_width,\n                    srcset.max_images\n                ].map(Number), _map2 = generateBreakpoints_slicedToArray(_map, 3), min_width = _map2[0], max_width = _map2[1], max_images = _map2[2];\n                if ([\n                    min_width,\n                    max_width,\n                    max_images\n                ].some(isNaN)) {\n                    throw \"Either (min_width, max_width, max_images) \" + \"or breakpoints must be provided to the image srcset attribute\";\n                }\n                if (min_width > max_width) {\n                    throw \"min_width must be less than max_width\";\n                }\n                if (max_images <= 0) {\n                    throw \"max_images must be a positive integer\";\n                } else if (max_images === 1) {\n                    min_width = max_width;\n                }\n                var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\n                for(var current = min_width; current < max_width; current += stepSize){\n                    breakpoints.push(current);\n                }\n                breakpoints.push(max_width);\n                return breakpoints;\n            }\n            // CONCATENATED MODULE: ./src/util/srcsetUtils.js\n            var srcsetUtils_isEmpty = isEmpty;\n            /**\n * Options used to generate the srcset attribute.\n * @typedef {object} srcset\n * @property {(number[]|string[])}   [breakpoints] An array of breakpoints.\n * @property {number}                [min_width]   Minimal width of the srcset images.\n * @property {number}                [max_width]   Maximal width of the srcset images.\n * @property {number}                [max_images]  Number of srcset images to generate.\n * @property {object|string}         [transformation] The transformation to use in the srcset urls.\n * @property {boolean}               [sizes] Whether to calculate and add the sizes attribute.\n */ /**\n * Helper function. Generates a single srcset item url\n *\n * @private\n * @param {string} public_id  Public ID of the resource.\n * @param {number} width      Width in pixels of the srcset item.\n * @param {object|string} transformation\n * @param {object} options    Additional options.\n *\n * @return {string} Resulting URL of the item\n */ function scaledUrl(public_id, width, transformation) {\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                var configParams = extractUrlParams(options);\n                transformation = transformation || options;\n                configParams.raw_transformation = new src_transformation([\n                    merge_root_merge_default.a({}, transformation),\n                    {\n                        crop: \"scale\",\n                        width: width\n                    }\n                ]).toString();\n                return url_url(public_id, configParams);\n            }\n            /**\n * If cache is enabled, get the breakpoints from the cache. If the values were not found in the cache,\n * or cache is not enabled, generate the values.\n * @param {srcset} srcset The srcset configuration parameters\n * @param {string} public_id\n * @param {object} options\n * @return {*|Array}\n */ function getOrGenerateBreakpoints(public_id) {\n                var srcset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return generateBreakpoints(srcset);\n            }\n            /**\n * Helper function. Generates srcset attribute value of the HTML img tag\n * @private\n *\n * @param {string} public_id  Public ID of the resource\n * @param {number[]} breakpoints An array of breakpoints (in pixels)\n * @param {object} transformation The transformation\n * @param {object} options Includes html tag options, transformation options\n * @return {string} Resulting srcset attribute value\n */ function generateSrcsetAttribute(public_id, breakpoints, transformation, options) {\n                options = cloneDeep_root_cloneDeep_default.a(options);\n                patchFetchFormat(options);\n                return breakpoints.map(function(width) {\n                    return \"\".concat(scaledUrl(public_id, width, transformation, options), \" \").concat(width, \"w\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates sizes attribute value of the HTML img tag\n * @private\n * @param {number[]} breakpoints An array of breakpoints.\n * @return {string} Resulting sizes attribute value\n */ function generateSizesAttribute(breakpoints) {\n                if (breakpoints == null) {\n                    return \"\";\n                }\n                return breakpoints.map(function(width) {\n                    return \"(max-width: \".concat(width, \"px) \").concat(width, \"px\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates srcset and sizes attributes of the image tag\n *\n * Generated attributes are added to attributes argument\n *\n * @private\n * @param {string}    publicId  The public ID of the resource\n * @param {object}    attributes Existing HTML attributes.\n * @param {srcset}    srcsetData\n * @param {object}    options    Additional options.\n *\n * @return array The responsive attributes\n */ function generateImageResponsiveAttributes(publicId) {\n                var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var srcsetData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                // Create both srcset and sizes here to avoid fetching breakpoints twice\n                var responsiveAttributes = {};\n                if (srcsetUtils_isEmpty(srcsetData)) {\n                    return responsiveAttributes;\n                }\n                var generateSizes = !attributes.sizes && srcsetData.sizes === true;\n                var generateSrcset = !attributes.srcset;\n                if (generateSrcset || generateSizes) {\n                    var breakpoints = getOrGenerateBreakpoints(publicId, srcsetData, options);\n                    if (generateSrcset) {\n                        var transformation = srcsetData.transformation;\n                        var srcsetAttr = generateSrcsetAttribute(publicId, breakpoints, transformation, options);\n                        if (!srcsetUtils_isEmpty(srcsetAttr)) {\n                            responsiveAttributes.srcset = srcsetAttr;\n                        }\n                    }\n                    if (generateSizes) {\n                        var sizesAttr = generateSizesAttribute(breakpoints);\n                        if (!srcsetUtils_isEmpty(sizesAttr)) {\n                            responsiveAttributes.sizes = sizesAttr;\n                        }\n                    }\n                }\n                return responsiveAttributes;\n            }\n            /**\n * Generate a media query\n *\n * @private\n * @param {object} options configuration options\n * @param {number|string} options.min_width\n * @param {number|string} options.max_width\n * @return {string} a media query string\n */ function generateMediaAttr(options) {\n                var mediaQuery = [];\n                if (options != null) {\n                    if (options.min_width != null) {\n                        mediaQuery.push(\"(min-width: \".concat(options.min_width, \"px)\"));\n                    }\n                    if (options.max_width != null) {\n                        mediaQuery.push(\"(max-width: \".concat(options.max_width, \"px)\"));\n                    }\n                }\n                return mediaQuery.join(\" and \");\n            }\n            var srcsetUrl = scaledUrl;\n            // CONCATENATED MODULE: ./src/tags/imagetag.js\n            function imagetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return imagetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, imagetag_typeof(obj);\n            }\n            function imagetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function imagetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function imagetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) imagetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) imagetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function imagetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    imagetag_get = Reflect.get.bind();\n                } else {\n                    imagetag_get = function _get(target, property, receiver) {\n                        var base = imagetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return imagetag_get.apply(this, arguments);\n            }\n            function imagetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = imagetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function imagetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) imagetag_setPrototypeOf(subClass, superClass);\n            }\n            function imagetag_setPrototypeOf(o, p) {\n                imagetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return imagetag_setPrototypeOf(o, p);\n            }\n            function imagetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = imagetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = imagetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = imagetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return imagetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function imagetag_possibleConstructorReturn(self, call) {\n                if (call && (imagetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return imagetag_assertThisInitialized(self);\n            }\n            function imagetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function imagetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function imagetag_getPrototypeOf(o) {\n                imagetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return imagetag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor ImageTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var imagetag_ImageTag = /*#__PURE__*/ function(_HtmlTag) {\n                imagetag_inherits(ImageTag, _HtmlTag);\n                var _super = imagetag_createSuper(ImageTag);\n                function ImageTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    imagetag_classCallCheck(this, ImageTag);\n                    return _super.call(this, \"img\", publicId, options);\n                }\n                /** @override */ imagetag_createClass(ImageTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr, options, srcAttribute;\n                            attr = imagetag_get(imagetag_getPrototypeOf(ImageTag.prototype), \"attributes\", this).call(this) || {};\n                            options = this.getOptions();\n                            var attributes = this.getOption(\"attributes\") || {};\n                            var srcsetParam = this.getOption(\"srcset\") || attributes.srcset;\n                            var responsiveAttributes = {};\n                            if (isString_root_isString_default()(srcsetParam)) {\n                                responsiveAttributes.srcset = srcsetParam;\n                            } else {\n                                responsiveAttributes = generateImageResponsiveAttributes(this.publicId, attributes, srcsetParam, options);\n                            }\n                            if (!isEmpty(responsiveAttributes)) {\n                                delete attr.width;\n                                delete attr.height;\n                            }\n                            merge_root_merge_default()(attr, responsiveAttributes);\n                            srcAttribute = options.responsive && !options.client_hints ? \"data-src\" : \"src\";\n                            if (attr[srcAttribute] == null) {\n                                attr[srcAttribute] = url_url(this.publicId, this.getOptions());\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n                return ImageTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var imagetag = imagetag_ImageTag;\n            // CONCATENATED MODULE: ./src/tags/sourcetag.js\n            function sourcetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return sourcetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, sourcetag_typeof(obj);\n            }\n            function sourcetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function sourcetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function sourcetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) sourcetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) sourcetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function sourcetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    sourcetag_get = Reflect.get.bind();\n                } else {\n                    sourcetag_get = function _get(target, property, receiver) {\n                        var base = sourcetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return sourcetag_get.apply(this, arguments);\n            }\n            function sourcetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = sourcetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function sourcetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) sourcetag_setPrototypeOf(subClass, superClass);\n            }\n            function sourcetag_setPrototypeOf(o, p) {\n                sourcetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return sourcetag_setPrototypeOf(o, p);\n            }\n            function sourcetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = sourcetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = sourcetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = sourcetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return sourcetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function sourcetag_possibleConstructorReturn(self, call) {\n                if (call && (sourcetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return sourcetag_assertThisInitialized(self);\n            }\n            function sourcetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function sourcetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function sourcetag_getPrototypeOf(o) {\n                sourcetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return sourcetag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor SourceTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var sourcetag_SourceTag = /*#__PURE__*/ function(_HtmlTag) {\n                sourcetag_inherits(SourceTag, _HtmlTag);\n                var _super = sourcetag_createSuper(SourceTag);\n                function SourceTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    sourcetag_classCallCheck(this, SourceTag);\n                    return _super.call(this, \"source\", publicId, options);\n                }\n                /** @override */ sourcetag_createClass(SourceTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var srcsetParam = this.getOption(\"srcset\");\n                            var attr = sourcetag_get(sourcetag_getPrototypeOf(SourceTag.prototype), \"attributes\", this).call(this) || {};\n                            var options = this.getOptions();\n                            merge_root_merge_default()(attr, generateImageResponsiveAttributes(this.publicId, attr, srcsetParam, options));\n                            if (!attr.srcset) {\n                                attr.srcset = url_url(this.publicId, options);\n                            }\n                            if (!attr.media && options.media) {\n                                attr.media = generateMediaAttr(options.media);\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n                return SourceTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var sourcetag = sourcetag_SourceTag;\n            // CONCATENATED MODULE: ./src/tags/picturetag.js\n            function picturetag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return picturetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, picturetag_typeof(obj);\n            }\n            function picturetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function picturetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function picturetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) picturetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) picturetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function picturetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    picturetag_get = Reflect.get.bind();\n                } else {\n                    picturetag_get = function _get(target, property, receiver) {\n                        var base = picturetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return picturetag_get.apply(this, arguments);\n            }\n            function picturetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = picturetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function picturetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) picturetag_setPrototypeOf(subClass, superClass);\n            }\n            function picturetag_setPrototypeOf(o, p) {\n                picturetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return picturetag_setPrototypeOf(o, p);\n            }\n            function picturetag_createSuper(Derived) {\n                var hasNativeReflectConstruct = picturetag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = picturetag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = picturetag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return picturetag_possibleConstructorReturn(this, result);\n                };\n            }\n            function picturetag_possibleConstructorReturn(self, call) {\n                if (call && (picturetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return picturetag_assertThisInitialized(self);\n            }\n            function picturetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function picturetag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function picturetag_getPrototypeOf(o) {\n                picturetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return picturetag_getPrototypeOf(o);\n            }\n            var picturetag_PictureTag = /*#__PURE__*/ function(_HtmlTag) {\n                picturetag_inherits(PictureTag, _HtmlTag);\n                var _super = picturetag_createSuper(PictureTag);\n                function PictureTag(publicId) {\n                    var _this;\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    var sources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n                    picturetag_classCallCheck(this, PictureTag);\n                    _this = _super.call(this, \"picture\", publicId, options);\n                    _this.widthList = sources;\n                    return _this;\n                }\n                /** @override */ picturetag_createClass(PictureTag, [\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this2 = this;\n                            return this.widthList.map(function(_ref) {\n                                var min_width = _ref.min_width, max_width = _ref.max_width, transformation = _ref.transformation;\n                                var options = _this2.getOptions();\n                                var sourceTransformation = new src_transformation(options);\n                                sourceTransformation.chain().fromOptions(typeof transformation === \"string\" ? {\n                                    raw_transformation: transformation\n                                } : transformation);\n                                options = extractUrlParams(options);\n                                options.media = {\n                                    min_width: min_width,\n                                    max_width: max_width\n                                };\n                                options.transformation = sourceTransformation;\n                                return new sourcetag(_this2.publicId, options).toHtml();\n                            }).join(\"\") + new imagetag(this.publicId, this.getOptions()).toHtml();\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr = picturetag_get(picturetag_getPrototypeOf(PictureTag.prototype), \"attributes\", this).call(this);\n                            delete attr.width;\n                            delete attr.height;\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\" + this.name + \">\";\n                        }\n                    }\n                ]);\n                return PictureTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var picturetag = picturetag_PictureTag;\n            // CONCATENATED MODULE: ./src/tags/videotag.js\n            function videotag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return videotag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, videotag_typeof(obj);\n            }\n            function videotag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function videotag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function videotag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) videotag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) videotag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function videotag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    videotag_get = Reflect.get.bind();\n                } else {\n                    videotag_get = function _get(target, property, receiver) {\n                        var base = videotag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return videotag_get.apply(this, arguments);\n            }\n            function videotag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = videotag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function videotag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) videotag_setPrototypeOf(subClass, superClass);\n            }\n            function videotag_setPrototypeOf(o, p) {\n                videotag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return videotag_setPrototypeOf(o, p);\n            }\n            function videotag_createSuper(Derived) {\n                var hasNativeReflectConstruct = videotag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = videotag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = videotag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return videotag_possibleConstructorReturn(this, result);\n                };\n            }\n            function videotag_possibleConstructorReturn(self, call) {\n                if (call && (videotag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return videotag_assertThisInitialized(self);\n            }\n            function videotag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function videotag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function videotag_getPrototypeOf(o) {\n                videotag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return videotag_getPrototypeOf(o);\n            }\n            /**\n * Video Tag\n * Depends on 'tags/htmltag', 'util', 'cloudinary'\n */ var VIDEO_TAG_PARAMS = [\n                \"source_types\",\n                \"source_transformation\",\n                \"fallback_content\",\n                \"poster\",\n                \"sources\"\n            ];\n            var videotag_DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var videotag_DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            /**\n * Creates an HTML (DOM) Video tag using Cloudinary as the source.\n * @constructor VideoTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var videotag_VideoTag = /*#__PURE__*/ function(_HtmlTag) {\n                videotag_inherits(VideoTag, _HtmlTag);\n                var _super = videotag_createSuper(VideoTag);\n                function VideoTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    videotag_classCallCheck(this, VideoTag);\n                    options = defaults({}, options, DEFAULT_VIDEO_PARAMS);\n                    return _super.call(this, \"video\", publicId.replace(/\\.(mp4|ogv|webm)$/, \"\"), options);\n                }\n                /**\n   * Set the transformation to apply on each source\n   * @function VideoTag#setSourceTransformation\n   * @param {Object} an object with pairs of source type and source transformation\n   * @returns {VideoTag} Returns this instance for chaining purposes.\n   */ videotag_createClass(VideoTag, [\n                    {\n                        key: \"setSourceTransformation\",\n                        value: function setSourceTransformation(value) {\n                            this.transformation().sourceTransformation(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setSourceTypes\",\n                        value: function setSourceTypes(value) {\n                            this.transformation().sourceTypes(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setPoster\",\n                        value: function setPoster(value) {\n                            this.transformation().poster(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setFallbackContent\",\n                        value: function setFallbackContent(value) {\n                            this.transformation().fallbackContent(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this = this;\n                            var sourceTypes = this.transformation().getValue(\"source_types\");\n                            var sourceTransformation = this.transformation().getValue(\"source_transformation\");\n                            var fallback = this.transformation().getValue(\"fallback_content\");\n                            var sources = this.getOption(\"sources\");\n                            var innerTags = [];\n                            if (isArray_root_isArray_default()(sources) && !isEmpty(sources)) {\n                                innerTags = sources.map(function(source) {\n                                    var src = url_url(_this.publicId, defaults({}, source.transformations || {}, {\n                                        resource_type: \"video\",\n                                        format: source.type\n                                    }), _this.getOptions());\n                                    return _this.createSourceTag(src, source.type, source.codecs);\n                                });\n                            } else {\n                                if (isEmpty(sourceTypes)) {\n                                    sourceTypes = videotag_DEFAULT_VIDEO_SOURCE_TYPES;\n                                }\n                                if (isArray_root_isArray_default()(sourceTypes)) {\n                                    innerTags = sourceTypes.map(function(srcType) {\n                                        var src = url_url(_this.publicId, defaults({}, sourceTransformation[srcType] || {}, {\n                                            resource_type: \"video\",\n                                            format: srcType\n                                        }), _this.getOptions());\n                                        return _this.createSourceTag(src, srcType);\n                                    });\n                                }\n                            }\n                            return innerTags.join(\"\") + fallback;\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var sourceTypes = this.getOption(\"source_types\");\n                            var poster = this.getOption(\"poster\");\n                            if (poster === undefined) {\n                                poster = {};\n                            }\n                            if (isPlainObject_root_isPlainObject_default()(poster)) {\n                                var defaultOptions = poster.public_id != null ? DEFAULT_IMAGE_PARAMS : videotag_DEFAULT_POSTER_OPTIONS;\n                                poster = url_url(poster.public_id || this.publicId, defaults({}, poster, defaultOptions, this.getOptions()));\n                            }\n                            var attr = videotag_get(videotag_getPrototypeOf(VideoTag.prototype), \"attributes\", this).call(this) || {};\n                            attr = omit(attr, VIDEO_TAG_PARAMS);\n                            var sources = this.getOption(\"sources\"); // In case of empty sourceTypes - fallback to default source types is used.\n                            var hasSourceTags = !isEmpty(sources) || isEmpty(sourceTypes) || isArray_root_isArray_default()(sourceTypes);\n                            if (!hasSourceTags) {\n                                attr[\"src\"] = url_url(this.publicId, this.getOptions(), {\n                                    resource_type: \"video\",\n                                    format: sourceTypes\n                                });\n                            }\n                            if (poster != null) {\n                                attr[\"poster\"] = poster;\n                            }\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"createSourceTag\",\n                        value: function createSourceTag(src, sourceType) {\n                            var codecs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n                            var mimeType = null;\n                            if (!isEmpty(sourceType)) {\n                                var videoType = sourceType === \"ogv\" ? \"ogg\" : sourceType;\n                                mimeType = \"video/\" + videoType;\n                                if (!isEmpty(codecs)) {\n                                    var codecsStr = isArray_root_isArray_default()(codecs) ? codecs.join(\", \") : codecs;\n                                    mimeType += \"; codecs=\" + codecsStr;\n                                }\n                            }\n                            return \"<source \" + this.htmlAttrs({\n                                src: src,\n                                type: mimeType\n                            }) + \">\";\n                        }\n                    }\n                ]);\n                return VideoTag;\n            }(htmltag);\n            /* harmony default export */ var videotag = videotag_VideoTag;\n            // CONCATENATED MODULE: ./src/tags/clienthintsmetatag.js\n            function clienthintsmetatag_typeof(obj) {\n                \"@babel/helpers - typeof\";\n                return clienthintsmetatag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                    return typeof obj;\n                } : function(obj) {\n                    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                }, clienthintsmetatag_typeof(obj);\n            }\n            function clienthintsmetatag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function clienthintsmetatag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function clienthintsmetatag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) clienthintsmetatag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) clienthintsmetatag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function clienthintsmetatag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) clienthintsmetatag_setPrototypeOf(subClass, superClass);\n            }\n            function clienthintsmetatag_setPrototypeOf(o, p) {\n                clienthintsmetatag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return clienthintsmetatag_setPrototypeOf(o, p);\n            }\n            function clienthintsmetatag_createSuper(Derived) {\n                var hasNativeReflectConstruct = clienthintsmetatag_isNativeReflectConstruct();\n                return function _createSuperInternal() {\n                    var Super = clienthintsmetatag_getPrototypeOf(Derived), result;\n                    if (hasNativeReflectConstruct) {\n                        var NewTarget = clienthintsmetatag_getPrototypeOf(this).constructor;\n                        result = Reflect.construct(Super, arguments, NewTarget);\n                    } else {\n                        result = Super.apply(this, arguments);\n                    }\n                    return clienthintsmetatag_possibleConstructorReturn(this, result);\n                };\n            }\n            function clienthintsmetatag_possibleConstructorReturn(self, call) {\n                if (call && (clienthintsmetatag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return clienthintsmetatag_assertThisInitialized(self);\n            }\n            function clienthintsmetatag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function clienthintsmetatag_isNativeReflectConstruct() {\n                if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                if (Reflect.construct.sham) return false;\n                if (typeof Proxy === \"function\") return true;\n                try {\n                    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            }\n            function clienthintsmetatag_getPrototypeOf(o) {\n                clienthintsmetatag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return clienthintsmetatag_getPrototypeOf(o);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Meta tag that enables Client-Hints for the HTML page. <br/>\n *  See\n *  <a href=\"https://cloudinary.com/documentation/responsive_images#automating_responsive_images_with_client_hints\"\n *  target=\"_new\">Automating responsive images with Client Hints</a> for more details.\n * @constructor ClientHintsMetaTag\n * @extends HtmlTag\n * @param {object} options\n * @example\n * tag = new ClientHintsMetaTag()\n * //returns: <meta http-equiv=\"Accept-CH\" content=\"DPR, Viewport-Width, Width\">\n */ var clienthintsmetatag_ClientHintsMetaTag = /*#__PURE__*/ function(_HtmlTag) {\n                clienthintsmetatag_inherits(ClientHintsMetaTag, _HtmlTag);\n                var _super = clienthintsmetatag_createSuper(ClientHintsMetaTag);\n                function ClientHintsMetaTag(options) {\n                    clienthintsmetatag_classCallCheck(this, ClientHintsMetaTag);\n                    return _super.call(this, \"meta\", void 0, assign_root_assign_default()({\n                        \"http-equiv\": \"Accept-CH\",\n                        content: \"DPR, Viewport-Width, Width\"\n                    }, options));\n                }\n                /** @override */ clienthintsmetatag_createClass(ClientHintsMetaTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    }\n                ]);\n                return ClientHintsMetaTag;\n            }(htmltag);\n            ;\n            /* harmony default export */ var clienthintsmetatag = clienthintsmetatag_ClientHintsMetaTag;\n            // CONCATENATED MODULE: ./src/util/parse/normalizeToArray.js\n            function normalizeToArray_toConsumableArray(arr) {\n                return normalizeToArray_arrayWithoutHoles(arr) || normalizeToArray_iterableToArray(arr) || normalizeToArray_unsupportedIterableToArray(arr) || normalizeToArray_nonIterableSpread();\n            }\n            function normalizeToArray_nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function normalizeToArray_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return normalizeToArray_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return normalizeToArray_arrayLikeToArray(o, minLen);\n            }\n            function normalizeToArray_iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function normalizeToArray_arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return normalizeToArray_arrayLikeToArray(arr);\n            }\n            function normalizeToArray_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            /**\n * @desc normalize elements, support a single element, array or nodelist, always outputs array\n * @param elements<HTMLElement[]>\n * @returns {[]}\n */ function normalizeToArray(elements) {\n                if (isArray_root_isArray_default()(elements)) {\n                    return elements;\n                } else if (elements.constructor.name === \"NodeList\") {\n                    return normalizeToArray_toConsumableArray(elements); // ensure an array is always returned, even if nodelist\n                } else if (isString_root_isString_default()(elements)) {\n                    return Array.prototype.slice.call(document.querySelectorAll(elements), 0);\n                } else {\n                    return [\n                        elements\n                    ];\n                }\n            }\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountCloudinaryVideoTag.js\n            /**\n * @param {HTMLElement} htmlElContainer\n * @param {object} clInstance cloudinary instance\n * @param {string} publicId\n * @param {object} options - TransformationOptions\n * @returns Promise<HTMLElement>\n */ function mountCloudinaryVideoTag(htmlElContainer, clInstance, publicId, options) {\n                return new Promise(function(resolve, reject) {\n                    htmlElContainer.innerHTML = clInstance.videoTag(publicId, options).toHtml(); // All videos under the html container must have a width of 100%, or they might overflow from the container\n                    var cloudinaryVideoElement = htmlElContainer.querySelector(\".cld-transparent-video\");\n                    cloudinaryVideoElement.style.width = \"100%\";\n                    resolve(htmlElContainer);\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountCloudinaryVideoTag = mountCloudinaryVideoTag;\n            // CONCATENATED MODULE: ./src/util/transformations/addFlag.js\n            /**\n * @description - Function will push a flag to incoming options\n * @param {{transformation} | {...transformation}} options - These options are the same options provided to all our SDK methods\n *                           We expect options to either be the transformation itself, or an object containing\n *                           an array of transformations\n *\n * @param {string} flag\n * @returns the mutated options object\n */ function addFlagToOptions(options, flag) {\n                // Do we have transformation\n                if (options.transformation) {\n                    options.transformation.push({\n                        flags: [\n                            flag\n                        ]\n                    });\n                } else {\n                    // no transformation\n                    // ensure the flags are extended\n                    if (!options.flags) {\n                        options.flags = [];\n                    }\n                    if (typeof options.flags === \"string\") {\n                        options.flags = [\n                            options.flags\n                        ];\n                    }\n                    options.flags.push(flag);\n                }\n            }\n            /* harmony default export */ var addFlag = addFlagToOptions;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/enforceOptionsForTransparentVideo.js\n            /**\n * @description - Enforce option structure, sets defaults and ensures alpha flag exists\n * @param options {TransformationOptions}\n */ function enforceOptionsForTransparentVideo(options) {\n                options.autoplay = true;\n                options.muted = true;\n                options.controls = false;\n                options.max_timeout_ms = options.max_timeout_ms || DEFAULT_TIMEOUT_MS;\n                options[\"class\"] = options[\"class\"] || \"\";\n                options[\"class\"] += \" cld-transparent-video\";\n                options.externalLibraries = options.externalLibraries || {};\n                if (!options.externalLibraries.seeThru) {\n                    options.externalLibraries.seeThru = DEFAULT_EXTERNAL_LIBRARIES.seeThru;\n                } // ensure there's an alpha transformation present\n                // this is a non documented internal flag\n                addFlag(options, \"alpha\");\n            }\n            /* harmony default export */ var transparentVideo_enforceOptionsForTransparentVideo = enforceOptionsForTransparentVideo;\n            // CONCATENATED MODULE: ./src/util/xhr/loadScript.js\n            /**\n * @description - Given a string URL, this function will load the script and resolve the promise.\n *                The function doesn't resolve any value,\n *                this is not a UMD loader where you can get your library name back.\n * @param scriptURL {string}\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param isAlreadyLoaded {boolean} if true, the loadScript resolves immediately\n *                                  this is used for multiple invocations - prevents the script from being loaded multiple times\n * @return {Promise<any | {status:string, message:string}>}\n */ function loadScript(scriptURL, max_timeout_ms, isAlreadyLoaded) {\n                return new Promise(function(resolve, reject) {\n                    if (isAlreadyLoaded) {\n                        resolve();\n                    } else {\n                        var scriptTag = document.createElement(\"script\");\n                        scriptTag.src = scriptURL;\n                        var timerID = setTimeout(function() {\n                            reject({\n                                status: \"error\",\n                                message: \"Timeout loading script \".concat(scriptURL)\n                            });\n                        }, max_timeout_ms); // 10 seconds for timeout\n                        scriptTag.onerror = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            reject({\n                                status: \"error\",\n                                message: \"Error loading \".concat(scriptURL)\n                            });\n                        };\n                        scriptTag.onload = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            resolve();\n                        };\n                        document.head.appendChild(scriptTag);\n                    }\n                });\n            }\n            /* harmony default export */ var xhr_loadScript = loadScript;\n            // CONCATENATED MODULE: ./src/util/xhr/getBlobFromURL.js\n            /**\n * Reject on timeout\n * @param maxTimeoutMS\n * @param reject\n * @returns {number} timerID\n */ function rejectOnTimeout(maxTimeoutMS, reject) {\n                return setTimeout(function() {\n                    reject({\n                        status: \"error\",\n                        message: \"Timeout loading Blob URL\"\n                    });\n                }, maxTimeoutMS);\n            }\n            /**\n * @description Converts a URL to a BLOB URL\n * @param {string} urlToLoad\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @return {Promise<{\n *   status: 'success' | 'error'\n *   message?: string,\n *    payload: {\n *      url: string\n *    }\n * }>}\n */ function getBlobFromURL(urlToLoad, maxTimeoutMS) {\n                return new Promise(function(resolve, reject) {\n                    var timerID = rejectOnTimeout(maxTimeoutMS, reject); // If fetch exists, use it to fetch blob, otherwise use XHR.\n                    // XHR causes issues on safari 14.1 so we prefer fetch\n                    var fetchBlob = typeof fetch !== \"undefined\" && fetch ? loadUrlUsingFetch : loadUrlUsingXhr;\n                    fetchBlob(urlToLoad).then(function(blob) {\n                        resolve({\n                            status: \"success\",\n                            payload: {\n                                blobURL: URL.createObjectURL(blob)\n                            }\n                        });\n                    })[\"catch\"](function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Error loading Blob URL\"\n                        });\n                    })[\"finally\"](function() {\n                        // Clear the timeout timer on fail or success.\n                        clearTimeout(timerID);\n                    });\n                });\n            }\n            /**\n * Use fetch function to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingFetch(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    fetch(urlToLoad).then(function(response) {\n                        response.blob().then(function(blob) {\n                            resolve(blob);\n                        });\n                    })[\"catch\"](function() {\n                        reject(\"error\");\n                    });\n                });\n            }\n            /**\n * Use XHR to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingXhr(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    var xhr = new XMLHttpRequest();\n                    xhr.responseType = \"blob\";\n                    xhr.onload = function(response) {\n                        resolve(xhr.response);\n                    };\n                    xhr.onerror = function() {\n                        reject(\"error\");\n                    };\n                    xhr.open(\"GET\", urlToLoad, true);\n                    xhr.send();\n                });\n            }\n            /* harmony default export */ var xhr_getBlobFromURL = getBlobFromURL;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/createHiddenVideoTag.js\n            /**\n * @description Creates a hidden HTMLVideoElement with the specified videoOptions\n * @param {{autoplay, playsinline, loop, muted, poster, blobURL, videoURL }} videoOptions\n * @param {boolean} videoOptions.autoplay - autoplays the video if true\n * @param {string} videoOptions.blobURL - the blobURL to set as video.src\n * @param {string} videoOptions.videoURL - the original videoURL the user created (with transformations)\n * @return {HTMLVideoElement}\n */ function createHiddenVideoTag(videoOptions) {\n                var autoplay = videoOptions.autoplay, playsinline = videoOptions.playsinline, loop = videoOptions.loop, muted = videoOptions.muted, poster = videoOptions.poster, blobURL = videoOptions.blobURL, videoURL = videoOptions.videoURL;\n                var el = document.createElement(\"video\");\n                el.style.visibility = \"hidden\";\n                el.position = \"absolute\";\n                el.x = 0;\n                el.y = 0;\n                el.src = blobURL;\n                el.setAttribute(\"data-video-url\", videoURL); // for debugging/testing\n                autoplay && el.setAttribute(\"autoplay\", autoplay);\n                playsinline && el.setAttribute(\"playsinline\", playsinline);\n                loop && el.setAttribute(\"loop\", loop);\n                muted && el.setAttribute(\"muted\", muted);\n                muted && (el.muted = muted); // this is also needed for autoplay, on top of setAttribute\n                poster && el.setAttribute(\"poster\", poster); // Free memory at the end of the file loading.\n                el.onload = function() {\n                    URL.revokeObjectURL(blobURL);\n                };\n                return el;\n            }\n            /* harmony default export */ var transparentVideo_createHiddenVideoTag = createHiddenVideoTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/instantiateSeeThru.js\n            /**\n * @description This function creates a new instanc eof seeThru (seeThru.create()) and returns a promise of the seeThru instance\n * @param {HTMLVideoElement} videoElement\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param {string} customClass - A classname to be added to the canvas element created by seeThru\n * @param {boolean} autoPlay\n * @return {Promise<any>} SeeThru instance or rejection error\n */ function instantiateSeeThru(videoElement, max_timeout_ms, customClass, autoPlay) {\n                var _window = window, seeThru = _window.seeThru, setTimeout1 = _window.setTimeout, clearTimeout1 = _window.clearTimeout;\n                return new Promise(function(resolve, reject) {\n                    var timerID = setTimeout1(function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Timeout instantiating seeThru instance\"\n                        });\n                    }, max_timeout_ms);\n                    if (seeThru) {\n                        var seeThruInstance = seeThru.create(videoElement).ready(function() {\n                            // clear timeout reject error\n                            clearTimeout1(timerID); // force container width, else the canvas can overflow out\n                            var canvasElement = seeThruInstance.getCanvas();\n                            canvasElement.style.width = \"100%\";\n                            canvasElement.className += \" \" + customClass; // start the video if autoplay is set\n                            if (autoPlay) {\n                                seeThruInstance.play();\n                            }\n                            resolve(seeThruInstance);\n                        });\n                    } else {\n                        reject({\n                            status: \"error\",\n                            message: \"Error instantiating seeThru instance\"\n                        });\n                    }\n                });\n            }\n            /* harmony default export */ var transparentVideo_instantiateSeeThru = instantiateSeeThru;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountSeeThruCanvasTag.js\n            /**\n *\n * @param {HTMLElement} htmlElContainer\n * @param {string} videoURL\n * @param {TransformationOptions} options\n * @return {Promise<any>}\n */ function mountSeeThruCanvasTag(htmlElContainer, videoURL, options) {\n                var poster = options.poster, autoplay = options.autoplay, playsinline = options.playsinline, loop = options.loop, muted = options.muted;\n                videoURL = videoURL + \".mp4\"; // seeThru always uses mp4\n                return new Promise(function(resolve, reject) {\n                    xhr_loadScript(options.externalLibraries.seeThru, options.max_timeout_ms, window.seeThru).then(function() {\n                        xhr_getBlobFromURL(videoURL, options.max_timeout_ms).then(function(_ref) {\n                            var payload = _ref.payload;\n                            var videoElement = transparentVideo_createHiddenVideoTag({\n                                blobURL: payload.blobURL,\n                                videoURL: videoURL,\n                                // for debugging/testing\n                                poster: poster,\n                                autoplay: autoplay,\n                                playsinline: playsinline,\n                                loop: loop,\n                                muted: muted\n                            });\n                            htmlElContainer.appendChild(videoElement);\n                            transparentVideo_instantiateSeeThru(videoElement, options.max_timeout_ms, options[\"class\"], options.autoplay).then(function() {\n                                resolve(htmlElContainer);\n                            })[\"catch\"](function(err) {\n                                reject(err);\n                            }); // catch for getBlobFromURL()\n                        })[\"catch\"](function(_ref2) {\n                            var status = _ref2.status, message = _ref2.message;\n                            reject({\n                                status: status,\n                                message: message\n                            });\n                        }); // catch for loadScript()\n                    })[\"catch\"](function(_ref3) {\n                        var status = _ref3.status, message = _ref3.message;\n                        reject({\n                            status: status,\n                            message: message\n                        });\n                    });\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountSeeThruCanvasTag = mountSeeThruCanvasTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/checkSupportForTransparency.js\n            /**\n * @return {Promise<boolean>} - Whether the browser supports transparent videos or not\n */ function checkSupportForTransparency() {\n                return new Promise(function(resolve, reject) {\n                    // Resolve early for safari.\n                    // Currently (29 December 2021) Safari can play webm/vp9,\n                    // but it does not support transparent video in the format we're outputting\n                    if (isSafari()) {\n                        resolve(false);\n                    }\n                    var video = document.createElement(\"video\");\n                    var canPlay = video.canPlayType && video.canPlayType('video/webm; codecs=\"vp9\"');\n                    resolve(canPlay === \"maybe\" || canPlay === \"probably\");\n                });\n            }\n            /* harmony default export */ var transparentVideo_checkSupportForTransparency = checkSupportForTransparency;\n            // CONCATENATED MODULE: ./src/cloudinary.js\n            function cloudinary_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function cloudinary_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function cloudinary_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) cloudinary_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) cloudinary_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            var applyBreakpoints, closestAbove, defaultBreakpoints, cloudinary_findContainerWidth, cloudinary_maxWidth, updateDpr;\n            //\n            defaultBreakpoints = function defaultBreakpoints(width) {\n                var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n                return steps * Math.ceil(width / steps);\n            };\n            closestAbove = function closestAbove(list, value) {\n                var i;\n                i = list.length - 2;\n                while(i >= 0 && list[i] >= value){\n                    i--;\n                }\n                return list[i + 1];\n            };\n            applyBreakpoints = function applyBreakpoints(tag, width, steps, options) {\n                var ref, ref1, ref2, responsive_use_breakpoints;\n                responsive_use_breakpoints = (ref = (ref1 = (ref2 = options[\"responsive_use_breakpoints\"]) != null ? ref2 : options[\"responsive_use_stoppoints\"]) != null ? ref1 : this.config(\"responsive_use_breakpoints\")) != null ? ref : this.config(\"responsive_use_stoppoints\");\n                if (!responsive_use_breakpoints || responsive_use_breakpoints === \"resize\" && !options.resizing) {\n                    return width;\n                } else {\n                    return this.calc_breakpoint(tag, width, steps);\n                }\n            };\n            cloudinary_findContainerWidth = function findContainerWidth(element) {\n                var containerWidth, style;\n                containerWidth = 0;\n                while((element = element != null ? element.parentNode : void 0) instanceof Element && !containerWidth){\n                    style = window.getComputedStyle(element);\n                    if (!/^inline/.test(style.display)) {\n                        containerWidth = lodash_width(element);\n                    }\n                }\n                return containerWidth;\n            };\n            updateDpr = function updateDpr(dataSrc, roundDpr) {\n                return dataSrc.replace(/\\bdpr_(1\\.0|auto)\\b/g, \"dpr_\" + this.device_pixel_ratio(roundDpr));\n            };\n            cloudinary_maxWidth = function maxWidth(requiredWidth, tag) {\n                var imageWidth;\n                imageWidth = lodash_getData(tag, \"width\") || 0;\n                if (requiredWidth > imageWidth) {\n                    imageWidth = requiredWidth;\n                    lodash_setData(tag, \"width\", requiredWidth);\n                }\n                return imageWidth;\n            };\n            var cloudinary_Cloudinary = /*#__PURE__*/ function() {\n                /**\n   * Creates a new Cloudinary instance.\n   * @class Cloudinary\n   * @classdesc Main class for accessing Cloudinary functionality.\n   * @param {Object} options - A {@link Configuration} object for globally configuring Cloudinary account settings.\n   * @example<br/>\n   *  var cl = new cloudinary.Cloudinary( { cloud_name: \"mycloud\"});<br/>\n   *  var imgTag = cl.image(\"myPicID\");\n   * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\" target=\"_blank\">\n   *  Available configuration options</a>\n   */ function Cloudinary(options) {\n                    cloudinary_classCallCheck(this, Cloudinary);\n                    var configuration;\n                    this.devicePixelRatioCache = {};\n                    this.responsiveConfig = {};\n                    this.responsiveResizeInitialized = false;\n                    configuration = new src_configuration(options); // Provided for backward compatibility\n                    this.config = function(newConfig, newValue) {\n                        return configuration.config(newConfig, newValue);\n                    };\n                    /**\n     * Use \\<meta\\> tags in the document to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromDocument = function() {\n                        configuration.fromDocument();\n                        return this;\n                    };\n                    /**\n     * Use environment variables to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromEnvironment = function() {\n                        configuration.fromEnvironment();\n                        return this;\n                    };\n                    /**\n     * Initializes the configuration of this `cloudinary` instance.\n     *  This is a convenience method that invokes both {@link Configuration#fromEnvironment|fromEnvironment()}\n     *  (Node.js environment only) and {@link Configuration#fromDocument|fromDocument()}.\n     *  It first tries to retrieve the configuration from the environment variable.\n     *  If not available, it tries from the document meta tags.\n     * @function Cloudinary#init\n     * @see Configuration#init\n     * @return This {Cloudinary} instance for chaining.\n     */ this.init = function() {\n                        configuration.init();\n                        return this;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Cloudinary}\n   * @example cl = cloudinary.Cloudinary.new( { cloud_name: \"mycloud\"})\n   */ cloudinary_createClass(Cloudinary, [\n                    {\n                        key: \"url\",\n                        value: /**\n     * Generates a URL for any asset in your Media library.\n     * @function Cloudinary#url\n     * @param {string} publicId - The public ID of the media asset.\n     * @param {Object} [options] - The {@link Transformation} parameters to include in the URL.\n     * @param {type} [options.type='upload'] - The asset's storage type.\n     *  For details on all fetch types, see\n     * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n     *  target=\"_blank\">Fetch types</a>.\n     * @param {resourceType} [options.resource_type='image'] - The type of asset. Possible values:<br/>\n     *  - `image`<br/>\n     *  - `video`<br/>\n     *  - `raw`\n     * @return {string} The media asset URL.\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n     *  Available image transformations</a>\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n     *  Available video transformations</a>\n     */ function url(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return url_url(publicId, options, this.config());\n                        }\n                    },\n                    {\n                        key: \"video_url\",\n                        value: function video_url(publicId, options) {\n                            options = assign_root_assign_default()({\n                                resource_type: \"video\"\n                            }, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail_url\",\n                        value: function video_thumbnail_url(publicId, options) {\n                            options = assign_root_assign_default()({}, DEFAULT_POSTER_OPTIONS, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"transformation_string\",\n                        value: function transformation_string(options) {\n                            return new src_transformation(options).serialize();\n                        }\n                    },\n                    {\n                        key: \"image\",\n                        value: function image(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            var client_hints, img, ref;\n                            img = this.imageTag(publicId, options);\n                            client_hints = (ref = options.client_hints != null ? options.client_hints : this.config(\"client_hints\")) != null ? ref : false;\n                            if (options.src == null && !client_hints) {\n                                // src must be removed before creating the DOM element to avoid loading the image\n                                img.setAttr(\"src\", \"\");\n                            }\n                            img = img.toDOM();\n                            if (!client_hints) {\n                                // cache the image src\n                                lodash_setData(img, \"src-cache\", this.url(publicId, options)); // set image src taking responsiveness in account\n                                this.cloudinary_update(img, options);\n                            }\n                            return img;\n                        }\n                    },\n                    {\n                        key: \"imageTag\",\n                        value: function imageTag(publicId, options) {\n                            var tag;\n                            tag = new imagetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"pictureTag\",\n                        value: function pictureTag(publicId, options, sources) {\n                            var tag;\n                            tag = new picturetag(publicId, this.config(), sources);\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"sourceTag\",\n                        value: function sourceTag(publicId, options) {\n                            var tag;\n                            tag = new sourcetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail\",\n                        value: function video_thumbnail(publicId, options) {\n                            return this.image(publicId, merge_root_merge_default()({}, DEFAULT_POSTER_OPTIONS, options));\n                        }\n                    },\n                    {\n                        key: \"facebook_profile_image\",\n                        value: function facebook_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"facebook\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_profile_image\",\n                        value: function twitter_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_name_profile_image\",\n                        value: function twitter_name_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter_name\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"gravatar_image\",\n                        value: function gravatar_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"gravatar\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"fetch_image\",\n                        value: function fetch_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"fetch\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"video\",\n                        value: function video(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return this.videoTag(publicId, options).toHtml();\n                        }\n                    },\n                    {\n                        key: \"videoTag\",\n                        value: function videoTag(publicId, options) {\n                            options = defaults({}, options, this.config());\n                            return new videotag(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"sprite_css\",\n                        value: function sprite_css(publicId, options) {\n                            options = assign_root_assign_default()({\n                                type: \"sprite\"\n                            }, options);\n                            if (!publicId.match(/.css$/)) {\n                                options.format = \"css\";\n                            }\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"responsive\",\n                        value: function responsive(options) {\n                            var _this = this;\n                            var bootstrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n                            var ref, ref1, ref2, responsiveClass, responsiveResize, timeout;\n                            this.responsiveConfig = merge_root_merge_default()(this.responsiveConfig || {}, options);\n                            responsiveClass = (ref = this.responsiveConfig.responsive_class) != null ? ref : this.config(\"responsive_class\");\n                            if (bootstrap) {\n                                this.cloudinary_update(\"img.\".concat(responsiveClass, \", img.cld-hidpi\"), this.responsiveConfig);\n                            }\n                            responsiveResize = (ref1 = (ref2 = this.responsiveConfig.responsive_resize) != null ? ref2 : this.config(\"responsive_resize\")) != null ? ref1 : true;\n                            if (responsiveResize && !this.responsiveResizeInitialized) {\n                                this.responsiveConfig.resizing = this.responsiveResizeInitialized = true;\n                                timeout = null;\n                                var makeResponsive = function makeResponsive() {\n                                    var debounce, ref3, ref4, reset, run, wait, waitFunc;\n                                    debounce = (ref3 = (ref4 = _this.responsiveConfig.responsive_debounce) != null ? ref4 : _this.config(\"responsive_debounce\")) != null ? ref3 : 100;\n                                    reset = function reset() {\n                                        if (timeout) {\n                                            clearTimeout(timeout);\n                                            timeout = null;\n                                        }\n                                    };\n                                    run = function run() {\n                                        return _this.cloudinary_update(\"img.\".concat(responsiveClass), _this.responsiveConfig);\n                                    };\n                                    waitFunc = function waitFunc() {\n                                        reset();\n                                        return run();\n                                    };\n                                    wait = function wait() {\n                                        reset();\n                                        timeout = setTimeout(waitFunc, debounce);\n                                    };\n                                    if (debounce) {\n                                        return wait();\n                                    } else {\n                                        return run();\n                                    }\n                                };\n                                window.addEventListener(\"resize\", makeResponsive);\n                                return function() {\n                                    return window.removeEventListener(\"resize\", makeResponsive);\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_breakpoint\",\n                        value: function calc_breakpoint(element, width, steps) {\n                            var breakpoints = lodash_getData(element, \"breakpoints\") || lodash_getData(element, \"stoppoints\") || this.config(\"breakpoints\") || this.config(\"stoppoints\") || defaultBreakpoints;\n                            if (isFunction_root_isFunction_default()(breakpoints)) {\n                                return breakpoints(width, steps);\n                            } else {\n                                if (isString_root_isString_default()(breakpoints)) {\n                                    breakpoints = breakpoints.split(\",\").map(function(point) {\n                                        return parseInt(point);\n                                    }).sort(function(a, b) {\n                                        return a - b;\n                                    });\n                                }\n                                return closestAbove(breakpoints, width);\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_stoppoint\",\n                        value: function calc_stoppoint(element, width, steps) {\n                            return this.calc_breakpoint(element, width, steps);\n                        }\n                    },\n                    {\n                        key: \"device_pixel_ratio\",\n                        value: function device_pixel_ratio(roundDpr) {\n                            roundDpr = roundDpr == null ? true : roundDpr;\n                            var dpr = ( false ? 0 : void 0) || 1;\n                            if (roundDpr) {\n                                dpr = Math.ceil(dpr);\n                            }\n                            if (dpr <= 0 || dpr === 0 / 0) {\n                                dpr = 1;\n                            }\n                            var dprString = dpr.toString();\n                            if (dprString.match(/^\\d+$/)) {\n                                dprString += \".0\";\n                            }\n                            return dprString;\n                        }\n                    },\n                    {\n                        key: \"processImageTags\",\n                        value: function processImageTags(nodes, options) {\n                            if (isEmpty(nodes)) {\n                                // similar to `$.fn.cloudinary`\n                                return this;\n                            }\n                            options = defaults({}, options || {}, this.config());\n                            var images = nodes.filter(function(node) {\n                                return /^img$/i.test(node.tagName);\n                            }).map(function(node) {\n                                var imgOptions = assign_root_assign_default()({\n                                    width: node.getAttribute(\"width\"),\n                                    height: node.getAttribute(\"height\"),\n                                    src: node.getAttribute(\"src\")\n                                }, options);\n                                var publicId = imgOptions[\"source\"] || imgOptions[\"src\"];\n                                delete imgOptions[\"source\"];\n                                delete imgOptions[\"src\"];\n                                var attr = new src_transformation(imgOptions).toHtmlAttributes();\n                                lodash_setData(node, \"src-cache\", url_url(publicId, imgOptions));\n                                node.setAttribute(\"width\", attr.width);\n                                node.setAttribute(\"height\", attr.height);\n                                return node;\n                            });\n                            this.cloudinary_update(images, options);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"cloudinary_update\",\n                        value: function cloudinary_update(elements, options) {\n                            var _this2 = this;\n                            var containerWidth, dataSrc, match, ref4, requiredWidth;\n                            if (elements === null) {\n                                return this;\n                            }\n                            if (options == null) {\n                                options = {};\n                            }\n                            var responsive = options.responsive != null ? options.responsive : this.config(\"responsive\");\n                            elements = normalizeToArray(elements);\n                            var responsiveClass;\n                            if (this.responsiveConfig && this.responsiveConfig.responsive_class != null) {\n                                responsiveClass = this.responsiveConfig.responsive_class;\n                            } else if (options.responsive_class != null) {\n                                responsiveClass = options.responsive_class;\n                            } else {\n                                responsiveClass = this.config(\"responsive_class\");\n                            }\n                            var roundDpr = options.round_dpr != null ? options.round_dpr : this.config(\"round_dpr\");\n                            elements.forEach(function(tag) {\n                                if (/img/i.test(tag.tagName)) {\n                                    var setUrl = true;\n                                    if (responsive) {\n                                        lodash_addClass(tag, responsiveClass);\n                                    }\n                                    dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                                    if (!isEmpty(dataSrc)) {\n                                        // Update dpr according to the device's devicePixelRatio\n                                        dataSrc = updateDpr.call(_this2, dataSrc, roundDpr);\n                                        if (htmltag.isResponsive(tag, responsiveClass)) {\n                                            containerWidth = cloudinary_findContainerWidth(tag);\n                                            if (containerWidth !== 0) {\n                                                if (/w_auto:breakpoints/.test(dataSrc)) {\n                                                    requiredWidth = cloudinary_maxWidth(containerWidth, tag);\n                                                    if (requiredWidth) {\n                                                        dataSrc = dataSrc.replace(/w_auto:breakpoints([_0-9]*)(:[0-9]+)?/, \"w_auto:breakpoints$1:\".concat(requiredWidth));\n                                                    } else {\n                                                        setUrl = false;\n                                                    }\n                                                } else {\n                                                    match = /w_auto(:(\\d+))?/.exec(dataSrc);\n                                                    if (match) {\n                                                        requiredWidth = applyBreakpoints.call(_this2, tag, containerWidth, match[2], options);\n                                                        requiredWidth = cloudinary_maxWidth(requiredWidth, tag);\n                                                        if (requiredWidth) {\n                                                            dataSrc = dataSrc.replace(/w_auto[^,\\/]*/g, \"w_\".concat(requiredWidth));\n                                                        } else {\n                                                            setUrl = false;\n                                                        }\n                                                    }\n                                                }\n                                                lodash_removeAttribute(tag, \"width\");\n                                                if (!options.responsive_preserve_height) {\n                                                    lodash_removeAttribute(tag, \"height\");\n                                                }\n                                            } else {\n                                                // Container doesn't know the size yet - usually because the image is hidden or outside the DOM.\n                                                setUrl = false;\n                                            }\n                                        }\n                                        var isLazyLoading = options.loading === \"lazy\" && !_this2.isNativeLazyLoadSupported() && _this2.isLazyLoadSupported() && !elements[0].getAttribute(\"src\");\n                                        if (setUrl || isLazyLoading) {\n                                            // If data-width exists, set width to be data-width\n                                            _this2.setAttributeIfExists(elements[0], \"width\", \"data-width\");\n                                        }\n                                        if (setUrl && !isLazyLoading) {\n                                            lodash_setAttribute(tag, \"src\", dataSrc);\n                                        }\n                                    }\n                                }\n                            });\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setAttributeIfExists\",\n                        value: function setAttributeIfExists(element, toAttribute, fromAttribute) {\n                            var attributeValue = element.getAttribute(fromAttribute);\n                            if (attributeValue != null) {\n                                lodash_setAttribute(element, toAttribute, attributeValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"isLazyLoadSupported\",\n                        value: function isLazyLoadSupported() {\n                            return window && \"IntersectionObserver\" in window;\n                        }\n                    },\n                    {\n                        key: \"isNativeLazyLoadSupported\",\n                        value: function isNativeLazyLoadSupported() {\n                            return \"loading\" in HTMLImageElement.prototype;\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(options) {\n                            return src_transformation[\"new\"](this.config()).fromOptions(options).setParent(this);\n                        }\n                    },\n                    {\n                        key: \"injectTransparentVideoElement\",\n                        value: function injectTransparentVideoElement(htmlElContainer, publicId) {\n                            var _this3 = this;\n                            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            return new Promise(function(resolve, reject) {\n                                if (!htmlElContainer) {\n                                    reject({\n                                        status: \"error\",\n                                        message: \"Expecting htmlElContainer to be HTMLElement\"\n                                    });\n                                }\n                                transparentVideo_enforceOptionsForTransparentVideo(options);\n                                var videoURL = _this3.video_url(publicId, options);\n                                transparentVideo_checkSupportForTransparency().then(function(isNativelyTransparent) {\n                                    var mountPromise;\n                                    if (isNativelyTransparent) {\n                                        mountPromise = transparentVideo_mountCloudinaryVideoTag(htmlElContainer, _this3, publicId, options);\n                                        resolve(htmlElContainer);\n                                    } else {\n                                        mountPromise = transparentVideo_mountSeeThruCanvasTag(htmlElContainer, videoURL, options);\n                                    }\n                                    mountPromise.then(function() {\n                                        resolve(htmlElContainer);\n                                    })[\"catch\"](function(_ref) {\n                                        var status = _ref.status, message = _ref.message;\n                                        reject({\n                                            status: status,\n                                            message: message\n                                        });\n                                    }); // catch for checkSupportForTransparency()\n                                })[\"catch\"](function(_ref2) {\n                                    var status = _ref2.status, message = _ref2.message;\n                                    reject({\n                                        status: status,\n                                        message: message\n                                    });\n                                });\n                            });\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new this(options);\n                        }\n                    }\n                ]);\n                return Cloudinary;\n            }();\n            assign_root_assign_default()(cloudinary_Cloudinary, constants_namespaceObject);\n            /* harmony default export */ var cloudinary = cloudinary_Cloudinary;\n            // CONCATENATED MODULE: ./src/namespace/cloudinary-core.js\n            /**\n * Creates the namespace for Cloudinary\n */ /* harmony default export */ var cloudinary_core = __nested_webpack_exports__[\"default\"] = {\n                ClientHintsMetaTag: clienthintsmetatag,\n                Cloudinary: cloudinary,\n                Condition: condition,\n                Configuration: src_configuration,\n                crc32: src_crc32,\n                Expression: expression,\n                FetchLayer: fetchlayer,\n                HtmlTag: htmltag,\n                ImageTag: imagetag,\n                Layer: layer_layer,\n                PictureTag: picturetag,\n                SubtitlesLayer: subtitleslayer,\n                TextLayer: textlayer,\n                Transformation: src_transformation,\n                utf8_encode: src_utf8_encode,\n                Util: lodash_namespaceObject,\n                VideoTag: videotag\n            };\n        /***/ },\n        /***/ \"lodash/assign\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_assign__;\n        /***/ },\n        /***/ \"lodash/cloneDeep\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__;\n        /***/ },\n        /***/ \"lodash/compact\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_compact__;\n        /***/ },\n        /***/ \"lodash/difference\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_difference__;\n        /***/ },\n        /***/ \"lodash/functions\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_functions__;\n        /***/ },\n        /***/ \"lodash/identity\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_identity__;\n        /***/ },\n        /***/ \"lodash/includes\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_includes__;\n        /***/ },\n        /***/ \"lodash/isArray\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isArray__;\n        /***/ },\n        /***/ \"lodash/isElement\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isElement__;\n        /***/ },\n        /***/ \"lodash/isFunction\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__;\n        /***/ },\n        /***/ \"lodash/isPlainObject\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__;\n        /***/ },\n        /***/ \"lodash/isString\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isString__;\n        /***/ },\n        /***/ \"lodash/merge\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_merge__;\n        /***/ },\n        /***/ \"lodash/trim\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_trim__;\n        /***/ }\n    });\n}); //# sourceMappingURL=cloudinary-core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xvdWRpbmFyeS1jb3JlL2Nsb3VkaW5hcnktY29yZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HLEdBQ0YsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRCxRQUFRRyxtQkFBT0EsQ0FBQyxvQ0FBZSxHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsc0NBQWdCLEdBQUdBLG1CQUFPQSxDQUFDLDRDQUFtQixHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLHdDQUFpQixHQUFHQSxtQkFBT0EsQ0FBQyxzQ0FBZ0IsR0FBR0EsbUJBQU9BLENBQUMsMENBQWtCLEdBQUdBLG1CQUFPQSxDQUFDLDRDQUFtQixHQUFHQSxtQkFBT0EsQ0FBQyxrREFBc0IsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLGtDQUFjLEdBQUdBLG1CQUFPQSxDQUFDLGdDQUFhO1NBQzNaLEVBSzRWO0FBQ2xXLEdBQUcsUUFBTSxTQUFTRyx5Q0FBeUMsRUFBRUMsNENBQTRDLEVBQUVDLDBDQUEwQyxFQUFFQyw2Q0FBNkMsRUFBRUMsNENBQTRDLEVBQUVDLDJDQUEyQyxFQUFFQywyQ0FBMkMsRUFBRUMsMENBQTBDLEVBQUVDLDRDQUE0QyxFQUFFQyw2Q0FBNkMsRUFBRUMsZ0RBQWdELEVBQUVDLDJDQUEyQyxFQUFFQyx3Q0FBd0MsRUFBRUMsdUNBQXVDO0lBQ3ZvQixPQUFnQixNQUFILEdBQUksU0FBU0MsT0FBTztRQUNqQyxNQUFNLEdBQUksbUJBQW1CO1FBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtRQUNqQyxNQUFNLEdBQUksU0FBU0MsK0JBQW1CQSxDQUFDQyxR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RWpCLEdBQUcsR0FBRztRQUVOLEdBQUcsR0FBRyxlQUNOLEdBQUcsR0FBSSxTQUFTaEIsT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUdrQjtRQUVqQixHQUFHLEdBQUc7SUFFRztBQUNULElBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja2FodGhvbl96ZXJvLy4vbm9kZV9tb2R1bGVzL2Nsb3VkaW5hcnktY29yZS9jbG91ZGluYXJ5LWNvcmUuanM/ZjczYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgICogY2xvdWRpbmFyeS1jb3JlLmpzXG4gICAqIENsb3VkaW5hcnkncyBKYXZhU2NyaXB0IGxpYnJhcnkgLSBWZXJzaW9uIDIuMTMuMFxuICAgKiBDb3B5cmlnaHQgQ2xvdWRpbmFyeVxuICAgKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkaW5hcnkvY2xvdWRpbmFyeV9qc1xuICAgKlxuICAgKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImxvZGFzaC9hc3NpZ25cIiksIHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVEZWVwXCIpLCByZXF1aXJlKFwibG9kYXNoL2NvbXBhY3RcIiksIHJlcXVpcmUoXCJsb2Rhc2gvZGlmZmVyZW5jZVwiKSwgcmVxdWlyZShcImxvZGFzaC9mdW5jdGlvbnNcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaWRlbnRpdHlcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaW5jbHVkZXNcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNBcnJheVwiKSwgcmVxdWlyZShcImxvZGFzaC9pc0VsZW1lbnRcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSwgcmVxdWlyZShcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzU3RyaW5nXCIpLCByZXF1aXJlKFwibG9kYXNoL21lcmdlXCIpLCByZXF1aXJlKFwibG9kYXNoL3RyaW1cIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibG9kYXNoL2Fzc2lnblwiLCBcImxvZGFzaC9jbG9uZURlZXBcIiwgXCJsb2Rhc2gvY29tcGFjdFwiLCBcImxvZGFzaC9kaWZmZXJlbmNlXCIsIFwibG9kYXNoL2Z1bmN0aW9uc1wiLCBcImxvZGFzaC9pZGVudGl0eVwiLCBcImxvZGFzaC9pbmNsdWRlc1wiLCBcImxvZGFzaC9pc0FycmF5XCIsIFwibG9kYXNoL2lzRWxlbWVudFwiLCBcImxvZGFzaC9pc0Z1bmN0aW9uXCIsIFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIiwgXCJsb2Rhc2gvaXNTdHJpbmdcIiwgXCJsb2Rhc2gvbWVyZ2VcIiwgXCJsb2Rhc2gvdHJpbVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjbG91ZGluYXJ5XCJdID0gZmFjdG9yeShyZXF1aXJlKFwibG9kYXNoL2Fzc2lnblwiKSwgcmVxdWlyZShcImxvZGFzaC9jbG9uZURlZXBcIiksIHJlcXVpcmUoXCJsb2Rhc2gvY29tcGFjdFwiKSwgcmVxdWlyZShcImxvZGFzaC9kaWZmZXJlbmNlXCIpLCByZXF1aXJlKFwibG9kYXNoL2Z1bmN0aW9uc1wiKSwgcmVxdWlyZShcImxvZGFzaC9pZGVudGl0eVwiKSwgcmVxdWlyZShcImxvZGFzaC9pbmNsdWRlc1wiKSwgcmVxdWlyZShcImxvZGFzaC9pc0FycmF5XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzRWxlbWVudFwiKSwgcmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpLCByZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNTdHJpbmdcIiksIHJlcXVpcmUoXCJsb2Rhc2gvbWVyZ2VcIiksIHJlcXVpcmUoXCJsb2Rhc2gvdHJpbVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY2xvdWRpbmFyeVwiXSA9IGZhY3Rvcnkocm9vdFtcIl9cIl1bXCJhc3NpZ25cIl0sIHJvb3RbXCJfXCJdW1wiY2xvbmVEZWVwXCJdLCByb290W1wiX1wiXVtcImNvbXBhY3RcIl0sIHJvb3RbXCJfXCJdW1wiZGlmZmVyZW5jZVwiXSwgcm9vdFtcIl9cIl1bXCJmdW5jdGlvbnNcIl0sIHJvb3RbXCJfXCJdW1wiaWRlbnRpdHlcIl0sIHJvb3RbXCJfXCJdW1wiaW5jbHVkZXNcIl0sIHJvb3RbXCJfXCJdW1wiaXNBcnJheVwiXSwgcm9vdFtcIl9cIl1bXCJpc0VsZW1lbnRcIl0sIHJvb3RbXCJfXCJdW1wiaXNGdW5jdGlvblwiXSwgcm9vdFtcIl9cIl1bXCJpc1BsYWluT2JqZWN0XCJdLCByb290W1wiX1wiXVtcImlzU3RyaW5nXCJdLCByb290W1wiX1wiXVtcIm1lcmdlXCJdLCByb290W1wiX1wiXVtcInRyaW1cIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfYXNzaWduX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Nsb25lRGVlcF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jb21wYWN0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2RpZmZlcmVuY2VfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZnVuY3Rpb25zX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lkZW50aXR5X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2luY2x1ZGVzX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzQXJyYXlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNFbGVtZW50X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRnVuY3Rpb25fXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNQbGFpbk9iamVjdF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1N0cmluZ19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9tZXJnZV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF90cmltX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvbmFtZXNwYWNlL2Nsb3VkaW5hcnktY29yZS5qc1wiKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL3NyYy9uYW1lc3BhY2UvY2xvdWRpbmFyeS1jb3JlLmpzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNsaWVudEhpbnRzTWV0YVRhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGNsaWVudGhpbnRzbWV0YXRhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDbG91ZGluYXJ5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gY2xvdWRpbmFyeTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDb25kaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBjb25kaXRpb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ29uZmlndXJhdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHNyY19jb25maWd1cmF0aW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNyYzMyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX2NyYzMyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkV4cHJlc3Npb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBleHByZXNzaW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkZldGNoTGF5ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBmZXRjaGxheWVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkh0bWxUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBodG1sdGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkltYWdlVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gaW1hZ2V0YWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiTGF5ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBsYXllcl9sYXllcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQaWN0dXJlVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gcGljdHVyZXRhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTdWJ0aXRsZXNMYXllclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHN1YnRpdGxlc2xheWVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRleHRMYXllclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHRleHRsYXllcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUcmFuc2Zvcm1hdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHNyY190cmFuc2Zvcm1hdGlvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ1dGY4X2VuY29kZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHNyY191dGY4X2VuY29kZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJVdGlsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gbG9kYXNoX25hbWVzcGFjZU9iamVjdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWaWRlb1RhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHZpZGVvdGFnOyB9KTtcblxuLy8gTkFNRVNQQUNFIE9CSkVDVDogLi9zcmMvY29uc3RhbnRzLmpzXG52YXIgY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiVkVSU0lPTlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZFUlNJT047IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiQ0ZfU0hBUkVEX0NETlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENGX1NIQVJFRF9DRE47IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiT0xEX0FLQU1BSV9TSEFSRURfQ0ROXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gT0xEX0FLQU1BSV9TSEFSRURfQ0ROOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkFLQU1BSV9TSEFSRURfQ0ROXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQUtBTUFJX1NIQVJFRF9DRE47IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiU0hBUkVEX0NETlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNIQVJFRF9DRE47IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9USU1FT1VUX01TXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9USU1FT1VUX01TOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfUE9TVEVSX09QVElPTlNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1BPU1RFUl9PUFRJT05TOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiU0VPX1RZUEVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU0VPX1RZUEVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfSU1BR0VfUEFSQU1TXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9JTUFHRV9QQVJBTVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9WSURFT19QQVJBTVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1ZJREVPX1BBUkFNUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1ZJREVPX1NPVVJDRVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1ZJREVPX1NPVVJDRVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9FWFRFUk5BTF9MSUJSQVJJRVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJQTEFDRUhPTERFUl9JTUFHRV9NT0RFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFBMQUNFSE9MREVSX0lNQUdFX01PREVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkFDQ0VTU0lCSUxJVFlfTU9ERVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBQ0NFU1NJQklMSVRZX01PREVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlVSTF9LRVlTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVVJMX0tFWVM7IH0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL3NyYy91dGlsL2xvZGFzaC5qc1xudmFyIGxvZGFzaF9uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldFNES0FuYWx5dGljc1NpZ25hdHVyZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFNES0FuYWx5dGljc1NpZ25hdHVyZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXRBbmFseXRpY3NPcHRpb25zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0QW5hbHl0aWNzT3B0aW9uczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJhc3NpZ25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNsb25lRGVlcFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY29tcGFjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJkaWZmZXJlbmNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImZ1bmN0aW9uc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc19kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaWRlbnRpdHlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpbmNsdWRlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzQXJyYXlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNQbGFpbk9iamVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc1N0cmluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm1lcmdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY29udGFpbnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnRlZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJkZXRlY3RJbnRlcnNlY3Rpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZXRlY3RJbnRlcnNlY3Rpb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwib21pdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9taXQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYWxsU3RyaW5nc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJhc2V1dGlsX2FsbFN0cmluZ3M7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwid2l0aG91dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdpdGhvdXQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNOdW1iZXJMaWtlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNOdW1iZXJMaWtlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNtYXJ0RXNjYXBlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc21hcnRFc2NhcGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZGVmYXVsdHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWZhdWx0czsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJvYmplY3RQcm90b1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9iamVjdFByb3RvOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm9ialRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb2JqVG9TdHJpbmc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNPYmplY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc09iamVjdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJmdW5jVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY1RhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJyZVdvcmRzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVXb3JkczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjYW1lbENhc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjYW1lbENhc2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic25ha2VDYXNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc25ha2VDYXNlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNvbnZlcnRLZXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udmVydEtleXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwid2l0aENhbWVsQ2FzZUtleXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3aXRoQ2FtZWxDYXNlS2V5czsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ3aXRoU25ha2VDYXNlS2V5c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdpdGhTbmFrZUNhc2VLZXlzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImJhc2U2NEVuY29kZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJhc2U2NEVuY29kZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJiYXNlNjRFbmNvZGVVUkxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiYXNlNjRFbmNvZGVVUkw7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZXh0cmFjdFVybFBhcmFtc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGV4dHJhY3RVcmxQYXJhbXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwicGF0Y2hGZXRjaEZvcm1hdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhdGNoRmV0Y2hGb3JtYXQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwib3B0aW9uQ29uc3VtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9wdGlvbkNvbnN1bWU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNFbXB0eVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRW1wdHk7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNBbmRyb2lkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNBbmRyb2lkOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzRWRnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRWRnZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0Nocm9tZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQ2hyb21lOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzU2FmYXJpXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNTYWZhcmk7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNFbGVtZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0Z1bmN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInRyaW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0cmltX3Jvb3RfdHJpbV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0RGF0YVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9nZXREYXRhOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNldERhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfc2V0RGF0YTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXRBdHRyaWJ1dGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfZ2V0QXR0cmlidXRlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNldEF0dHJpYnV0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9zZXRBdHRyaWJ1dGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwicmVtb3ZlQXR0cmlidXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX3JlbW92ZUF0dHJpYnV0ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzZXRBdHRyaWJ1dGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2V0QXR0cmlidXRlczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJoYXNDbGFzc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9oYXNDbGFzczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJhZGRDbGFzc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9hZGRDbGFzczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXRTdHlsZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTdHlsZXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY3NzRXhwYW5kXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3NzRXhwYW5kOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImRvbVN0eWxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZG9tU3R5bGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY3VyQ1NTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3VyQ1NTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNzc1ZhbHVlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3NzVmFsdWU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYXVnbWVudFdpZHRoT3JIZWlnaHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhdWdtZW50V2lkdGhPckhlaWdodDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXRXaWR0aE9ySGVpZ2h0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0V2lkdGhPckhlaWdodDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ3aWR0aFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF93aWR0aDsgfSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0ZjhfZW5jb2RlLmpzXG4vKipcbiAqIFVURjggZW5jb2RlclxuICogQHByaXZhdGVcbiAqL1xudmFyIHV0ZjhfZW5jb2RlO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3V0ZjhfZW5jb2RlID0gKHV0ZjhfZW5jb2RlID0gZnVuY3Rpb24gdXRmOF9lbmNvZGUoYXJnU3RyaW5nKSB7XG4gIHZhciBjMSwgZW5jLCBlbmQsIG4sIHN0YXJ0LCBzdHJpbmcsIHN0cmluZ2wsIHV0ZnRleHQ7IC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG4gIC8vICsgICBvcmlnaW5hbCBieTogV2VidG9vbGtpdC5pbmZvIChodHRwOi8vd3d3LndlYnRvb2xraXQuaW5mby8pXG4gIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gIC8vICsgICBpbXByb3ZlZCBieTogc293YmVycnlcbiAgLy8gKyAgICB0d2Vha2VkIGJ5OiBKYWNrXG4gIC8vICsgICBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXG4gIC8vICsgICBpbXByb3ZlZCBieTogWXZlcyBTdWNhZXRcbiAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBVbHJpY2hcbiAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBSYWZhbCBLdWthd3NraVxuICAvLyArICAgaW1wcm92ZWQgYnk6IGtpcmlsbG9pZFxuICAvLyAqICAgICBleGFtcGxlIDE6IHV0ZjhfZW5jb2RlKCdLZXZpbiB2YW4gWm9ubmV2ZWxkJyk7XG4gIC8vICogICAgIHJldHVybnMgMTogJ0tldmluIHZhbiBab25uZXZlbGQnXG5cbiAgaWYgKGFyZ1N0cmluZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnU3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHN0cmluZyA9IGFyZ1N0cmluZyArICcnOyAvLyAucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKTtcblxuICB1dGZ0ZXh0ID0gJyc7XG4gIHN0YXJ0ID0gdm9pZCAwO1xuICBlbmQgPSB2b2lkIDA7XG4gIHN0cmluZ2wgPSAwO1xuICBzdGFydCA9IGVuZCA9IDA7XG4gIHN0cmluZ2wgPSBzdHJpbmcubGVuZ3RoO1xuICBuID0gMDtcblxuICB3aGlsZSAobiA8IHN0cmluZ2wpIHtcbiAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xuICAgIGVuYyA9IG51bGw7XG5cbiAgICBpZiAoYzEgPCAxMjgpIHtcbiAgICAgIGVuZCsrO1xuICAgIH0gZWxzZSBpZiAoYzEgPiAxMjcgJiYgYzEgPCAyMDQ4KSB7XG4gICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxID4+IDYgfCAxOTIsIGMxICYgNjMgfCAxMjgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxID4+IDEyIHwgMjI0LCBjMSA+PiA2ICYgNjMgfCAxMjgsIGMxICYgNjMgfCAxMjgpO1xuICAgIH1cblxuICAgIGlmIChlbmMgIT09IG51bGwpIHtcbiAgICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgdXRmdGV4dCArPSBlbmM7XG4gICAgICBzdGFydCA9IGVuZCA9IG4gKyAxO1xuICAgIH1cblxuICAgIG4rKztcbiAgfVxuXG4gIGlmIChlbmQgPiBzdGFydCkge1xuICAgIHV0ZnRleHQgKz0gc3RyaW5nLnNsaWNlKHN0YXJ0LCBzdHJpbmdsKTtcbiAgfVxuXG4gIHJldHVybiB1dGZ0ZXh0O1xufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jcmMzMi5qc1xuXG4vKipcbiAqIENSQzMyIGNhbGN1bGF0b3JcbiAqIERlcGVuZHMgb24gJ3V0ZjhfZW5jb2RlJ1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGNhbGN1bGF0ZSB0aGUgQ1JDMzIgZm9yLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cbmZ1bmN0aW9uIGNyYzMyKHN0cikge1xuICB2YXIgY3JjLCBpLCBpVG9wLCB0YWJsZSwgeCwgeTsgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBXZWJ0b29sa2l0LmluZm8gKGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvLylcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUMGJzblxuICAvLyArICAgaW1wcm92ZWQgYnk6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjY0NzkzNS9qYXZhc2NyaXB0LWNyYzMyLWZ1bmN0aW9uLWFuZC1waHAtY3JjMzItbm90LW1hdGNoaW5nXG4gIC8vIC0gICAgZGVwZW5kcyBvbjogdXRmOF9lbmNvZGVcbiAgLy8gKiAgICAgZXhhbXBsZSAxOiBjcmMzMignS2V2aW4gdmFuIFpvbm5ldmVsZCcpO1xuICAvLyAqICAgICByZXR1cm5zIDE6IDEyNDk5OTEyNDlcblxuICBzdHIgPSBzcmNfdXRmOF9lbmNvZGUoc3RyKTtcbiAgdGFibGUgPSAnMDAwMDAwMDAgNzcwNzMwOTYgRUUwRTYxMkMgOTkwOTUxQkEgMDc2REM0MTkgNzA2QUY0OEYgRTk2M0E1MzUgOUU2NDk1QTMgMEVEQjg4MzIgNzlEQ0I4QTQgRTBENUU5MUUgOTdEMkQ5ODggMDlCNjRDMkIgN0VCMTdDQkQgRTdCODJEMDcgOTBCRjFEOTEgMURCNzEwNjQgNkFCMDIwRjIgRjNCOTcxNDggODRCRTQxREUgMUFEQUQ0N0QgNkREREU0RUIgRjRENEI1NTEgODNEMzg1QzcgMTM2Qzk4NTYgNjQ2QkE4QzAgRkQ2MkY5N0EgOEE2NUM5RUMgMTQwMTVDNEYgNjMwNjZDRDkgRkEwRjNENjMgOEQwODBERjUgM0I2RTIwQzggNEM2OTEwNUUgRDU2MDQxRTQgQTI2NzcxNzIgM0MwM0U0RDEgNEIwNEQ0NDcgRDIwRDg1RkQgQTUwQUI1NkIgMzVCNUE4RkEgNDJCMjk4NkMgREJCQkM5RDYgQUNCQ0Y5NDAgMzJEODZDRTMgNDVERjVDNzUgRENENjBEQ0YgQUJEMTNENTkgMjZEOTMwQUMgNTFERTAwM0EgQzhENzUxODAgQkZEMDYxMTYgMjFCNEY0QjUgNTZCM0M0MjMgQ0ZCQTk1OTkgQjhCREE1MEYgMjgwMkI4OUUgNUYwNTg4MDggQzYwQ0Q5QjIgQjEwQkU5MjQgMkY2RjdDODcgNTg2ODRDMTEgQzE2MTFEQUIgQjY2NjJEM0QgNzZEQzQxOTAgMDFEQjcxMDYgOThEMjIwQkMgRUZENTEwMkEgNzFCMTg1ODkgMDZCNkI1MUYgOUZCRkU0QTUgRThCOEQ0MzMgNzgwN0M5QTIgMEYwMEY5MzQgOTYwOUE4OEUgRTEwRTk4MTggN0Y2QTBEQkIgMDg2RDNEMkQgOTE2NDZDOTcgRTY2MzVDMDEgNkI2QjUxRjQgMUM2QzYxNjIgODU2NTMwRDggRjI2MjAwNEUgNkMwNjk1RUQgMUIwMUE1N0IgODIwOEY0QzEgRjUwRkM0NTcgNjVCMEQ5QzYgMTJCN0U5NTAgOEJCRUI4RUEgRkNCOTg4N0MgNjJERDFEREYgMTVEQTJENDkgOENEMzdDRjMgRkJENDRDNjUgNERCMjYxNTggM0FCNTUxQ0UgQTNCQzAwNzQgRDRCQjMwRTIgNEFERkE1NDEgM0REODk1RDcgQTREMUM0NkQgRDNENkY0RkIgNDM2OUU5NkEgMzQ2RUQ5RkMgQUQ2Nzg4NDYgREE2MEI4RDAgNDQwNDJENzMgMzMwMzFERTUgQUEwQTRDNUYgREQwRDdDQzkgNTAwNTcxM0MgMjcwMjQxQUEgQkUwQjEwMTAgQzkwQzIwODYgNTc2OEI1MjUgMjA2Rjg1QjMgQjk2NkQ0MDkgQ0U2MUU0OUYgNUVERUY5MEUgMjlEOUM5OTggQjBEMDk4MjIgQzdEN0E4QjQgNTlCMzNEMTcgMkVCNDBEODEgQjdCRDVDM0IgQzBCQTZDQUQgRURCODgzMjAgOUFCRkIzQjYgMDNCNkUyMEMgNzRCMUQyOUEgRUFENTQ3MzkgOUREMjc3QUYgMDREQjI2MTUgNzNEQzE2ODMgRTM2MzBCMTIgOTQ2NDNCODQgMEQ2RDZBM0UgN0E2QTVBQTggRTQwRUNGMEIgOTMwOUZGOUQgMEEwMEFFMjcgN0QwNzlFQjEgRjAwRjkzNDQgODcwOEEzRDIgMUUwMUYyNjggNjkwNkMyRkUgRjc2MjU3NUQgODA2NTY3Q0IgMTk2QzM2NzEgNkU2QjA2RTcgRkVENDFCNzYgODlEMzJCRTAgMTBEQTdBNUEgNjdERDRBQ0MgRjlCOURGNkYgOEVCRUVGRjkgMTdCN0JFNDMgNjBCMDhFRDUgRDZENkEzRTggQTFEMTkzN0UgMzhEOEMyQzQgNEZERkYyNTIgRDFCQjY3RjEgQTZCQzU3NjcgM0ZCNTA2REQgNDhCMjM2NEIgRDgwRDJCREEgQUYwQTFCNEMgMzYwMzRBRjYgNDEwNDdBNjAgREY2MEVGQzMgQTg2N0RGNTUgMzE2RThFRUYgNDY2OUJFNzkgQ0I2MUIzOEMgQkM2NjgzMUEgMjU2RkQyQTAgNTI2OEUyMzYgQ0MwQzc3OTUgQkIwQjQ3MDMgMjIwMjE2QjkgNTUwNTI2MkYgQzVCQTNCQkUgQjJCRDBCMjggMkJCNDVBOTIgNUNCMzZBMDQgQzJEN0ZGQTcgQjVEMENGMzEgMkNEOTlFOEIgNUJERUFFMUQgOUI2NEMyQjAgRUM2M0YyMjYgNzU2QUEzOUMgMDI2RDkzMEEgOUMwOTA2QTkgRUIwRTM2M0YgNzIwNzY3ODUgMDUwMDU3MTMgOTVCRjRBODIgRTJCODdBMTQgN0JCMTJCQUUgMENCNjFCMzggOTJEMjhFOUIgRTVENUJFMEQgN0NEQ0VGQjcgMEJEQkRGMjEgODZEM0QyRDQgRjFENEUyNDIgNjhEREIzRjggMUZEQTgzNkUgODFCRTE2Q0QgRjZCOTI2NUIgNkZCMDc3RTEgMThCNzQ3NzcgODgwODVBRTYgRkYwRjZBNzAgNjYwNjNCQ0EgMTEwMTBCNUMgOEY2NTlFRkYgRjg2MkFFNjkgNjE2QkZGRDMgMTY2Q0NGNDUgQTAwQUUyNzggRDcwREQyRUUgNEUwNDgzNTQgMzkwM0IzQzIgQTc2NzI2NjEgRDA2MDE2RjcgNDk2OTQ3NEQgM0U2RTc3REIgQUVEMTZBNEEgRDlENjVBREMgNDBERjBCNjYgMzdEODNCRjAgQTlCQ0FFNTMgREVCQjlFQzUgNDdCMkNGN0YgMzBCNUZGRTkgQkRCREYyMUMgQ0FCQUMyOEEgNTNCMzkzMzAgMjRCNEEzQTYgQkFEMDM2MDUgQ0RENzA2OTMgNTRERTU3MjkgMjNEOTY3QkYgQjM2NjdBMkUgQzQ2MTRBQjggNUQ2ODFCMDIgMkE2RjJCOTQgQjQwQkJFMzcgQzMwQzhFQTEgNUEwNURGMUIgMkQwMkVGOEQnO1xuICBjcmMgPSAwO1xuICB4ID0gMDtcbiAgeSA9IDA7XG4gIGNyYyA9IGNyYyBeIC0xO1xuICBpID0gMDtcbiAgaVRvcCA9IHN0ci5sZW5ndGg7XG5cbiAgd2hpbGUgKGkgPCBpVG9wKSB7XG4gICAgeSA9IChjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGO1xuICAgIHggPSAnMHgnICsgdGFibGUuc3Vic3RyKHkgKiA5LCA4KTtcbiAgICBjcmMgPSBjcmMgPj4+IDggXiB4O1xuICAgIGkrKztcbiAgfVxuXG4gIGNyYyA9IGNyYyBeIC0xOyAvL2NvbnZlcnQgdG8gdW5zaWduZWQgMzItYml0IGludCBpZiBuZWVkZWRcblxuICBpZiAoY3JjIDwgMCkge1xuICAgIGNyYyArPSA0Mjk0OTY3Mjk2O1xuICB9XG5cbiAgcmV0dXJuIGNyYztcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2NyYzMyID0gKGNyYzMyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9zdHJpbmdQYWQuanNcbmZ1bmN0aW9uIHN0cmluZ1BhZCh2YWx1ZSwgdGFyZ2V0TGVuZ3RoLCBwYWRTdHJpbmcpIHtcbiAgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TGVuZ3RoID4+IDA7IC8vdHJ1bmNhdGUgaWYgbnVtYmVyIG9yIGNvbnZlcnQgbm9uLW51bWJlciB0byAwO1xuXG4gIHBhZFN0cmluZyA9IFN0cmluZyh0eXBlb2YgcGFkU3RyaW5nICE9PSAndW5kZWZpbmVkJyA/IHBhZFN0cmluZyA6ICcgJyk7XG5cbiAgaWYgKHZhbHVlLmxlbmd0aCA+IHRhcmdldExlbmd0aCkge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldExlbmd0aCA9IHRhcmdldExlbmd0aCAtIHZhbHVlLmxlbmd0aDtcblxuICAgIGlmICh0YXJnZXRMZW5ndGggPiBwYWRTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBwYWRTdHJpbmcgKz0gcmVwZWF0U3RyaW5nTnVtVGltZXMocGFkU3RyaW5nLCB0YXJnZXRMZW5ndGggLyBwYWRTdHJpbmcubGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFkU3RyaW5nLnNsaWNlKDAsIHRhcmdldExlbmd0aCkgKyBTdHJpbmcodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGVhdFN0cmluZ051bVRpbWVzKHN0cmluZywgdGltZXMpIHtcbiAgdmFyIHJlcGVhdGVkU3RyaW5nID0gXCJcIjtcblxuICB3aGlsZSAodGltZXMgPiAwKSB7XG4gICAgcmVwZWF0ZWRTdHJpbmcgKz0gc3RyaW5nO1xuICAgIHRpbWVzLS07XG4gIH1cblxuICByZXR1cm4gcmVwZWF0ZWRTdHJpbmc7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvYmFzZTY0TWFwLmpzXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cblxudmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xudmFyIGJhc2U2NE1hcF9udW0gPSAwO1xudmFyIG1hcCA9IHt9O1xuXG5fdG9Db25zdW1hYmxlQXJyYXkoY2hhcnMpLmZvckVhY2goZnVuY3Rpb24gKF9jaGFyKSB7XG4gIHZhciBrZXkgPSBiYXNlNjRNYXBfbnVtLnRvU3RyaW5nKDIpO1xuICBrZXkgPSBzdHJpbmdQYWQoa2V5LCA2LCAnMCcpO1xuICBtYXBba2V5XSA9IF9jaGFyO1xuICBiYXNlNjRNYXBfbnVtKys7XG59KTtcbi8qKlxuICogTWFwIG9mIHNpeC1iaXQgYmluYXJ5IGNvZGVzIHRvIEJhc2U2NCBjaGFyYWN0ZXJzXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBiYXNlNjRNYXAgPSAobWFwKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9yZXZlcnNlVmVyc2lvbi5qc1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBBIHNlbVZlciBsaWtlIHN0cmluZywgeC55Lnogb3IgeC55IGlzIGFsbG93ZWRcbiAqICAgICAgICAgICAgICBSZXZlcnNlcyB0aGUgdmVyc2lvbiBwb3NpdGlvbnMsIHgueS56IHR1cm5zIHRvIHoueS54XG4gKiAgICAgICAgICAgICAgUGFkcyBlYWNoIHNlZ21lbnQgd2l0aCAnMCcgc28gdGhleSBoYXZlIGxlbmd0aCBvZiAyXG4gKiAgICAgICAgICAgICAgRXhhbXBsZTogMS4yLjMgLT4gMDMuMDIuMDFcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZW1WZXIgSW5wdXQgY2FuIGJlIGVpdGhlciB4LnkueiBvciB4LnlcbiAqIEByZXR1cm4ge3N0cmluZ30gaW4gdGhlIGZvcm0gb2YgenoueXkueHggKFxuICovXG5cbmZ1bmN0aW9uIHJldmVyc2VWZXJzaW9uKHNlbVZlcikge1xuICBpZiAoc2VtVmVyLnNwbGl0KCcuJykubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZW1WZXIsIG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gc2VnbWVudHMnKTtcbiAgfSAvLyBTcGxpdCBieSAnLicsIHJldmVyc2UsIGNyZWF0ZSBuZXcgYXJyYXkgd2l0aCBwYWRkZWQgdmFsdWVzIGFuZCBjb25jYXQgaXQgdG9nZXRoZXJcblxuXG4gIHJldHVybiBzZW1WZXIuc3BsaXQoJy4nKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgcmV0dXJuIHN0cmluZ1BhZChzZWdtZW50LCAyLCAnMCcpO1xuICB9KS5qb2luKCcuJyk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZW5jb2RlVmVyc2lvbi5qc1xuXG5cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gRW5jb2RlcyBhIHNlbVZlci1saWtlIHZlcnNpb24gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VtVmVyIElucHV0IGNhbiBiZSBlaXRoZXIgeC55Lnogb3IgeC55XG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIGJ1aWx0IGZyb20gMyBjaGFyYWN0ZXJzIG9mIHRoZSBiYXNlNjQgdGFibGUgdGhhdCBlbmNvZGUgdGhlIHNlbVZlclxuICovXG5cbmZ1bmN0aW9uIGVuY29kZVZlcnNpb24oc2VtVmVyKSB7XG4gIHZhciBzdHJSZXN1bHQgPSAnJzsgLy8gc3VwcG9ydCB4Lnkgb3IgeC55LnogYnkgdXNpbmcgJ3BhcnRzJyBhcyBhIHZhcmlhYmxlXG5cbiAgdmFyIHBhcnRzID0gc2VtVmVyLnNwbGl0KCcuJykubGVuZ3RoO1xuICB2YXIgcGFkZGVkU3RyaW5nTGVuZ3RoID0gcGFydHMgKiA2OyAvLyB3ZSBwYWQgdG8gZWl0aGVyIDEyIG9yIDE4IGNoYXJhY3RlcnNcbiAgLy8gcmV2ZXJzZSAoYnV0IGRvbid0IG1pcnJvcikgdGhlIHZlcnNpb24uIDEuNS4xNSAtPiAxNS41LjFcbiAgLy8gUGFkIHRvIHR3byBzcGFjZXMsIDE1LjUuMSAtPiAxNS4wNS4wMVxuXG4gIHZhciBwYWRkZWRSZXZlcnNlZFNlbXZlciA9IHJldmVyc2VWZXJzaW9uKHNlbVZlcik7IC8vIHR1cm4gMTUuMDUuMDEgdG8gYSBzdHJpbmcgJzE1MDUwMScgdGhlbiB0byBhIG51bWJlciAxNTA1MDFcblxuICB2YXIgbnVtID0gcGFyc2VJbnQocGFkZGVkUmV2ZXJzZWRTZW12ZXIuc3BsaXQoJy4nKS5qb2luKCcnKSk7IC8vIFJlcHJlc2VudCBhcyBiaW5hcnksIGFkZCBsZWZ0IHBhZGRpbmcgdG8gMTIgb3IgMTggY2hhcmFjdGVycy5cbiAgLy8gMTUwLDUwMSAtPiAxMDAxMDAxMDExMTExMDAxMDFcblxuICB2YXIgcGFkZGVkQmluYXJ5ID0gbnVtLnRvU3RyaW5nKDIpO1xuICBwYWRkZWRCaW5hcnkgPSBzdHJpbmdQYWQocGFkZGVkQmluYXJ5LCBwYWRkZWRTdHJpbmdMZW5ndGgsICcwJyk7IC8vIFN0b3AgaW4gY2FzZSBhbiBpbnZhbGlkIHZlcnNpb24gbnVtYmVyIHdhcyBwcm92aWRlZFxuICAvLyBwYWRkZWRCaW5hcnkgbXVzdCBiZSBidWlsdCBmcm9tIHNlY3Rpb25zIG9mIDYgYml0c1xuXG4gIGlmIChwYWRkZWRCaW5hcnkubGVuZ3RoICUgNiAhPT0gMCkge1xuICAgIHRocm93ICdWZXJzaW9uIG11c3QgYmUgc21hbGxlciB0aGFuIDQzLjIxLjI2KSc7XG4gIH0gLy8gdHVybiBldmVyeSA2IGJpdHMgaW50byBhIGNoYXJhY3RlciB1c2luZyB0aGUgYmFzZTY0TWFwXG5cblxuICBwYWRkZWRCaW5hcnkubWF0Y2goLy57MSw2fS9nKS5mb3JFYWNoKGZ1bmN0aW9uIChiaXRTdHJpbmcpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhiaXRTdHJpbmcpO1xuICAgIHN0clJlc3VsdCArPSBiYXNlNjRNYXBbYml0U3RyaW5nXTtcbiAgfSk7XG4gIHJldHVybiBzdHJSZXN1bHQ7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlLmpzXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEdldHMgdGhlIFNESyBzaWduYXR1cmUgYnkgZW5jb2RpbmcgdGhlIFNESyB2ZXJzaW9uIGFuZCB0ZWNoIHZlcnNpb25cbiAqIEBwYXJhbSB7e1xuICogICAgW3RlY2hWZXJzaW9uXTpzdHJpbmcsXG4gKiAgICBbc2RrU2VtdmVyXTogc3RyaW5nLFxuICogICAgW3Nka0NvZGVdOiBzdHJpbmcsXG4gKiAgICBbZmVhdHVyZV06IHN0cmluZ1xuICogfX0gYW5hbHl0aWNzT3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfSBzZGtBbmFseXRpY3NTaWduYXR1cmVcbiAqL1xuXG5mdW5jdGlvbiBnZXRTREtBbmFseXRpY3NTaWduYXR1cmUoKSB7XG4gIHZhciBhbmFseXRpY3NPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB0cnkge1xuICAgIHZhciB0d29QYXJ0VmVyc2lvbiA9IHJlbW92ZVBhdGNoRnJvbVNlbXZlcihhbmFseXRpY3NPcHRpb25zLnRlY2hWZXJzaW9uKTtcbiAgICB2YXIgZW5jb2RlZFNES1ZlcnNpb24gPSBlbmNvZGVWZXJzaW9uKGFuYWx5dGljc09wdGlvbnMuc2RrU2VtdmVyKTtcbiAgICB2YXIgZW5jb2RlZFRlY2hWZXJzaW9uID0gZW5jb2RlVmVyc2lvbih0d29QYXJ0VmVyc2lvbik7XG4gICAgdmFyIGZlYXR1cmVDb2RlID0gYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlO1xuICAgIHZhciBTREtDb2RlID0gYW5hbHl0aWNzT3B0aW9ucy5zZGtDb2RlO1xuICAgIHZhciBhbGdvVmVyc2lvbiA9ICdBJzsgLy8gVGhlIGFsZ28gdmVyc2lvbiBpcyBkZXRlcm1pbmVkIGhlcmUsIGl0IHNob3VsZCBub3QgYmUgYW4gYXJndW1lbnRcblxuICAgIHJldHVybiBcIlwiLmNvbmNhdChhbGdvVmVyc2lvbikuY29uY2F0KFNES0NvZGUpLmNvbmNhdChlbmNvZGVkU0RLVmVyc2lvbikuY29uY2F0KGVuY29kZWRUZWNoVmVyc2lvbikuY29uY2F0KGZlYXR1cmVDb2RlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEVpdGhlciBTREsgb3IgTm9kZSB2ZXJzaW9ucyB3ZXJlIHVucGFyc2FibGVcbiAgICByZXR1cm4gJ0UnO1xuICB9XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIHBhdGNoIHZlcnNpb24gZnJvbSB0aGUgc2VtdmVyIGlmIGl0IGV4aXN0c1xuICogICAgICAgICAgICAgIFR1cm5zIHgueS56IE9SIHgueSBpbnRvIHgueVxuICogQHBhcmFtIHsneC55LnonIHx8ICd4LnknIHx8IHN0cmluZ30gc2VtVmVyU3RyXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlUGF0Y2hGcm9tU2VtdmVyKHNlbVZlclN0cikge1xuICB2YXIgcGFydHMgPSBzZW1WZXJTdHIuc3BsaXQoJy4nKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHBhcnRzWzBdLCBcIi5cIikuY29uY2F0KHBhcnRzWzFdKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9nZXRBbmFseXRpY3NPcHRpb25zLmpzXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHZXRzIHRoZSBhbmFseXRpY3NPcHRpb25zIGZyb20gb3B0aW9ucy0gc2hvdWxkIGluY2x1ZGUgc2RrU2VtdmVyLCB0ZWNoVmVyc2lvbiwgc2RrQ29kZSwgYW5kIGZlYXR1cmVcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7e3Nka1NlbXZlcjogKHN0cmluZyksIHNka0NvZGUsIGZlYXR1cmU6IHN0cmluZywgdGVjaFZlcnNpb246IChzdHJpbmcpfSB8fCB7fX1cbiAqL1xuZnVuY3Rpb24gZ2V0QW5hbHl0aWNzT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBhbmFseXRpY3NPcHRpb25zID0ge1xuICAgIHNka1NlbXZlcjogb3B0aW9ucy5zZGtTZW12ZXIsXG4gICAgdGVjaFZlcnNpb246IG9wdGlvbnMudGVjaFZlcnNpb24sXG4gICAgc2RrQ29kZTogb3B0aW9ucy5zZGtDb2RlLFxuICAgIGZlYXR1cmU6ICcwJ1xuICB9O1xuXG4gIGlmIChvcHRpb25zLnVybEFuYWx5dGljcykge1xuICAgIGlmIChvcHRpb25zLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgIGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZSA9ICdEJztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sb2FkaW5nID09PSAnbGF6eScpIHtcbiAgICAgIGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZSA9ICdDJztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICBhbmFseXRpY3NPcHRpb25zLmZlYXR1cmUgPSAnQSc7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXIpIHtcbiAgICAgIGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZSA9ICdCJztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5hbHl0aWNzT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9hc3NpZ25cIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2Fzc2lnblwiLFwiYW1kXCI6XCJsb2Rhc2gvYXNzaWduXCIsXCJyb290XCI6W1wiX1wiLFwiYXNzaWduXCJdfVxudmFyIGFzc2lnbl9yb290X2Fzc2lnbl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2Fzc2lnblwiKTtcbnZhciBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYXNzaWduX3Jvb3RfYXNzaWduXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9jbG9uZURlZXBcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2Nsb25lRGVlcFwiLFwiYW1kXCI6XCJsb2Rhc2gvY2xvbmVEZWVwXCIsXCJyb290XCI6W1wiX1wiLFwiY2xvbmVEZWVwXCJdfVxudmFyIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2Nsb25lRGVlcFwiKTtcbnZhciBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJhbWRcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJyb290XCI6W1wiX1wiLFwiY29tcGFjdFwiXX1cbnZhciBjb21wYWN0X3Jvb3RfY29tcGFjdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2NvbXBhY3RcIik7XG52YXIgY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29tcGFjdF9yb290X2NvbXBhY3RfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcImFtZFwiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcInJvb3RcIjpbXCJfXCIsXCJkaWZmZXJlbmNlXCJdfVxudmFyIGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvZGlmZmVyZW5jZVwiKTtcbnZhciBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvZnVuY3Rpb25zXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9mdW5jdGlvbnNcIixcImFtZFwiOlwibG9kYXNoL2Z1bmN0aW9uc1wiLFwicm9vdFwiOltcIl9cIixcImZ1bmN0aW9uc1wiXX1cbnZhciBmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9mdW5jdGlvbnNcIik7XG52YXIgZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaWRlbnRpdHlcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lkZW50aXR5XCIsXCJhbWRcIjpcImxvZGFzaC9pZGVudGl0eVwiLFwicm9vdFwiOltcIl9cIixcImlkZW50aXR5XCJdfVxudmFyIGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pZGVudGl0eVwiKTtcbnZhciBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2luY2x1ZGVzXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pbmNsdWRlc1wiLFwiYW1kXCI6XCJsb2Rhc2gvaW5jbHVkZXNcIixcInJvb3RcIjpbXCJfXCIsXCJpbmNsdWRlc1wiXX1cbnZhciBpbmNsdWRlc19yb290X2luY2x1ZGVzXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaW5jbHVkZXNcIik7XG52YXIgaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpbmNsdWRlc19yb290X2luY2x1ZGVzXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJhbWRcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJyb290XCI6W1wiX1wiLFwiaXNBcnJheVwiXX1cbnZhciBpc0FycmF5X3Jvb3RfaXNBcnJheV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzQXJyYXlcIik7XG52YXIgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNBcnJheV9yb290X2lzQXJyYXlfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcImFtZFwiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcInJvb3RcIjpbXCJfXCIsXCJpc1BsYWluT2JqZWN0XCJdfVxudmFyIGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKTtcbnZhciBpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaXNTdHJpbmdcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzU3RyaW5nXCIsXCJhbWRcIjpcImxvZGFzaC9pc1N0cmluZ1wiLFwicm9vdFwiOltcIl9cIixcImlzU3RyaW5nXCJdfVxudmFyIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pc1N0cmluZ1wiKTtcbnZhciBpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL21lcmdlXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9tZXJnZVwiLFwiYW1kXCI6XCJsb2Rhc2gvbWVyZ2VcIixcInJvb3RcIjpbXCJfXCIsXCJtZXJnZVwiXX1cbnZhciBtZXJnZV9yb290X21lcmdlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvbWVyZ2VcIik7XG52YXIgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihtZXJnZV9yb290X21lcmdlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0VsZW1lbnRcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzRWxlbWVudFwiLFwiYW1kXCI6XCJsb2Rhc2gvaXNFbGVtZW50XCIsXCJyb290XCI6W1wiX1wiLFwiaXNFbGVtZW50XCJdfVxudmFyIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzRWxlbWVudFwiKTtcbnZhciBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50Xyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJhbWRcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJyb290XCI6W1wiX1wiLFwiaXNGdW5jdGlvblwiXX1cbnZhciBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzRnVuY3Rpb25cIik7XG52YXIgaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL3RyaW1cIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL3RyaW1cIixcImFtZFwiOlwibG9kYXNoL3RyaW1cIixcInJvb3RcIjpbXCJfXCIsXCJ0cmltXCJdfVxudmFyIHRyaW1fcm9vdF90cmltXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvdHJpbVwiKTtcbnZhciB0cmltX3Jvb3RfdHJpbV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih0cmltX3Jvb3RfdHJpbV8pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2xhenlMb2FkLmpzXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbi8qXG4gKiBJbmNsdWRlcyB1dGlsaXR5IG1ldGhvZHMgZm9yIGxhenkgbG9hZGluZyBtZWRpYVxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgc3VwcG9ydGVkXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciBpcyBkZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQoKSB7XG4gIC8vIENoZWNrIHRoYXQgJ0ludGVyc2VjdGlvbk9ic2VydmVyJyBwcm9wZXJ0eSBpcyBkZWZpbmVkIG9uIHdpbmRvd1xuICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG59XG4vKipcbiAqIENoZWNrIGlmIG5hdGl2ZSBsYXp5IGxvYWRpbmcgaXMgc3VwcG9ydGVkXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmICdsb2FkaW5nJyBwcm9wZXJ0eSBpcyBkZWZpbmVkIGZvciBIVE1MSW1hZ2VFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuICh0eXBlb2YgSFRNTEltYWdlRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKEhUTUxJbWFnZUVsZW1lbnQpKSA9PT0gXCJvYmplY3RcIiAmJiBIVE1MSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5sb2FkaW5nO1xufVxuLyoqXG4gKiBDYWxscyBvbkludGVyc2VjdCgpIHdoZW4gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkLCBvciB3aGVuXG4gKiBubyBuYXRpdmUgbGF6eSBsb2FkaW5nIG9yIHdoZW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXNuJ3Qgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIHRoZSBlbGVtZW50IHRvIG9ic2VydmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uSW50ZXJzZWN0IC0gY2FsbGVkIHdoZW4gdGhlIGdpdmVuIGVsZW1lbnQgaXMgaW4gdmlld1xuICovXG5cbmZ1bmN0aW9uIGRldGVjdEludGVyc2VjdGlvbihlbCwgb25JbnRlcnNlY3QpIHtcbiAgdHJ5IHtcbiAgICBpZiAoaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpIHx8ICFpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkKCkpIHtcbiAgICAgIC8vIFJldHVybiBpZiB0aGVyZSdzIG5vIG5lZWQgb3IgcG9zc2liaWxpdHkgdG8gZGV0ZWN0IGludGVyc2VjdGlvblxuICAgICAgb25JbnRlcnNlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIERldGVjdCBpbnRlcnNlY3Rpb24gd2l0aCBnaXZlbiBlbGVtZW50IHVzaW5nIEludGVyc2VjdGlvbk9ic2VydmVyXG5cblxuICAgIHZhciBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICBvbkludGVyc2VjdCgpO1xuICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbnRyeS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICB0aHJlc2hvbGQ6IFswLCAwLjAxXVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb25JbnRlcnNlY3QoKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29uc3RhbnRzLmpzXG52YXIgVkVSU0lPTiA9IFwiMi41LjBcIjtcbnZhciBDRl9TSEFSRURfQ0ROID0gXCJkM2pwbDkxcHhldmJraC5jbG91ZGZyb250Lm5ldFwiO1xudmFyIE9MRF9BS0FNQUlfU0hBUkVEX0NETiA9IFwiY2xvdWRpbmFyeS1hLmFrYW1haWhkLm5ldFwiO1xudmFyIEFLQU1BSV9TSEFSRURfQ0ROID0gXCJyZXMuY2xvdWRpbmFyeS5jb21cIjtcbnZhciBTSEFSRURfQ0ROID0gQUtBTUFJX1NIQVJFRF9DRE47XG52YXIgREVGQVVMVF9USU1FT1VUX01TID0gMTAwMDA7XG52YXIgREVGQVVMVF9QT1NURVJfT1BUSU9OUyA9IHtcbiAgZm9ybWF0OiAnanBnJyxcbiAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJ1xufTtcbnZhciBERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyA9IFsnd2VibScsICdtcDQnLCAnb2d2J107XG52YXIgU0VPX1RZUEVTID0ge1xuICBcImltYWdlL3VwbG9hZFwiOiBcImltYWdlc1wiLFxuICBcImltYWdlL3ByaXZhdGVcIjogXCJwcml2YXRlX2ltYWdlc1wiLFxuICBcImltYWdlL2F1dGhlbnRpY2F0ZWRcIjogXCJhdXRoZW50aWNhdGVkX2ltYWdlc1wiLFxuICBcInJhdy91cGxvYWRcIjogXCJmaWxlc1wiLFxuICBcInZpZGVvL3VwbG9hZFwiOiBcInZpZGVvc1wiXG59O1xuLyoqXG4qIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfSU1BR0VfUEFSQU1TXG4qIERlZmF1bHRzIHZhbHVlcyBmb3IgaW1hZ2UgcGFyYW1ldGVycy5cbipcbiogKFByZXZpb3VzbHkgZGVmaW5lZCB1c2luZyBvcHRpb25fY29uc3VtZSgpIClcbiAqL1xuXG52YXIgREVGQVVMVF9JTUFHRV9QQVJBTVMgPSB7XG4gIHJlc291cmNlX3R5cGU6IFwiaW1hZ2VcIixcbiAgdHJhbnNmb3JtYXRpb246IFtdLFxuICB0eXBlOiAndXBsb2FkJ1xufTtcbi8qKlxuKiBEZWZhdWx0cyB2YWx1ZXMgZm9yIHZpZGVvIHBhcmFtZXRlcnMuXG4qIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfVklERU9fUEFSQU1TXG4qIChQcmV2aW91c2x5IGRlZmluZWQgdXNpbmcgb3B0aW9uX2NvbnN1bWUoKSApXG4gKi9cblxudmFyIERFRkFVTFRfVklERU9fUEFSQU1TID0ge1xuICBmYWxsYmFja19jb250ZW50OiAnJyxcbiAgcmVzb3VyY2VfdHlwZTogXCJ2aWRlb1wiLFxuICBzb3VyY2VfdHJhbnNmb3JtYXRpb246IHt9LFxuICBzb3VyY2VfdHlwZXM6IERFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTLFxuICB0cmFuc2Zvcm1hdGlvbjogW10sXG4gIHR5cGU6ICd1cGxvYWQnXG59O1xuLyoqXG4gKiBSZWNvbW1lbmRlZCBzb3VyY2VzIGZvciB2aWRlbyB0YWdcbiAqIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfVklERU9fU09VUkNFU1xuICovXG5cbnZhciBERUZBVUxUX1ZJREVPX1NPVVJDRVMgPSBbe1xuICB0eXBlOiBcIm1wNFwiLFxuICBjb2RlY3M6IFwiaGV2MVwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJoMjY1XCJcbiAgfVxufSwge1xuICB0eXBlOiBcIndlYm1cIixcbiAgY29kZWNzOiBcInZwOVwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJ2cDlcIlxuICB9XG59LCB7XG4gIHR5cGU6IFwibXA0XCIsXG4gIHRyYW5zZm9ybWF0aW9uczoge1xuICAgIHZpZGVvX2NvZGVjOiBcImF1dG9cIlxuICB9XG59LCB7XG4gIHR5cGU6IFwid2VibVwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJhdXRvXCJcbiAgfVxufV07XG52YXIgREVGQVVMVF9FWFRFUk5BTF9MSUJSQVJJRVMgPSB7XG4gIHNlZVRocnU6ICdodHRwczovL3VucGtnLmNvbS9zZWV0aHJ1QDQvZGlzdC9zZWVUaHJ1Lm1pbi5qcydcbn07XG4vKipcbiAqIFByZWRlZmluZWQgcGxhY2Vob2xkZXIgdHJhbnNmb3JtYXRpb25zXG4gKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5QTEFDRUhPTERFUl9JTUFHRV9NT0RFU1xuICovXG5cbnZhciBQTEFDRUhPTERFUl9JTUFHRV9NT0RFUyA9IHtcbiAgJ2JsdXInOiBbe1xuICAgIGVmZmVjdDogJ2JsdXI6MjAwMCcsXG4gICAgcXVhbGl0eTogMSxcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJ1xuICB9XSxcbiAgLy8gRGVmYXVsdFxuICAncGl4ZWxhdGUnOiBbe1xuICAgIGVmZmVjdDogJ3BpeGVsYXRlJyxcbiAgICBxdWFsaXR5OiAxLFxuICAgIGZldGNoX2Zvcm1hdDogJ2F1dG8nXG4gIH1dLFxuICAvLyBHZW5lcmF0ZXMgYSBwaXhlbCBzaXplIGltYWdlIHdoaWNoIGNvbG9yIGlzIHRoZSBwcmVkb21pbmFudCBjb2xvciBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UuXG4gICdwcmVkb21pbmFudC1jb2xvci1waXhlbCc6IFt7XG4gICAgd2lkdGg6ICdpd19kaXZfMicsXG4gICAgYXNwZWN0X3JhdGlvOiAxLFxuICAgIGNyb3A6ICdwYWQnLFxuICAgIGJhY2tncm91bmQ6ICdhdXRvJ1xuICB9LCB7XG4gICAgY3JvcDogJ2Nyb3AnLFxuICAgIHdpZHRoOiAxLFxuICAgIGhlaWdodDogMSxcbiAgICBncmF2aXR5OiAnbm9ydGhfZWFzdCdcbiAgfSwge1xuICAgIGZldGNoX2Zvcm1hdDogJ2F1dG8nLFxuICAgIHF1YWxpdHk6ICdhdXRvJ1xuICB9XSxcbiAgLy8gR2VuZXJhdGVzIGFuIGltYWdlIHdoaWNoIGNvbG9yIGlzIHRoZSBwcmVkb21pbmFudCBjb2xvciBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UuXG4gICdwcmVkb21pbmFudC1jb2xvcic6IFt7XG4gICAgdmFyaWFibGVzOiBbWyckY3VycldpZHRoJywgJ3cnXSwgWyckY3VyckhlaWdodCcsICdoJ11dXG4gIH0sIHtcbiAgICB3aWR0aDogJ2l3X2Rpdl8yJyxcbiAgICBhc3BlY3RfcmF0aW86IDEsXG4gICAgY3JvcDogJ3BhZCcsXG4gICAgYmFja2dyb3VuZDogJ2F1dG8nXG4gIH0sIHtcbiAgICBjcm9wOiAnY3JvcCcsXG4gICAgd2lkdGg6IDEwLFxuICAgIGhlaWdodDogMTAsXG4gICAgZ3Jhdml0eTogJ25vcnRoX2Vhc3QnXG4gIH0sIHtcbiAgICB3aWR0aDogJyRjdXJyV2lkdGgnLFxuICAgIGhlaWdodDogJyRjdXJySGVpZ2h0JyxcbiAgICBjcm9wOiAnZmlsbCdcbiAgfSwge1xuICAgIGZldGNoX2Zvcm1hdDogJ2F1dG8nLFxuICAgIHF1YWxpdHk6ICdhdXRvJ1xuICB9XSxcbiAgJ3ZlY3Rvcml6ZSc6IFt7XG4gICAgZWZmZWN0OiAndmVjdG9yaXplOjM6MC4xJyxcbiAgICBmZXRjaF9mb3JtYXQ6ICdzdmcnXG4gIH1dXG59O1xuLyoqXG4gKiBQcmVkZWZpbmVkIGFjY2Vzc2liaWxpdHkgdHJhbnNmb3JtYXRpb25zXG4gKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5BQ0NFU1NJQklMSVRZX01PREVTXG4gKi9cblxudmFyIEFDQ0VTU0lCSUxJVFlfTU9ERVMgPSB7XG4gIGRhcmttb2RlOiAndGludDo3NTpibGFjaycsXG4gIGJyaWdodG1vZGU6ICd0aW50OjUwOndoaXRlJyxcbiAgbW9ub2Nocm9tZTogJ2dyYXlzY2FsZScsXG4gIGNvbG9yYmxpbmQ6ICdhc3Npc3RfY29sb3JibGluZCdcbn07XG4vKipcbiAqIEEgbGlzdCBvZiBrZXlzIHVzZWQgYnkgdGhlIHVybCgpIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgVVJMX0tFWVMgPSBbJ2FjY2Vzc2liaWxpdHknLCAnYXBpX3NlY3JldCcsICdhdXRoX3Rva2VuJywgJ2Nkbl9zdWJkb21haW4nLCAnY2xvdWRfbmFtZScsICdjbmFtZScsICdmb3JtYXQnLCAncGxhY2Vob2xkZXInLCAncHJpdmF0ZV9jZG4nLCAncmVzb3VyY2VfdHlwZScsICdzZWN1cmUnLCAnc2VjdXJlX2Nkbl9zdWJkb21haW4nLCAnc2VjdXJlX2Rpc3RyaWJ1dGlvbicsICdzaG9ydGVuJywgJ3NpZ25fdXJsJywgJ3NpZ25hdHVyZScsICdzc2xfZGV0ZWN0ZWQnLCAndHlwZScsICd1cmxfc3VmZml4JywgJ3VzZV9yb290X3BhdGgnLCAndmVyc2lvbiddO1xuLyoqXG4gKiBUaGUgcmVzb3VyY2Ugc3RvcmFnZSB0eXBlXG4gKiBAdHlwZWRlZiB0eXBlXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByb3BlcnR5ICB7c3RyaW5nfSAndXBsb2FkJyBBIHJlc291cmNlIHVwbG9hZGVkIGRpcmVjdGx5IHRvIENsb3VkaW5hcnlcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ2ZldGNoJyBBIHJlc291cmNlIGZldGNoZWQgYnkgQ2xvdWRpbmFyeSBmcm9tIGEgM3JkIHBhcnR5IHN0b3JhZ2VcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3ByaXZhdGUnXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICdhdXRoZW50aWNhdGVkJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnc3ByaXRlJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnZmFjZWJvb2snXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICd0d2l0dGVyJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAneW91dHViZSdcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3ZpbWVvJ1xuICpcbiAqL1xuXG4vKipcbiAqIFRoZSByZXNvdXJjZSB0eXBlXG4gKiBAdHlwZWRlZiByZXNvdXJjZVR5cGVcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gJ2ltYWdlJyBBbiBpbWFnZSBmaWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gJ3ZpZGVvJyBBIHZpZGVvIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAncmF3JyAgIEEgcmF3IGZpbGVcbiAqL1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9iYXNldXRpbC5qc1xuZnVuY3Rpb24gYmFzZXV0aWxfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBiYXNldXRpbF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBiYXNldXRpbF90eXBlb2Yob2JqKTsgfVxuXG4vKlxuICogSW5jbHVkZXMgY29tbW9uIHV0aWxpdHkgbWV0aG9kcyBhbmQgc2hpbXNcbiAqL1xuXG5cbmZ1bmN0aW9uIG9taXQob2JqLCBrZXlzKSB7XG4gIG9iaiA9IG9iaiB8fCB7fTtcbiAgdmFyIHNyY0tleXMgPSBPYmplY3Qua2V5cyhvYmopLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKShrZXlzLCBrZXkpO1xuICB9KTtcbiAgdmFyIGZpbHRlcmVkID0ge307XG4gIHNyY0tleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGZpbHRlcmVkW2tleV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYWxsIGl0ZW1zIGluIGxpc3QgYXJlIHN0cmluZ3NcbiAqIEBmdW5jdGlvbiBVdGlsLmFsbFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gbGlzdCAtIGFuIGFycmF5IG9mIGl0ZW1zXG4gKi9cblxudmFyIGJhc2V1dGlsX2FsbFN0cmluZ3MgPSBmdW5jdGlvbiBhbGxTdHJpbmdzKGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QubGVuZ3RoICYmIGxpc3QuZXZlcnkoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0LmEpO1xufTtcbi8qKlxuKiBDcmVhdGVzIGEgbmV3IGFycmF5IHdpdGhvdXQgdGhlIGdpdmVuIGl0ZW0uXG4qIEBmdW5jdGlvbiBVdGlsLndpdGhvdXRcbiogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBvcmlnaW5hbCBhcnJheVxuKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byBleGNsdWRlIGZyb20gdGhlIG5ldyBhcnJheVxuKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgYXJyYXkgbWFkZSBvZiB0aGUgb3JpZ2luYWwgYXJyYXkncyBpdGVtcyBleGNlcHQgZm9yIGBpdGVtYFxuICovXG5cbnZhciB3aXRob3V0ID0gZnVuY3Rpb24gd2l0aG91dChhcnJheSwgaXRlbSkge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYgIT09IGl0ZW07XG4gIH0pO1xufTtcbi8qKlxuKiBSZXR1cm4gdHJ1ZSBpcyB2YWx1ZSBpcyBhIG51bWJlciBvciBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlci5cbiogQGZ1bmN0aW9uIFV0aWwuaXNOdW1iZXJMaWtlXG4qIEBwYXJhbSB7Kn0gdmFsdWVcbiogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsdWUgaXMgYSBudW1iZXJcbiogQGV4YW1wbGVcbiogICAgVXRpbC5pc051bWJlcigwKSAvLyB0cnVlXG4qICAgIFV0aWwuaXNOdW1iZXIoXCIxLjNcIikgLy8gdHJ1ZVxuKiAgICBVdGlsLmlzTnVtYmVyKFwiXCIpIC8vIGZhbHNlXG4qICAgIFV0aWwuaXNOdW1iZXIodW5kZWZpbmVkKSAvLyBmYWxzZVxuICovXG5cbnZhciBpc051bWJlckxpa2UgPSBmdW5jdGlvbiBpc051bWJlckxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbn07XG4vKipcbiAqIEVzY2FwZSBhbGwgY2hhcmFjdGVycyBtYXRjaGluZyB1bnNhZmUgaW4gdGhlIGdpdmVuIHN0cmluZ1xuICogQGZ1bmN0aW9uIFV0aWwuc21hcnRFc2NhcGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBzb3VyY2Ugc3RyaW5nIHRvIGVzY2FwZVxuICogQHBhcmFtIHtSZWdFeHB9IHVuc2FmZSAtIGNoYXJhY3RlcnMgdGhhdCBtdXN0IGJlIGVzY2FwZWRcbiAqIEByZXR1cm4ge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcbiAqL1xuXG52YXIgc21hcnRFc2NhcGUgPSBmdW5jdGlvbiBzbWFydEVzY2FwZShzdHJpbmcpIHtcbiAgdmFyIHVuc2FmZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogLyhbXmEtekEtWjAtOV8uXFwtXFwvOl0rKS9nO1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UodW5zYWZlLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gbWF0Y2guc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gXCIlXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBBc3NpZ24gdmFsdWVzIGZyb20gc291cmNlcyBpZiB0aGV5IGFyZSBub3QgZGVmaW5lZCBpbiB0aGUgZGVzdGluYXRpb24uXG4gKiBPbmNlIGEgdmFsdWUgaXMgc2V0IGl0IGRvZXMgbm90IGNoYW5nZVxuICogQGZ1bmN0aW9uIFV0aWwuZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiAtIHRoZSBvYmplY3QgdG8gYXNzaWduIGRlZmF1bHRzIHRvXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlIC0gdGhlIHNvdXJjZSBvYmplY3QocykgdG8gYXNzaWduIGRlZmF1bHRzIGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gZGVzdGluYXRpb24gYWZ0ZXIgaXQgd2FzIG1vZGlmaWVkXG4gKi9cblxudmFyIGRlZmF1bHRzID0gZnVuY3Rpb24gZGVmYXVsdHMoZGVzdGluYXRpb24pIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZXMucmVkdWNlKGZ1bmN0aW9uIChkZXN0LCBzb3VyY2UpIHtcbiAgICB2YXIga2V5LCB2YWx1ZTtcblxuICAgIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgICAgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgaWYgKGRlc3Rba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXN0O1xuICB9LCBkZXN0aW5hdGlvbik7XG59O1xuLyoqKioqKioqKioqIGxvZGFzaCBmdW5jdGlvbnMgKi9cblxudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xuXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiNpc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuI2lzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuI2lzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZTsgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgdHlwZSA9IGJhc2V1dGlsX3R5cGVvZih2YWx1ZSk7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn07XG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4vKipcbiogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuKiBAZnVuY3Rpb24gVXRpbC5pc0Z1bmN0aW9uXG4qIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuKiBAZXhhbXBsZVxuKlxuKiBmdW5jdGlvbiBGb28oKXt9O1xuKiBpc0Z1bmN0aW9uKEZvbyk7XG4qIC8vID0+IHRydWVcbipcbiogaXNGdW5jdGlvbigvYWJjLyk7XG4qIC8vID0+IGZhbHNlXG4gKi9cblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBmdW5jVGFnO1xufTtcbi8qKioqKioqKioqKiBsb2Rhc2ggZnVuY3Rpb25zICovXG5cbi8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIHRvIGNyZWF0ZSBjb21wb3VuZCB3b3Jkcy4gKi9cblxudmFyIHJlV29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb3dlciwgdXBwZXI7XG4gIHVwcGVyID0gJ1tBLVpdJztcbiAgbG93ZXIgPSAnW2Etel0rJztcbiAgcmV0dXJuIFJlZ0V4cCh1cHBlciArICcrKD89JyArIHVwcGVyICsgbG93ZXIgKyAnKXwnICsgdXBwZXIgKyAnPycgKyBsb3dlciArICd8JyArIHVwcGVyICsgJyt8WzAtOV0rJywgJ2cnKTtcbn0oKTtcbi8qKlxuKiBDb252ZXJ0IHN0cmluZyB0byBjYW1lbENhc2VcbiogQGZ1bmN0aW9uIFV0aWwuY2FtZWxDYXNlXG4qIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiogQHJldHVybiB7c3RyaW5nfSBpbiBjYW1lbENhc2UgZm9ybWF0XG4gKi9cblxudmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uIGNhbWVsQ2FzZShzb3VyY2UpIHtcbiAgdmFyIHdvcmRzID0gc291cmNlLm1hdGNoKHJlV29yZHMpO1xuICB3b3JkcyA9IHdvcmRzLm1hcChmdW5jdGlvbiAod29yZCkge1xuICAgIHJldHVybiB3b3JkLmNoYXJBdCgwKS50b0xvY2FsZVVwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICB9KTtcbiAgd29yZHNbMF0gPSB3b3Jkc1swXS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICByZXR1cm4gd29yZHMuam9pbignJyk7XG59O1xuLyoqXG4gKiBDb252ZXJ0IHN0cmluZyB0byBzbmFrZV9jYXNlXG4gKiBAZnVuY3Rpb24gVXRpbC5zbmFrZUNhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3N0cmluZ30gaW4gc25ha2VfY2FzZSBmb3JtYXRcbiAqL1xuXG52YXIgc25ha2VDYXNlID0gZnVuY3Rpb24gc25ha2VDYXNlKHNvdXJjZSkge1xuICB2YXIgd29yZHMgPSBzb3VyY2UubWF0Y2gocmVXb3Jkcyk7XG4gIHdvcmRzID0gd29yZHMubWFwKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgfSk7XG4gIHJldHVybiB3b3Jkcy5qb2luKCdfJyk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBmcm9tIHNvdXJjZSwgd2l0aCB0aGUga2V5cyB0cmFuc2Zvcm1lZCB1c2luZyB0aGUgY29udmVydGVyLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBjb252ZXJ0ZXJcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxudmFyIGNvbnZlcnRLZXlzID0gZnVuY3Rpb24gY29udmVydEtleXMoc291cmNlLCBjb252ZXJ0ZXIpIHtcbiAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gIHJlc3VsdCA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAga2V5ID0gY29udmVydGVyKGtleSk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0VtcHR5KGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHNvdXJjZSBvYmplY3Qgd2l0aCBhbGwga2V5cyBpbiBjYW1lbENhc2VcbiAqIEBmdW5jdGlvbiBVdGlsLndpdGhDYW1lbENhc2VLZXlzXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgb2JqZWN0IHRvIGNvcHlcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0XG4gKi9cblxudmFyIHdpdGhDYW1lbENhc2VLZXlzID0gZnVuY3Rpb24gd2l0aENhbWVsQ2FzZUtleXMoc291cmNlKSB7XG4gIHJldHVybiBjb252ZXJ0S2V5cyhzb3VyY2UsIGNhbWVsQ2FzZSk7XG59O1xuLyoqXG4gKiBDcmVhdGUgYSBjb3B5IG9mIHRoZSBzb3VyY2Ugb2JqZWN0IHdpdGggYWxsIGtleXMgaW4gc25ha2VfY2FzZVxuICogQGZ1bmN0aW9uIFV0aWwud2l0aFNuYWtlQ2FzZUtleXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBvYmplY3QgdG8gY29weVxuICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3RcbiAqL1xuXG52YXIgd2l0aFNuYWtlQ2FzZUtleXMgPSBmdW5jdGlvbiB3aXRoU25ha2VDYXNlS2V5cyhzb3VyY2UpIHtcbiAgcmV0dXJuIGNvbnZlcnRLZXlzKHNvdXJjZSwgc25ha2VDYXNlKTtcbn07IC8vIEJyb3dzZXJcbi8vIE5vZGUuanNcblxudmFyIGJhc2U2NEVuY29kZSA9IHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJyAmJiBpc0Z1bmN0aW9uKGJ0b2EpID8gYnRvYSA6IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGlzRnVuY3Rpb24oQnVmZmVyKSA/IGZ1bmN0aW9uIChpbnB1dCkge1xuICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICBpbnB1dCA9IG5ldyBCdWZmZXIuZnJvbShTdHJpbmcoaW5wdXQpLCAnYmluYXJ5Jyk7XG4gIH1cblxuICByZXR1cm4gaW5wdXQudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJObyBiYXNlNjQgZW5jb2RpbmcgZnVuY3Rpb24gZm91bmRcIik7XG59O1xuLyoqXG4qIFJldHVybnMgdGhlIEJhc2U2NC1kZWNvZGVkIHZlcnNpb24gb2YgdXJsLjxicj5cbiogVGhpcyBtZXRob2QgZGVsZWdhdGVzIHRvIGBidG9hYCBpZiBwcmVzZW50LiBPdGhlcndpc2UgaXQgdHJpZXMgYEJ1ZmZlcmAuXG4qIEBmdW5jdGlvbiBVdGlsLmJhc2U2NEVuY29kZVVSTFxuKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gdGhlIHVybCB0byBlbmNvZGUuIHRoZSB2YWx1ZSBpcyBVUklkZWNvZGVkIGFuZCB0aGVuIHJlLWVuY29kZWQgYmVmb3JlIGNvbnZlcnRpbmcgdG8gYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4qIEByZXR1cm4ge3N0cmluZ30gdGhlIGJhc2U2NCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVVJMXG4gKi9cblxudmFyIGJhc2U2NEVuY29kZVVSTCA9IGZ1bmN0aW9uIGJhc2U2NEVuY29kZVVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICB1cmwgPSBkZWNvZGVVUkkodXJsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1cmwgPSBlbmNvZGVVUkkodXJsKTtcbiAgfVxuXG4gIHJldHVybiBiYXNlNjRFbmNvZGUodXJsKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCBvbmx5IFVSTCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgc291cmNlIG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBvbmx5IFVSTCBwYXJhbWV0ZXJzXG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdFVybFBhcmFtcyhvcHRpb25zKSB7XG4gIHJldHVybiBVUkxfS0VZUy5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgaWYgKG9wdGlvbnNba2V5XSAhPSBudWxsKSB7XG4gICAgICBvYmpba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59XG4vKipcbiAqIEhhbmRsZSB0aGUgZm9ybWF0IHBhcmFtZXRlciBmb3IgZmV0Y2ggdXJsc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSBvcHRpb25zIHVybCBhbmQgdHJhbnNmb3JtYXRpb24gb3B0aW9ucy4gVGhpcyBhcmd1bWVudCBtYXkgYmUgY2hhbmdlZCBieSB0aGUgZnVuY3Rpb24hXG4gKi9cblxuZnVuY3Rpb24gcGF0Y2hGZXRjaEZvcm1hdChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAob3B0aW9ucy50eXBlID09PSBcImZldGNoXCIpIHtcbiAgICBpZiAob3B0aW9ucy5mZXRjaF9mb3JtYXQgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5mZXRjaF9mb3JtYXQgPSBvcHRpb25Db25zdW1lKG9wdGlvbnMsIFwiZm9ybWF0XCIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBEZWxldGVzIGBvcHRpb25fbmFtZWAgZnJvbSBgb3B0aW9uc2AgYW5kIHJldHVybiB0aGUgdmFsdWUgaWYgcHJlc2VudC5cbiAqIElmIGBvcHRpb25zYCBkb2Vzbid0IGNvbnRhaW4gYG9wdGlvbl9uYW1lYCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGEgY29sbGVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbl9uYW1lIHRoZSBuYW1lIChrZXkpIG9mIHRoZSBkZXNpcmVkIHZhbHVlXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0X3ZhbHVlXSB0aGUgdmFsdWUgdG8gcmV0dXJuIGlzIG9wdGlvbl9uYW1lIGlzIG1pc3NpbmdcbiAqL1xuXG5mdW5jdGlvbiBvcHRpb25Db25zdW1lKG9wdGlvbnMsIG9wdGlvbl9uYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvcHRpb25zW29wdGlvbl9uYW1lXTtcbiAgZGVsZXRlIG9wdGlvbnNbb3B0aW9uX25hbWVdO1xuXG4gIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlZmF1bHRfdmFsdWU7XG4gIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGVtcHR5OlxuICogPHVsPlxuICogICA8bGk+dmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQ8L2xpPlxuICogICA8bGk+dmFsdWUgaXMgYW4gYXJyYXkgb3Igc3RyaW5nIG9mIGxlbmd0aCAwPC9saT5cbiAqICAgPGxpPnZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIG5vIGtleXM8L2xpPlxuICogPC91bD5cbiAqIEBmdW5jdGlvbiBVdGlsLmlzRW1wdHlcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsdWUgaXMgZW1wdHlcbiAqL1xuXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlLmxlbmd0aCA9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUuc2l6ZSA9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNpemUgPT09IDA7XG4gIH1cblxuICBpZiAoYmFzZXV0aWxfdHlwZW9mKHZhbHVlKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvYnJvd3Nlci5qc1xuLyoqXG4gKiBCYXNlZCBvbiB2aWRlby5qcyBpbXBsZW1lbnRhdGlvbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2Jsb2IvNDIzOGY1YzFkODg4OTA1NDcxNTNlN2UxZGU3YmQwZDFkOGUwYjIzNi9zcmMvanMvdXRpbHMvYnJvd3Nlci5qc1xuICovXG5cbi8qKlxuKiBSZXRyaWV2ZSBmcm9tIHRoZSBuYXZpZ2F0b3IgdGhlIHVzZXIgYWdlbnQgcHJvcGVydHkuXG4qIEByZXR1cm5zIHVzZXIgYWdlbnQgcHJvcGVydHkuXG4qL1xuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG59XG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgYW55IEFuZHJvaWRcbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIEFuZHJvaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KHVzZXJBZ2VudCk7XG59XG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgYW55IEVkZ2VcbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIEVkZ2UsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc0VkZ2UoKSB7XG4gIHZhciB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgcmV0dXJuIC9FZGcvaS50ZXN0KHVzZXJBZ2VudCk7XG59XG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgY2hyb21lLlxuICogQHJldHVybnMgdHJ1ZSBpZiBjdXJyZW50IGJyb3dzZXIgaXMgQ2hyb21lLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNDaHJvbWUoKSB7XG4gIHZhciB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgcmV0dXJuICFpc0VkZ2UoKSAmJiAoL0Nocm9tZS9pLnRlc3QodXNlckFnZW50KSB8fCAvQ3JpT1MvaS50ZXN0KHVzZXJBZ2VudCkpO1xufVxuLyoqXG4gKiBEZXRlY3QgaWYgY3VycmVudCBicm93c2VyIGlzIFNhZmFyaS5cbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIFNhZmFyaSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAvLyBVc2VyIGFnZW50cyBmb3Igb3RoZXIgYnJvd3NlcnMgbWlnaHQgaW5jbHVkZSBcIlNhZmFyaVwiIHNvIHdlIG11c3QgZXhjbHVkZSB0aGVtLlxuICAvLyBGb3IgZXhhbXBsZSAtIHRoaXMgaXMgdGhlIGNocm9tZSB1c2VyIGFnZW50IG9uIHdpbmRvd3MgMTA6XG4gIC8vIE1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85Ni4wLjQ2NjQuMTEwIFNhZmFyaS81MzcuMzZcbiAgdmFyIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICByZXR1cm4gL1NhZmFyaS9pLnRlc3QodXNlckFnZW50KSAmJiAhaXNDaHJvbWUoKSAmJiAhaXNBbmRyb2lkKCkgJiYgIWlzRWRnZSgpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9sb2Rhc2guanNcbnZhciBub2RlQ29udGFpbnM7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiBJbmNsdWRlcyB1dGlsaXR5IG1ldGhvZHMgYW5kIGxvZGFzaCAvIGpRdWVyeSBzaGltc1xuICovXG5cbi8qKlxuICogR2V0IGRhdGEgZnJvbSB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogVGhpcyBtZXRob2Qgd2lsbCB1c2UgalF1ZXJ5J3MgYGRhdGEoKWAgbWV0aG9kIGlmIGl0IGlzIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGl0IHdpbGwgZ2V0IHRoZSBgZGF0YS1gIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gZ2V0IHRoZSBkYXRhIGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGRhdGEgaXRlbVxuICogQHJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYG5hbWVgXG4gKiBAZnVuY3Rpb24gVXRpbC5nZXREYXRhXG4gKi9cblxudmFyIGxvZGFzaF9nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YShlbGVtZW50LCBuYW1lKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5nZXRBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQobmFtZSkpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyKFwiZGF0YS1cIi5jb25jYXQobmFtZSkpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZGF0YSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5kYXRhKG5hbWUpO1xuXG4gICAgY2FzZSAhKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5mbiAmJiBqUXVlcnkuZm4uZGF0YSkgJiYgaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQoKShlbGVtZW50KSk6XG4gICAgICByZXR1cm4galF1ZXJ5KGVsZW1lbnQpLmRhdGEobmFtZSk7XG4gIH1cbn07XG4vKipcbiAqIFNldCBkYXRhIGluIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHVzZSBqUXVlcnkncyBgZGF0YSgpYCBtZXRob2QgaWYgaXQgaXMgYXZhaWxhYmxlLCBvdGhlcndpc2UgaXQgd2lsbCBzZXQgdGhlIGBkYXRhLWAgYXR0cmlidXRlXG4gKiBAZnVuY3Rpb24gVXRpbC5zZXREYXRhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGRhdGEgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGRhdGEgaXRlbVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBiZSBzZXRcbiAqXG4gKi9cblxudmFyIGxvZGFzaF9zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuc2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KG5hbWUpLCB2YWx1ZSk7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHIoXCJkYXRhLVwiLmNvbmNhdChuYW1lKSwgdmFsdWUpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZGF0YSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5kYXRhKG5hbWUsIHZhbHVlKTtcblxuICAgIGNhc2UgIShpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZm4gJiYgalF1ZXJ5LmZuLmRhdGEpICYmIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0KCkoZWxlbWVudCkpOlxuICAgICAgcmV0dXJuIGpRdWVyeShlbGVtZW50KS5kYXRhKG5hbWUsIHZhbHVlKTtcbiAgfVxufTtcbi8qKlxuICogR2V0IGF0dHJpYnV0ZSBmcm9tIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBAZnVuY3Rpb24gVXRpbC5nZXRBdHRyaWJ1dGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIHNldCB0aGUgYXR0cmlidXRlIGZvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7Kn0gdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAqXG4gKi9cblxudmFyIGxvZGFzaF9nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYXR0cihuYW1lKTtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmdldEF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cihuYW1lKTtcbiAgfVxufTtcbi8qKlxuICogU2V0IGF0dHJpYnV0ZSBpbiB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIFV0aWwuc2V0QXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBiZSBzZXRcbiAqL1xuXG52YXIgbG9kYXNoX3NldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuc2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5hdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmF0dHIobmFtZSwgdmFsdWUpO1xuXG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuc2V0QXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5zZXRBdHRyKG5hbWUsIHZhbHVlKTtcbiAgfVxufTtcbi8qKlxuICogUmVtb3ZlIGFuIGF0dHJpYnV0ZSBpbiB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIFV0aWwucmVtb3ZlQXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICovXG5cbnZhciBsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIG5hbWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcblxuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGxvZGFzaF9zZXRBdHRyaWJ1dGUoZWxlbWVudCwgdm9pZCAwKTtcbiAgfVxufTtcbi8qKlxuICogU2V0IGEgZ3JvdXAgb2YgYXR0cmlidXRlcyB0byB0aGUgZWxlbWVudFxuICogQGZ1bmN0aW9uIFV0aWwuc2V0QXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGVzIGZvclxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhIGhhc2ggb2YgYXR0cmlidXRlIG5hbWVzIGFuZCB2YWx1ZXNcbiAqL1xuXG52YXIgc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICB2YXIgbmFtZSwgcmVzdWx0cywgdmFsdWU7XG4gIHJlc3VsdHMgPSBbXTtcblxuICBmb3IgKG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHRzLnB1c2gobG9kYXNoX3NldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzLnB1c2gobG9kYXNoX3JlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgZWxlbWVudCBoYXMgYSBjc3MgY2xhc3NcbiAqIEBmdW5jdGlvbiBVdGlsLmhhc0NsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgY2xhc3MgbmFtZVxuIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3NcbiAqL1xuXG52YXIgbG9kYXNoX2hhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICBpZiAoaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQoKShlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKFwiXFxcXGJcIi5jb25jYXQobmFtZSwgXCJcXFxcYlwiKSkpO1xuICB9XG59O1xuLyoqXG4gKiBBZGQgY2xhc3MgdG8gdGhlIGVsZW1lbnRcbiAqIEBmdW5jdGlvbiBVdGlsLmFkZENsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgY2xhc3MgbmFtZSB0byBhZGRcbiAqL1xuXG52YXIgbG9kYXNoX2FkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICBpZiAoIWVsZW1lbnQuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoXCJcXFxcYlwiLmNvbmNhdChuYW1lLCBcIlxcXFxiXCIpKSkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUgPSB0cmltX3Jvb3RfdHJpbV9kZWZhdWx0KCkoXCJcIi5jb25jYXQoZWxlbWVudC5jbGFzc05hbWUsIFwiIFwiKS5jb25jYXQobmFtZSkpO1xuICB9XG59OyAvLyBUaGUgZm9sbG93aW5nIGNvZGUgaXMgdGFrZW4gZnJvbSBqUXVlcnlcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIGdldFN0eWxlcyhlbGVtKSB7XG4gIC8vIFN1cHBvcnQ6IElFPD0xMSssIEZpcmVmb3g8PTMwKyAoIzE1MDk4LCAjMTQxNTApXG4gIC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuICAvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcbiAgaWYgKGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5vcGVuZXIpIHtcbiAgICByZXR1cm4gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCk7XG4gIH1cblxuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCk7XG59O1xudmFyIGNzc0V4cGFuZCA9IFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXTtcblxubm9kZUNvbnRhaW5zID0gZnVuY3Rpb24gbm9kZUNvbnRhaW5zKGEsIGIpIHtcbiAgdmFyIGFkb3duLCBidXA7XG4gIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYTtcbiAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG4gIHJldHVybiBhID09PSBidXAgfHwgISEoYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiBhZG93bi5jb250YWlucyhidXApKTtcbn07IC8vIFRydW5jYXRlZCB2ZXJzaW9uIG9mIGpRdWVyeS5zdHlsZShlbGVtLCBuYW1lKVxuXG5cbnZhciBkb21TdHlsZSA9IGZ1bmN0aW9uIGRvbVN0eWxlKGVsZW0sIG5hbWUpIHtcbiAgaWYgKCEoIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlKSkge1xuICAgIHJldHVybiBlbGVtLnN0eWxlW25hbWVdO1xuICB9XG59O1xudmFyIGN1ckNTUyA9IGZ1bmN0aW9uIGN1ckNTUyhlbGVtLCBuYW1lLCBjb21wdXRlZCkge1xuICB2YXIgbWF4V2lkdGgsIG1pbldpZHRoLCByZXQsIHJtYXJnaW4sIHN0eWxlLCB3aWR0aDtcbiAgcm1hcmdpbiA9IC9ebWFyZ2luLztcbiAgd2lkdGggPSB2b2lkIDA7XG4gIG1pbldpZHRoID0gdm9pZCAwO1xuICBtYXhXaWR0aCA9IHZvaWQgMDtcbiAgcmV0ID0gdm9pZCAwO1xuICBzdHlsZSA9IGVsZW0uc3R5bGU7XG4gIGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKGVsZW0pO1xuXG4gIGlmIChjb21wdXRlZCkge1xuICAgIC8vIFN1cHBvcnQ6IElFOVxuICAgIC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG4gICAgcmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFtuYW1lXTtcbiAgfVxuXG4gIGlmIChjb21wdXRlZCkge1xuICAgIGlmIChyZXQgPT09IFwiXCIgJiYgIW5vZGVDb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pKSB7XG4gICAgICByZXQgPSBkb21TdHlsZShlbGVtLCBuYW1lKTtcbiAgICB9IC8vIFN1cHBvcnQ6IGlPUyA8IDZcbiAgICAvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG4gICAgLy8gaU9TIDwgNiAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuICAgIC8vIHRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXG5cbiAgICBpZiAocm51bW5vbnB4LnRlc3QocmV0KSAmJiBybWFyZ2luLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuICAgICAgbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDsgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXG4gICAgICBzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG4gICAgICByZXQgPSBjb21wdXRlZC53aWR0aDsgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXG4gICAgICBzdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICAgIHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgfVxuICB9IC8vIFN1cHBvcnQ6IElFXG4gIC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cblxuICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmV0ICsgXCJcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xudmFyIGNzc1ZhbHVlID0gZnVuY3Rpb24gY3NzVmFsdWUoZWxlbSwgbmFtZSwgY29udmVydCwgc3R5bGVzKSB7XG4gIHZhciB2YWw7XG4gIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xuXG4gIGlmIChjb252ZXJ0KSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG59O1xudmFyIGF1Z21lbnRXaWR0aE9ySGVpZ2h0ID0gZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMpIHtcbiAgdmFyIGksIGxlbiwgc2lkZSwgc2lkZXMsIHZhbDsgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG4gIC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblxuICBpZiAoZXh0cmEgPT09IChpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIikpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICBzaWRlcyA9IG5hbWUgPT09IFwid2lkdGhcIiA/IFtcIlJpZ2h0XCIsIFwiTGVmdFwiXSA6IFtcIlRvcFwiLCBcIkJvdHRvbVwiXTtcbiAgICB2YWwgPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc2lkZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNpZGUgPSBzaWRlc1tpXTtcblxuICAgICAgaWYgKGV4dHJhID09PSBcIm1hcmdpblwiKSB7XG4gICAgICAgIC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcbiAgICAgICAgdmFsICs9IGNzc1ZhbHVlKGVsZW0sIGV4dHJhICsgc2lkZSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQm9yZGVyQm94KSB7XG4gICAgICAgIGlmIChleHRyYSA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgICAgICAvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcbiAgICAgICAgICB2YWwgLT0gY3NzVmFsdWUoZWxlbSwgXCJwYWRkaW5nXCIuY29uY2F0KHNpZGUpLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhICE9PSBcIm1hcmdpblwiKSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcbiAgICAgICAgICB2YWwgLT0gY3NzVmFsdWUoZWxlbSwgXCJib3JkZXJcIi5jb25jYXQoc2lkZSwgXCJXaWR0aFwiKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcbiAgICAgICAgdmFsICs9IGNzc1ZhbHVlKGVsZW0sIFwicGFkZGluZ1wiLmNvbmNhdChzaWRlKSwgdHJ1ZSwgc3R5bGVzKTtcblxuICAgICAgICBpZiAoZXh0cmEgIT09IFwicGFkZGluZ1wiKSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuICAgICAgICAgIHZhbCArPSBjc3NWYWx1ZShlbGVtLCBcImJvcmRlclwiLmNvbmNhdChzaWRlLCBcIldpZHRoXCIpLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufTtcbnZhciBwbnVtID0gL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiKTtcbnZhciBnZXRXaWR0aE9ySGVpZ2h0ID0gZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSkge1xuICB2YXIgaXNCb3JkZXJCb3gsIHN0eWxlcywgdmFsLCB2YWx1ZUlzQm9yZGVyQm94OyAvLyBTdGFydCB3aXRoIG9mZnNldCBwcm9wZXJ0eSwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byB0aGUgYm9yZGVyLWJveCB2YWx1ZVxuXG4gIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xuICB2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQ7XG4gIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKTtcbiAgaXNCb3JkZXJCb3ggPSBjc3NWYWx1ZShlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCI7IC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuICAvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcbiAgLy8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cbiAgaWYgKHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgLy8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG4gICAgdmFsID0gY3VyQ1NTKGVsZW0sIG5hbWUsIHN0eWxlcyk7XG5cbiAgICBpZiAodmFsIDwgMCB8fCB2YWwgPT0gbnVsbCkge1xuICAgICAgdmFsID0gZWxlbS5zdHlsZVtuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAocm51bW5vbnB4LnRlc3QodmFsKSkge1xuICAgICAgLy8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSAvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuICAgIC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcbiAgICAvLyAgICB2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggYW5kIChzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgb3IgdmFsIGlzIGVsZW0uc3R5bGVbbmFtZV0pXG5cblxuICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJiB2YWwgPT09IGVsZW0uc3R5bGVbbmFtZV07IC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblxuICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKSB8fCAwO1xuICB9IC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cblxuICByZXR1cm4gdmFsICsgYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEgfHwgKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSwgdmFsdWVJc0JvcmRlckJveCwgc3R5bGVzKTtcbn07XG52YXIgbG9kYXNoX3dpZHRoID0gZnVuY3Rpb24gd2lkdGgoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodChlbGVtZW50LCBcIndpZHRoXCIsIFwiY29udGVudFwiKTtcbn07XG4vKipcbiAqIEBjbGFzcyBVdGlsXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBpcyBhIHN0cmluZ1xuICogQGZ1bmN0aW9uIFV0aWwuaXNTdHJpbmdcbiAqIEBwYXJhbSBpdGVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdGVtIGlzIGEgc3RyaW5nXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBpcyBlbXB0eTpcbiAqIDx1bD5cbiAqICAgPGxpPml0ZW0gaXMgbnVsbCBvciB1bmRlZmluZWQ8L2xpPlxuICogICA8bGk+aXRlbSBpcyBhbiBhcnJheSBvciBzdHJpbmcgb2YgbGVuZ3RoIDA8L2xpPlxuICogICA8bGk+aXRlbSBpcyBhbiBvYmplY3Qgd2l0aCBubyBrZXlzPC9saT5cbiAqIDwvdWw+XG4gKiBAZnVuY3Rpb24gVXRpbC5pc0VtcHR5XG4gKiBAcGFyYW0gaXRlbVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaXRlbSBpcyBlbXB0eVxuICovXG5cbi8qKlxuICogQXNzaWduIHNvdXJjZSBwcm9wZXJ0aWVzIHRvIGRlc3RpbmF0aW9uLlxuICogSWYgdGhlIHByb3BlcnR5IGlzIGFuIG9iamVjdCBpdCBpcyBhc3NpZ25lZCBhcyBhIHdob2xlLCBvdmVycmlkaW5nIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAZnVuY3Rpb24gVXRpbC5hc3NpZ25cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiAtIHRoZSBvYmplY3QgdG8gYXNzaWduIHRvXG4gKi9cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBhc3NpZ24gc291cmNlIHByb3BlcnRpZXMgdG8gZGVzdGluYXRpb25cbiAqIEBmdW5jdGlvbiBVdGlsLm1lcmdlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gLSB0aGUgb2JqZWN0IHRvIGFzc2lnbiB0b1xuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LCBpbmNsdWRpbmcgYWxsIGludGVybmFsIG9iamVjdHMuXG4gKiBAZnVuY3Rpb24gVXRpbC5jbG9uZURlZXBcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgZGVlcCBjb3B5IG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgZnJvbSB0aGUgcGFyYW1ldGVyIHdpdGggXCJmYWxzZXlcIiB2YWx1ZXMgcmVtb3ZlZFxuICogQGZ1bmN0aW9uIFV0aWwuY29tcGFjdFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gcmVtb3ZlIHZhbHVlcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgYXJyYXkgd2l0aG91dCBmYWxzZXkgdmFsdWVzXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIGl0ZW0gaXMgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGFycmF5XG4gKiBAZnVuY3Rpb24gVXRpbC5jb250YWluc1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBpdGVtIGlzIGluY2x1ZGVkIGluIHRoZSBhcnJheVxuICovXG5cbi8qKlxuICogUmV0dXJucyB2YWx1ZXMgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgYXJyYXlcbiAqIEBmdW5jdGlvbiBVdGlsLmRpZmZlcmVuY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciAtIHRoZSBhcnJheSB0byBzZWxlY3QgZnJvbVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gdmFsdWVzIHRvIGZpbHRlciBmcm9tIGFyclxuICogQHJldHVybiB7QXJyYXl9IHRoZSBmaWx0ZXJlZCB2YWx1ZXNcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB0aGUgZnVuY3Rpb24gbmFtZXMgaW4gb2JqXG4gKiBAZnVuY3Rpb24gVXRpbC5mdW5jdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSB0aGUgb2JqZWN0IHRvIGluc3BlY3RcbiAqIEByZXR1cm4ge0FycmF5fSBhIGxpc3Qgb2YgZnVuY3Rpb25zIG9mIG9iamVjdFxuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoaXMgZnVuY3Rpb25zIGlzIHVzZWQgYXMgYSBkZWZhdWx0IHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBmdW5jdGlvbiBVdGlsLmlkZW50aXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfSB0aGUgcHJvdmlkZWQgdmFsdWVcbiAqL1xuXG4vKipcbiAqIFJlbW92ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlcyBmcm9tIHRleHRcbiAqIEBmdW5jdGlvbiBVdGlsLnRyaW1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBgdGV4dGAgd2l0aG91dCBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlc1xuICovXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9leHByZXNzaW9uLmpzXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zZm9ybWF0aW9uIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvblN0ciAtIEFuIGV4cHJlc3Npb24gaW4gc3RyaW5nIGZvcm1hdC5cbiAqIEBjbGFzcyBFeHByZXNzaW9uXG4gKiBOb3JtYWxseSB0aGlzIGNsYXNzIGlzIG5vdCBpbnN0YW50aWF0ZWQgZGlyZWN0bHlcbiAqL1xudmFyIEV4cHJlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHByZXNzaW9uKGV4cHJlc3Npb25TdHIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwcmVzc2lvbik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlubmVyIEV4cHJlc3Npb24tZXhwcmVzc2lvbnNcbiAgICAgKi9cbiAgICB0aGlzLmV4cHJlc3Npb25zID0gW107XG5cbiAgICBpZiAoZXhwcmVzc2lvblN0ciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goRXhwcmVzc2lvbi5ub3JtYWxpemUoZXhwcmVzc2lvblN0cikpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3IgbWV0aG9kXG4gICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLm5ld1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhFeHByZXNzaW9uLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBleHByZXNzaW9uIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb24ubm9ybWFsaXplKHRoaXMuZXhwcmVzc2lvbnMuam9pbihcIl9cIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmVudCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGlzIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIFRyYW5zZm9ybWF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFyZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBhcmVudCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGlzIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge1RyYW5zZm9ybWF0aW9ufSB0aGUgcGFyZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgZXhwcmVzc2lvblxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3ByZWRpY2F0ZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlZGljYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWRpY2F0ZShuYW1lLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIGlmIChFeHByZXNzaW9uLk9QRVJBVE9SU1tvcGVyYXRvcl0gIT0gbnVsbCkge1xuICAgICAgICBvcGVyYXRvciA9IEV4cHJlc3Npb24uT1BFUkFUT1JTW29wZXJhdG9yXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKFwiXCIuY29uY2F0KG5hbWUsIFwiX1wiKS5jb25jYXQob3BlcmF0b3IsIFwiX1wiKS5jb25jYXQodmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNhbmRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmQoKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goXCJhbmRcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9yKCkge1xuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKFwib3JcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uY2x1ZGUgZXhwcmVzc2lvblxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3RoZW5cbiAgICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm1hdGlvbn0gdGhlIHRyYW5zZm9ybWF0aW9uIHRoaXMgZXhwcmVzc2lvbiBpcyBkZWZpbmVkIGZvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidGhlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aGVuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50KClbXCJpZlwiXSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWlnaHQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJoXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3dpZHRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcIndcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jYXNwZWN0UmF0aW9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiYXJcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jcGFnZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlQ291bnQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJwY1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNmYWNlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoaXMgZXhwcmVzc2lvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFjZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY2VDb3VudChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImZjXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF92YWx1ZSkge1xuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKF92YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICovXG5cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5ld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KGV4cHJlc3Npb25TdHIpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhleHByZXNzaW9uU3RyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgc3RyaW5nIGV4cHJlc3Npb25cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNub3JtYWxpemVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBhIGV4cHJlc3Npb24sIGUuZy4gXCJ3IGd0IDEwMFwiLCBcIndpZHRoX2d0XzEwMFwiLCBcIndpZHRoID4gMTAwXCJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBub3JtYWxpemVkIGZvcm0gb2YgdGhlIHZhbHVlIGV4cHJlc3Npb24sIGUuZy4gXCJ3X2d0XzEwMFwiXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJub3JtYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKGV4cHJlc3Npb24pIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICB9XG5cbiAgICAgIGV4cHJlc3Npb24gPSBTdHJpbmcoZXhwcmVzc2lvbik7XG4gICAgICB2YXIgb3BlcmF0b3JzID0gXCJcXFxcfFxcXFx8fD49fDw9fCYmfCE9fD58PXw8fC98LXxcXFxcK3xcXFxcKnxcXFxcXlwiOyAvLyBvcGVyYXRvcnNcblxuICAgICAgdmFyIG9wZXJhdG9yc1BhdHRlcm4gPSBcIigoXCIgKyBvcGVyYXRvcnMgKyBcIikoPz1bIF9dKSlcIjtcbiAgICAgIHZhciBvcGVyYXRvcnNSZXBsYWNlUkUgPSBuZXcgUmVnRXhwKG9wZXJhdG9yc1BhdHRlcm4sIFwiZ1wiKTtcbiAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2Uob3BlcmF0b3JzUmVwbGFjZVJFLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIEV4cHJlc3Npb24uT1BFUkFUT1JTW21hdGNoXTtcbiAgICAgIH0pOyAvLyBwcmVkZWZpbmVkIHZhcmlhYmxlc1xuICAgICAgLy8gVGhlIDoke3Z9IHBhcnQgaXMgdG8gcHJldmVudCBub3JtYWxpemF0aW9uIG9mIHZhcnMgd2l0aCBhIHByZWNlZGluZyBjb2xvbiAoc3VjaCBhcyA6ZHVyYXRpb24pLFxuICAgICAgLy8gSXQgd29uJ3QgYmUgZm91bmQgaW4gUFJFREVGSU5FRF9WQVJTIGFuZCBzbyB3b24ndCBiZSBub3JtYWxpemVkLlxuICAgICAgLy8gSXQgaXMgZG9uZSBsaWtlIHRoaXMgYmVjYXVzZSBpZTExIGRvZXMgbm90IHN1cHBvcnQgcmVnZXggbG9va2JlaGluZFxuXG4gICAgICB2YXIgcHJlZGVmaW5lZFZhcnNQYXR0ZXJuID0gXCIoXCIgKyBPYmplY3Qua2V5cyhFeHByZXNzaW9uLlBSRURFRklORURfVkFSUykubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBcIjpcIi5jb25jYXQodiwgXCJ8XCIpLmNvbmNhdCh2KTtcbiAgICAgIH0pLmpvaW4oXCJ8XCIpICsgXCIpXCI7XG4gICAgICB2YXIgdXNlclZhcmlhYmxlUGF0dGVybiA9ICcoXFxcXCRfKlteXyBdKyknO1xuICAgICAgdmFyIHZhcmlhYmxlc1JlcGxhY2VSRSA9IG5ldyBSZWdFeHAoXCJcIi5jb25jYXQodXNlclZhcmlhYmxlUGF0dGVybiwgXCJ8XCIpLmNvbmNhdChwcmVkZWZpbmVkVmFyc1BhdHRlcm4pLCBcImdcIik7XG4gICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZXBsYWNlKHZhcmlhYmxlc1JlcGxhY2VSRSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBFeHByZXNzaW9uLlBSRURFRklORURfVkFSU1ttYXRjaF0gfHwgbWF0Y2g7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBleHByZXNzaW9uLnJlcGxhY2UoL1sgX10rL2csICdfJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhcmlhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMobmFtZSkudmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcIndpZHRoXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi53aWR0aFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJ3aWR0aFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJoZWlnaHRcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmhlaWdodFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImhlaWdodFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsV2lkdGhcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmluaXRpYWxXaWR0aFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbFdpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxXaWR0aCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImluaXRpYWxXaWR0aFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsSGVpZ2h0XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5pbml0aWFsSGVpZ2h0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsSGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJpbml0aWFsSGVpZ2h0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImFzcGVjdFJhdGlvXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5hc3BlY3RSYXRpb1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXNwZWN0UmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNwZWN0UmF0aW8oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJhc3BlY3RSYXRpb1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsQXNwZWN0UmF0aW9cIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmluaXRpYWxBc3BlY3RSYXRpb1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbEFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxBc3BlY3RSYXRpbygpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImluaXRpYWxBc3BlY3RSYXRpb1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJwYWdlQ291bnRcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnBhZ2VDb3VudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VDb3VudCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcInBhZ2VDb3VudFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiZmFjZUNvdW50XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5mYWNlQ291bnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZhY2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWNlQ291bnQoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJmYWNlQ291bnRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiY3VycmVudFBhZ2VcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmN1cnJlbnRQYWdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50UGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJyZW50UGFnZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImN1cnJlbnRQYWdlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInRhZ3NcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnRhZ3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGFncygpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcInRhZ3NcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwicGFnZVhcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnBhZ2VYXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwYWdlWFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlWCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcInBhZ2VYXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInBhZ2VZXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5wYWdlWVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZVlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZVkoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJwYWdlWVwiKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXhwcmVzc2lvbjtcbn0oKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuXG5FeHByZXNzaW9uLk9QRVJBVE9SUyA9IHtcbiAgXCI9XCI6ICdlcScsXG4gIFwiIT1cIjogJ25lJyxcbiAgXCI8XCI6ICdsdCcsXG4gIFwiPlwiOiAnZ3QnLFxuICBcIjw9XCI6ICdsdGUnLFxuICBcIj49XCI6ICdndGUnLFxuICBcIiYmXCI6ICdhbmQnLFxuICBcInx8XCI6ICdvcicsXG4gIFwiKlwiOiBcIm11bFwiLFxuICBcIi9cIjogXCJkaXZcIixcbiAgXCIrXCI6IFwiYWRkXCIsXG4gIFwiLVwiOiBcInN1YlwiLFxuICBcIl5cIjogXCJwb3dcIlxufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuRXhwcmVzc2lvbi5QUkVERUZJTkVEX1ZBUlMgPSB7XG4gIFwiYXNwZWN0X3JhdGlvXCI6IFwiYXJcIixcbiAgXCJhc3BlY3RSYXRpb1wiOiBcImFyXCIsXG4gIFwiY3VycmVudF9wYWdlXCI6IFwiY3BcIixcbiAgXCJjdXJyZW50UGFnZVwiOiBcImNwXCIsXG4gIFwiZHVyYXRpb25cIjogXCJkdVwiLFxuICBcImZhY2VfY291bnRcIjogXCJmY1wiLFxuICBcImZhY2VDb3VudFwiOiBcImZjXCIsXG4gIFwiaGVpZ2h0XCI6IFwiaFwiLFxuICBcImluaXRpYWxfYXNwZWN0X3JhdGlvXCI6IFwiaWFyXCIsXG4gIFwiaW5pdGlhbF9kdXJhdGlvblwiOiBcImlkdVwiLFxuICBcImluaXRpYWxfaGVpZ2h0XCI6IFwiaWhcIixcbiAgXCJpbml0aWFsX3dpZHRoXCI6IFwiaXdcIixcbiAgXCJpbml0aWFsQXNwZWN0UmF0aW9cIjogXCJpYXJcIixcbiAgXCJpbml0aWFsRHVyYXRpb25cIjogXCJpZHVcIixcbiAgXCJpbml0aWFsSGVpZ2h0XCI6IFwiaWhcIixcbiAgXCJpbml0aWFsV2lkdGhcIjogXCJpd1wiLFxuICBcInBhZ2VfY291bnRcIjogXCJwY1wiLFxuICBcInBhZ2VfeFwiOiBcInB4XCIsXG4gIFwicGFnZV95XCI6IFwicHlcIixcbiAgXCJwYWdlQ291bnRcIjogXCJwY1wiLFxuICBcInBhZ2VYXCI6IFwicHhcIixcbiAgXCJwYWdlWVwiOiBcInB5XCIsXG4gIFwidGFnc1wiOiBcInRhZ3NcIixcbiAgXCJ3aWR0aFwiOiBcIndcIlxufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuRXhwcmVzc2lvbi5CT1VORFJZID0gXCJbIF9dK1wiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZXhwcmVzc2lvbiA9IChFeHByZXNzaW9uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbmRpdGlvbi5qc1xuZnVuY3Rpb24gY29uZGl0aW9uX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gY29uZGl0aW9uX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIGNvbmRpdGlvbl90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBjb25kaXRpb25fY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBjb25kaXRpb25fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGNvbmRpdGlvbl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGNvbmRpdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgY29uZGl0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGNvbmRpdGlvbl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNmb3JtYXRpb24gY29uZGl0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmRpdGlvblN0ciAtIGEgY29uZGl0aW9uIGluIHN0cmluZyBmb3JtYXRcbiAqIEBjbGFzcyBDb25kaXRpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBub3JtYWxseSB0aGlzIGNsYXNzIGlzIG5vdCBpbnN0YW50aWF0ZWQgZGlyZWN0bHlcbiAqIHZhciB0ciA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KClcbiAqICAgIC5pZigpLndpZHRoKCBcIj5cIiwgMTAwMCkuYW5kKCkuYXNwZWN0UmF0aW8oXCI8XCIsIFwiMzo0XCIpLnRoZW4oKVxuICogICAgICAud2lkdGgoMTAwMClcbiAqICAgICAgLmNyb3AoXCJzY2FsZVwiKVxuICogICAgLmVsc2UoKVxuICogICAgICAud2lkdGgoNTAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKlxuICogdmFyIHRyID0gY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbi5uZXcoKVxuICogICAgLmlmKFwidyA+IDEwMDAgYW5kIGFzcGVjdFJhdGlvIDwgMzo0XCIpXG4gKiAgICAgIC53aWR0aCgxMDAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKiAgICAuZWxzZSgpXG4gKiAgICAgIC53aWR0aCg1MDApXG4gKiAgICAgIC5jcm9wKFwic2NhbGVcIilcbiAqXG4gKi9cblxudmFyIENvbmRpdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V4cHJlc3Npb24pIHtcbiAgX2luaGVyaXRzKENvbmRpdGlvbiwgX0V4cHJlc3Npb24pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ29uZGl0aW9uKTtcblxuICBmdW5jdGlvbiBDb25kaXRpb24oY29uZGl0aW9uU3RyKSB7XG4gICAgY29uZGl0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmRpdGlvbik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29uZGl0aW9uU3RyKTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNoZWlnaHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAqL1xuXG5cbiAgY29uZGl0aW9uX2NyZWF0ZUNsYXNzKENvbmRpdGlvbiwgW3tcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlaWdodChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImhcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiN3aWR0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwid1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2FzcGVjdFJhdGlvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXNwZWN0UmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNwZWN0UmF0aW8ob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJhclwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI3BhZ2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VDb3VudChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcInBjXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jZmFjZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmYWNlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZUNvdW50KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiZmNcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNkdXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImR1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGR1cmF0aW9uKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiZHVcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNpbml0aWFsRHVyYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsRHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbER1cmF0aW9uKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiaWR1XCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbmRpdGlvbjtcbn0oZXhwcmVzc2lvbik7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbmRpdGlvbiA9IChDb25kaXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29uZmlndXJhdGlvbi5qc1xuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBjb25maWd1cmF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgY29uZmlndXJhdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgY29uZmlndXJhdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcbiAqIENsYXNzIGZvciBkZWZpbmluZyBhY2NvdW50IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIERlcGVuZHMgb24gJ3V0aWxzJ1xuICovXG5cbi8qKlxuICogQ2xhc3MgZm9yIGRlZmluaW5nIGFjY291bnQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogQGNvbnN0cnVjdG9yIENvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIGFjY291bnQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIHRvIHNldC5cbiAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICogIHRhcmdldD1cIl9uZXdcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICovXG5cbnZhciBjb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25maWd1cmF0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmZpZ3VyYXRpb24pO1xuXG4gICAgdGhpcy5jb25maWd1cmF0aW9uID0gb3B0aW9ucyA9PSBudWxsID8ge30gOiBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKG9wdGlvbnMpO1xuICAgIGRlZmF1bHRzKHRoaXMuY29uZmlndXJhdGlvbiwgREVGQVVMVF9DT05GSUdVUkFUSU9OX1BBUkFNUyk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb25maWd1cmF0aW9uLiBUaGlzIG1ldGhvZCBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGludm9rZXMgYm90aFxuICAgKiAge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50fGZyb21FbnZpcm9ubWVudCgpfSAoTm9kZS5qcyBlbnZpcm9ubWVudCBvbmx5KVxuICAgKiAgYW5kIHtAbGluayBDb25maWd1cmF0aW9uI2Zyb21Eb2N1bWVudHxmcm9tRG9jdW1lbnQoKX0uXG4gICAqICBJdCBmaXJzdCB0cmllcyB0byByZXRyaWV2ZSB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICogIElmIG5vdCBhdmFpbGFibGUsIGl0IHRyaWVzIGZyb20gdGhlIGRvY3VtZW50IG1ldGEgdGFncy5cbiAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jaW5pdFxuICAgKiBAcmV0dXJuIHtDb25maWd1cmF0aW9ufSByZXR1cm5zIGB0aGlzYCBmb3IgY2hhaW5pbmdcbiAgICogQHNlZSBmcm9tRG9jdW1lbnRcbiAgICogQHNlZSBmcm9tRW52aXJvbm1lbnRcbiAgICovXG5cblxuICBjb25maWd1cmF0aW9uX2NyZWF0ZUNsYXNzKENvbmZpZ3VyYXRpb24sIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuZnJvbUVudmlyb25tZW50KCk7XG4gICAgICB0aGlzLmZyb21Eb2N1bWVudCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIG5ldyBjb25maWd1cmF0aW9uIGl0ZW1cbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBpdGVtIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYmUgc2V0XG4gICAgICogQHJldHVybiB7Q29uZmlndXJhdGlvbn1cbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jb25maWd1cmF0aW9uW25hbWVdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiBhIGNvbmZpZ3VyYXRpb24gaXRlbVxuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI2dldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGl0ZW0gdG8gc2V0XG4gICAgICogQHJldHVybiB7Kn0gdGhlIGNvbmZpZ3VyYXRpb24gaXRlbVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uW25hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShjb25maWcpIHtcbiAgICAgIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkodGhpcy5jb25maWd1cmF0aW9uLCBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKGNvbmZpZykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgQ2xvdWRpbmFyeSBmcm9tIEhUTUwgbWV0YSB0YWdzLlxuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI2Zyb21Eb2N1bWVudFxuICAgICAqIEByZXR1cm4ge0NvbmZpZ3VyYXRpb259XG4gICAgICogQGV4YW1wbGUgPG1ldGEgbmFtZT1cImNsb3VkaW5hcnlfY2xvdWRfbmFtZVwiIGNvbnRlbnQ9XCJteWNsb3VkXCI+XG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZyb21Eb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRG9jdW1lbnQoKSB7XG4gICAgICB2YXIgZWwsIGksIGxlbiwgbWV0YV9lbGVtZW50cztcbiAgICAgIG1ldGFfZWxlbWVudHMgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQgIT09IG51bGwgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdtZXRhW25hbWVePVwiY2xvdWRpbmFyeV9cIl0nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKG1ldGFfZWxlbWVudHMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbWV0YV9lbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGVsID0gbWV0YV9lbGVtZW50c1tpXTtcbiAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bZWwuZ2V0QXR0cmlidXRlKCduYW1lJykucmVwbGFjZSgnY2xvdWRpbmFyeV8nLCAnJyldID0gZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgQ2xvdWRpbmFyeSBmcm9tIHRoZSBgQ0xPVURJTkFSWV9VUkxgIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIG9ubHkgcnVuIHVuZGVyIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50XG4gICAgICogQHJlcXVpcmVzIE5vZGUuanNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZyb21FbnZpcm9ubWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRW52aXJvbm1lbnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2xvdWRpbmFyeV91cmwsIHF1ZXJ5LCB1cmksIHVyaVJlZ2V4O1xuXG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5DTE9VRElOQVJZX1VSTCkge1xuICAgICAgICBjbG91ZGluYXJ5X3VybCA9IHByb2Nlc3MuZW52LkNMT1VESU5BUllfVVJMO1xuICAgICAgICB1cmlSZWdleCA9IC9jbG91ZGluYXJ5OlxcL1xcLyg/OihcXHcrKSg/OlxcOihbXFx3LV0rKSk/QCk/KFtcXHdcXC4tXSspKD86XFwvKFteP10qKSk/KD86XFw/KC4rKSk/LztcbiAgICAgICAgdXJpID0gdXJpUmVnZXguZXhlYyhjbG91ZGluYXJ5X3VybCk7XG5cbiAgICAgICAgaWYgKHVyaSkge1xuICAgICAgICAgIGlmICh1cmlbM10gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uWydjbG91ZF9uYW1lJ10gPSB1cmlbM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVyaVsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ2FwaV9rZXknXSA9IHVyaVsxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXJpWzJdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnYXBpX3NlY3JldCddID0gdXJpWzJdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1cmlbNF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uWydwcml2YXRlX2NkbiddID0gdXJpWzRdICE9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVyaVs0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ3NlY3VyZV9kaXN0cmlidXRpb24nXSA9IHVyaVs0XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBxdWVyeSA9IHVyaVs1XTtcblxuICAgICAgICAgIGlmIChxdWVyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICBxdWVyeS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciBfdmFsdWUkc3BsaXQgPSB2YWx1ZS5zcGxpdCgnPScpLFxuICAgICAgICAgICAgICAgICAgX3ZhbHVlJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF92YWx1ZSRzcGxpdCwgMiksXG4gICAgICAgICAgICAgICAgICBrID0gX3ZhbHVlJHNwbGl0MlswXSxcbiAgICAgICAgICAgICAgICAgIHYgPSBfdmFsdWUkc3BsaXQyWzFdO1xuXG4gICAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzLmNvbmZpZ3VyYXRpb25ba10gPSB2O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgb3IgbW9kaWZ5IHRoZSBDbG91ZGluYXJ5IGNsaWVudCBjb25maWd1cmF0aW9uXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiBgY29uZmlnKClgIHJldHVybnMgdGhlIGFjdHVhbCBpbnRlcm5hbCBjb25maWd1cmF0aW9uIG9iamVjdC4gbW9kaWZ5aW5nIGl0IHdpbGwgY2hhbmdlIHRoZSBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgbWV0aG9kLiBGb3IgbmV3IGNvZGUsIHVzZSBnZXQoKSwgbWVyZ2UoKSBldGMuXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jY29uZmlnXG4gICAgICogQHBhcmFtIHtoYXNofHN0cmluZ3xib29sZWFufSBuZXdfY29uZmlnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld192YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfSBjb25maWd1cmF0aW9uLCBvciB2YWx1ZVxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUVudmlyb25tZW50fSBmb3IgaW5pdGlhbGl6YXRpb24gdXNpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbURvY3VtZW50fSBmb3IgaW5pdGlhbGl6YXRpb24gdXNpbmcgSFRNTCBtZXRhIHRhZ3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWcobmV3X2NvbmZpZywgbmV3X3ZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgIGNhc2UgbmV3X3ZhbHVlID09PSB2b2lkIDA6XG4gICAgICAgICAgdGhpcy5zZXQobmV3X2NvbmZpZywgbmV3X3ZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xuXG4gICAgICAgIGNhc2UgIWlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKG5ld19jb25maWcpOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldChuZXdfY29uZmlnKTtcblxuICAgICAgICBjYXNlICFpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkobmV3X2NvbmZpZyk6XG4gICAgICAgICAgdGhpcy5tZXJnZShuZXdfY29uZmlnKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSAtIHJldHVybiB0aGUgaW50ZXJuYWwgb2JqZWN0XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI3RvT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGEga2V5OnZhbHVlIGNvbGxlY3Rpb24gb2YgdGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9PcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvT3B0aW9ucygpIHtcbiAgICAgIHJldHVybiBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKHRoaXMuY29uZmlndXJhdGlvbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbmZpZ3VyYXRpb247XG59KCk7XG5cbnZhciBERUZBVUxUX0NPTkZJR1VSQVRJT05fUEFSQU1TID0ge1xuICByZXNwb25zaXZlX2NsYXNzOiAnY2xkLXJlc3BvbnNpdmUnLFxuICByZXNwb25zaXZlX3VzZV9icmVha3BvaW50czogdHJ1ZSxcbiAgcm91bmRfZHByOiB0cnVlLFxuICBzZWN1cmU6ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCA/IHdpbmRvdy5sb2NhdGlvbiA/IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA6IHZvaWQgMCA6IHZvaWQgMCkgPT09ICdodHRwczonXG59O1xuY29uZmlndXJhdGlvbl9Db25maWd1cmF0aW9uLkNPTkZJR19QQVJBTVMgPSBbXCJhcGlfa2V5XCIsIFwiYXBpX3NlY3JldFwiLCBcImNhbGxiYWNrXCIsIFwiY2RuX3N1YmRvbWFpblwiLCBcImNsb3VkX25hbWVcIiwgXCJjbmFtZVwiLCBcInByaXZhdGVfY2RuXCIsIFwicHJvdG9jb2xcIiwgXCJyZXNvdXJjZV90eXBlXCIsIFwicmVzcG9uc2l2ZVwiLCBcInJlc3BvbnNpdmVfY2xhc3NcIiwgXCJyZXNwb25zaXZlX3VzZV9icmVha3BvaW50c1wiLCBcInJlc3BvbnNpdmVfd2lkdGhcIiwgXCJyb3VuZF9kcHJcIiwgXCJzZWN1cmVcIiwgXCJzZWN1cmVfY2RuX3N1YmRvbWFpblwiLCBcInNlY3VyZV9kaXN0cmlidXRpb25cIiwgXCJzaG9ydGVuXCIsIFwidHlwZVwiLCBcInVwbG9hZF9wcmVzZXRcIiwgXCJ1cmxfc3VmZml4XCIsIFwidXNlX3Jvb3RfcGF0aFwiLCBcInZlcnNpb25cIiwgXCJleHRlcm5hbExpYnJhcmllc1wiLCBcIm1heF90aW1lb3V0X21zXCJdO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2NvbmZpZ3VyYXRpb24gPSAoY29uZmlndXJhdGlvbl9Db25maWd1cmF0aW9uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xheWVyL2xheWVyLmpzXG5mdW5jdGlvbiBsYXllcl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGxheWVyX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBsYXllcl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxudmFyIGxheWVyX0xheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIExheWVyXG4gICAqIEBjb25zdHJ1Y3RvciBMYXllclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGxheWVyIHBhcmFtZXRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIExheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgbGF5ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5ZXIpO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG5cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICBbXCJyZXNvdXJjZVR5cGVcIiwgXCJ0eXBlXCIsIFwicHVibGljSWRcIiwgXCJmb3JtYXRcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zW2tleV0gPSAocmVmID0gb3B0aW9uc1trZXldKSAhPSBudWxsID8gcmVmIDogb3B0aW9uc1tzbmFrZUNhc2Uoa2V5KV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBsYXllcl9jcmVhdGVDbGFzcyhMYXllciwgW3tcbiAgICBrZXk6IFwicmVzb3VyY2VUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc291cmNlVHlwZSh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZSh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnR5cGUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaWNJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaWNJZCh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnB1YmxpY0lkID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwdWJsaWMgSUQsIGZvcm1hdHRlZCBmb3IgbGF5ZXIgcGFyYW1ldGVyXG4gICAgICogQGZ1bmN0aW9uIExheWVyI2dldFB1YmxpY0lkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBwdWJsaWMgSURcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFB1YmxpY0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFB1YmxpY0lkKCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiAocmVmID0gdGhpcy5vcHRpb25zLnB1YmxpY0lkKSAhPSBudWxsID8gcmVmLnJlcGxhY2UoL1xcLy9nLCBcIjpcIikgOiB2b2lkIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHVibGljIElELCB3aXRoIGZvcm1hdCBpZiBwcmVzZW50XG4gICAgICogQGZ1bmN0aW9uIExheWVyI2dldEZ1bGxQdWJsaWNJZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gcHVibGljIElEXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGdWxsUHVibGljSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnVsbFB1YmxpY0lkKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQdWJsaWNJZCgpICsgXCIuXCIgKyB0aGlzLm9wdGlvbnMuZm9ybWF0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHVibGljSWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvcm1hdCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyXG4gICAgICogQGZ1bmN0aW9uIExheWVyI3RvU3RyaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnRzO1xuICAgICAgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnB1YmxpY0lkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgXCJNdXN0IHN1cHBseSBwdWJsaWNJZFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlID09PSBcImltYWdlXCIpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLnR5cGUgPT09IFwidXBsb2FkXCIpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMudHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLmdldEZ1bGxQdWJsaWNJZCgpKTtcbiAgICAgIHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoY29tcG9uZW50cykuam9pbihcIjpcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExheWVyO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsYXllcl9sYXllciA9IChsYXllcl9MYXllcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sYXllci90ZXh0bGF5ZXIuanNcbmZ1bmN0aW9uIHRleHRsYXllcl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHRleHRsYXllcl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCB0ZXh0bGF5ZXJfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSB0ZXh0bGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHRleHRsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgdGV4dGxheWVyX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCkgeyB0ZXh0bGF5ZXJfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHRleHRsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHRleHRsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHRleHRsYXllcl9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gdGV4dGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmICh0ZXh0bGF5ZXJfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHRleHRsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gdGV4dGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHRleHRsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YobykgeyB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHRleHRsYXllcl9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxuXG52YXIgdGV4dGxheWVyX1RleHRMYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xheWVyKSB7XG4gIHRleHRsYXllcl9pbmhlcml0cyhUZXh0TGF5ZXIsIF9MYXllcik7XG5cbiAgdmFyIF9zdXBlciA9IHRleHRsYXllcl9jcmVhdGVTdXBlcihUZXh0TGF5ZXIpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgVGV4dExheWVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gbGF5ZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gVGV4dExheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB0ZXh0bGF5ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dExheWVyKTtcblxuICAgIHZhciBrZXlzO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtcInJlc291cmNlVHlwZVwiLCBcInJlc291cmNlVHlwZVwiLCBcImZvbnRGYW1pbHlcIiwgXCJmb250U2l6ZVwiLCBcImZvbnRXZWlnaHRcIiwgXCJmb250U3R5bGVcIiwgXCJ0ZXh0RGVjb3JhdGlvblwiLCBcInRleHRBbGlnblwiLCBcInN0cm9rZVwiLCBcImxldHRlclNwYWNpbmdcIiwgXCJsaW5lU3BhY2luZ1wiLCBcImZvbnRIaW50aW5nXCIsIFwiZm9udEFudGlhbGlhc2luZ1wiLCBcInRleHRcIiwgXCJ0ZXh0U3R5bGVcIl07XG5cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9uc1trZXldID0gKHJlZiA9IG9wdGlvbnNba2V5XSkgIT0gbnVsbCA/IHJlZiA6IG9wdGlvbnNbc25ha2VDYXNlKGtleSldO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3RoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUgPSBcInRleHRcIjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB0ZXh0bGF5ZXJfY3JlYXRlQ2xhc3MoVGV4dExheWVyLCBbe1xuICAgIGtleTogXCJyZXNvdXJjZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb3VyY2VUeXBlKF9yZXNvdXJjZVR5cGUpIHtcbiAgICAgIHRocm93IFwiQ2Fubm90IG1vZGlmeSByZXNvdXJjZVR5cGUgZm9yIHRleHQgbGF5ZXJzXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZShfdHlwZSkge1xuICAgICAgdGhyb3cgXCJDYW5ub3QgbW9kaWZ5IHR5cGUgZm9yIHRleHQgbGF5ZXJzXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQoX2Zvcm1hdCkge1xuICAgICAgdGhyb3cgXCJDYW5ub3QgbW9kaWZ5IGZvcm1hdCBmb3IgdGV4dCBsYXllcnNcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udEZhbWlseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250RmFtaWx5KF9mb250RmFtaWx5KSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udEZhbWlseSA9IF9mb250RmFtaWx5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRTaXplKF9mb250U2l6ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRTaXplID0gX2ZvbnRTaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRXZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udFdlaWdodChfZm9udFdlaWdodCkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRXZWlnaHQgPSBfZm9udFdlaWdodDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250U3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udFN0eWxlKF9mb250U3R5bGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250U3R5bGUgPSBfZm9udFN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHREZWNvcmF0aW9uKF90ZXh0RGVjb3JhdGlvbikge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHREZWNvcmF0aW9uID0gX3RleHREZWNvcmF0aW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRBbGlnblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0QWxpZ24oX3RleHRBbGlnbikge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHRBbGlnbiA9IF90ZXh0QWxpZ247XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3Ryb2tlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cm9rZShfc3Ryb2tlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc3Ryb2tlID0gX3N0cm9rZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXR0ZXJTcGFjaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxldHRlclNwYWNpbmcoX2xldHRlclNwYWNpbmcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5sZXR0ZXJTcGFjaW5nID0gX2xldHRlclNwYWNpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGluZVNwYWNpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluZVNwYWNpbmcoX2xpbmVTcGFjaW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubGluZVNwYWNpbmcgPSBfbGluZVNwYWNpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udEhpbnRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udEhpbnRpbmcoX2ZvbnRIaW50aW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udEhpbnRpbmcgPSBfZm9udEhpbnRpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udEFudGlhbGlhc2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250QW50aWFsaWFzaW5nKF9mb250QW50aWFsaWFzaW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udEFudGlhbGlhc2luZyA9IF9mb250QW50aWFsaWFzaW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHQgPSBfdGV4dDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0U3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dFN0eWxlKF90ZXh0U3R5bGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZXh0U3R5bGUgPSBfdGV4dFN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyXG4gICAgICogQGZ1bmN0aW9uIFRleHRMYXllciN0b1N0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudHMsIGhhc1B1YmxpY0lkLCBoYXNTdHlsZSwgcHVibGljSWQsIHJlLCByZXMsIHN0YXJ0LCBzdHlsZSwgdGV4dCwgdGV4dFNvdXJjZTtcbiAgICAgIHN0eWxlID0gdGhpcy50ZXh0U3R5bGVJZGVudGlmaWVyKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHVibGljSWQgIT0gbnVsbCkge1xuICAgICAgICBwdWJsaWNJZCA9IHRoaXMuZ2V0RnVsbFB1YmxpY0lkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dCAhPSBudWxsKSB7XG4gICAgICAgIGhhc1B1YmxpY0lkID0gIWlzRW1wdHkocHVibGljSWQpO1xuICAgICAgICBoYXNTdHlsZSA9ICFpc0VtcHR5KHN0eWxlKTtcblxuICAgICAgICBpZiAoaGFzUHVibGljSWQgJiYgaGFzU3R5bGUgfHwgIWhhc1B1YmxpY0lkICYmICFoYXNTdHlsZSkge1xuICAgICAgICAgIHRocm93IFwiTXVzdCBzdXBwbHkgZWl0aGVyIHN0eWxlIHBhcmFtZXRlcnMgb3IgYSBwdWJsaWNfaWQgd2hlbiBwcm92aWRpbmcgdGV4dCBwYXJhbWV0ZXIgaW4gYSB0ZXh0IG92ZXJsYXkvdW5kZXJsYXksIGJ1dCBub3QgYm90aCFcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlID0gL1xcJFxcKFthLXpBLVpdXFx3KlxcKS9nO1xuICAgICAgICBzdGFydCA9IDA7IC8vICAgICAgICB0ZXh0U291cmNlID0gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJbLC9dXCIsICdnJyksIChjKS0+IFwiJSN7Yy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfVwiKVxuXG4gICAgICAgIHRleHRTb3VyY2UgPSBzbWFydEVzY2FwZSh0aGlzLm9wdGlvbnMudGV4dCwgL1ssXFwvXS9nKTtcbiAgICAgICAgdGV4dCA9IFwiXCI7XG5cbiAgICAgICAgd2hpbGUgKHJlcyA9IHJlLmV4ZWModGV4dFNvdXJjZSkpIHtcbiAgICAgICAgICB0ZXh0ICs9IHNtYXJ0RXNjYXBlKHRleHRTb3VyY2Uuc2xpY2Uoc3RhcnQsIHJlcy5pbmRleCkpO1xuICAgICAgICAgIHRleHQgKz0gcmVzWzBdO1xuICAgICAgICAgIHN0YXJ0ID0gcmVzLmluZGV4ICsgcmVzWzBdLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQgKz0gc21hcnRFc2NhcGUodGV4dFNvdXJjZS5zbGljZShzdGFydCkpO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRzID0gW3RoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUsIHN0eWxlLCBwdWJsaWNJZCwgdGV4dF07XG4gICAgICByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpLmpvaW4oXCI6XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0U3R5bGVJZGVudGlmaWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRTdHlsZUlkZW50aWZpZXIoKSB7XG4gICAgICAvLyBOb3RlOiBpZiBhIHRleHQtc3R5bGUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYXMgYSB3aG9sZSwgaXQgb3ZlcnJpZGVzIGV2ZXJ5dGhpbmcgZWxzZSwgbm8gbWl4IGFuZCBtYXRjaC5cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLm9wdGlvbnMudGV4dFN0eWxlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRleHRTdHlsZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudHM7XG4gICAgICBjb21wb25lbnRzID0gW107XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9udFdlaWdodCAhPT0gXCJub3JtYWxcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLmZvbnRXZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvbnRTdHlsZSAhPT0gXCJub3JtYWxcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLmZvbnRTdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dERlY29yYXRpb24gIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMudGV4dERlY29yYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnRleHRBbGlnbik7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnN0cm9rZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKGlzRW1wdHkodGhpcy5vcHRpb25zLmxldHRlclNwYWNpbmcpICYmICFpc051bWJlckxpa2UodGhpcy5vcHRpb25zLmxldHRlclNwYWNpbmcpKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goXCJsZXR0ZXJfc3BhY2luZ19cIiArIHRoaXMub3B0aW9ucy5sZXR0ZXJTcGFjaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoaXNFbXB0eSh0aGlzLm9wdGlvbnMubGluZVNwYWNpbmcpICYmICFpc051bWJlckxpa2UodGhpcy5vcHRpb25zLmxpbmVTcGFjaW5nKSkpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKFwibGluZV9zcGFjaW5nX1wiICsgdGhpcy5vcHRpb25zLmxpbmVTcGFjaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMub3B0aW9ucy5mb250QW50aWFsaWFzaW5nKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goXCJhbnRpYWxpYXNfXCIgKyB0aGlzLm9wdGlvbnMuZm9udEFudGlhbGlhc2luZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLm9wdGlvbnMuZm9udEhpbnRpbmcpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChcImhpbnRpbmdfXCIgKyB0aGlzLm9wdGlvbnMuZm9udEhpbnRpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRW1wdHkoY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpKSkge1xuICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLm9wdGlvbnMuZm9udEZhbWlseSkpIHtcbiAgICAgICAgICB0aHJvdyBcIk11c3Qgc3VwcGx5IGZvbnRGYW1pbHkuIFwiLmNvbmNhdChjb21wb25lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0VtcHR5KHRoaXMub3B0aW9ucy5mb250U2l6ZSkgJiYgIWlzTnVtYmVyTGlrZSh0aGlzLm9wdGlvbnMuZm9udFNpemUpKSB7XG4gICAgICAgICAgdGhyb3cgXCJNdXN0IHN1cHBseSBmb250U2l6ZS5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRzLnVuc2hpZnQodGhpcy5vcHRpb25zLmZvbnRGYW1pbHksIHRoaXMub3B0aW9ucy5mb250U2l6ZSk7XG4gICAgICBjb21wb25lbnRzID0gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpLmpvaW4oXCJfXCIpO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHRMYXllcjtcbn0obGF5ZXJfbGF5ZXIpO1xuXG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0ZXh0bGF5ZXIgPSAodGV4dGxheWVyX1RleHRMYXllcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sYXllci9zdWJ0aXRsZXNsYXllci5qc1xuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBzdWJ0aXRsZXNsYXllcl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBzdWJ0aXRsZXNsYXllcl90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBzdWJ0aXRsZXNsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgc3VidGl0bGVzbGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCkgeyBzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gc3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHN1YnRpdGxlc2xheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gc3VidGl0bGVzbGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoc3VidGl0bGVzbGF5ZXJfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHN1YnRpdGxlc2xheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZihvKSB7IHN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxudmFyIFN1YnRpdGxlc0xheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGV4dExheWVyKSB7XG4gIHN1YnRpdGxlc2xheWVyX2luaGVyaXRzKFN1YnRpdGxlc0xheWVyLCBfVGV4dExheWVyKTtcblxuICB2YXIgX3N1cGVyID0gc3VidGl0bGVzbGF5ZXJfY3JlYXRlU3VwZXIoU3VidGl0bGVzTGF5ZXIpO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzdWJ0aXRsZXMgbGF5ZXJcbiAgICogQGNvbnN0cnVjdG9yIFN1YnRpdGxlc0xheWVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gbGF5ZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gU3VidGl0bGVzTGF5ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIHN1YnRpdGxlc2xheWVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnRpdGxlc0xheWVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgX3RoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUgPSBcInN1YnRpdGxlc1wiO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBzdWJ0aXRsZXNsYXllcl9jcmVhdGVDbGFzcyhTdWJ0aXRsZXNMYXllcik7XG59KHRleHRsYXllcik7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHN1YnRpdGxlc2xheWVyID0gKFN1YnRpdGxlc0xheWVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xheWVyL2ZldGNobGF5ZXIuanNcbmZ1bmN0aW9uIGZldGNobGF5ZXJfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBmZXRjaGxheWVyX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIGZldGNobGF5ZXJfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBmZXRjaGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBmZXRjaGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKSB7IGZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIGZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZmV0Y2hsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBmZXRjaGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoZmV0Y2hsYXllcl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gZmV0Y2hsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gZmV0Y2hsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBmZXRjaGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YobykgeyBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cbnZhciBmZXRjaGxheWVyX0ZldGNoTGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MYXllcikge1xuICBmZXRjaGxheWVyX2luaGVyaXRzKEZldGNoTGF5ZXIsIF9MYXllcik7XG5cbiAgdmFyIF9zdXBlciA9IGZldGNobGF5ZXJfY3JlYXRlU3VwZXIoRmV0Y2hMYXllcik7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBGZXRjaExheWVyXG4gICAqIEBjbGFzc2Rlc2MgQ3JlYXRlcyBhbiBpbWFnZSBsYXllciB1c2luZyBhIHJlbW90ZSBVUkwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb3B0aW9ucyAtIGxheWVyIHBhcmFtZXRlcnMgb3IgYSB1cmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudXJsIHRoZSB1cmwgb2YgdGhlIGltYWdlIHRvIGZldGNoXG4gICAqL1xuICBmdW5jdGlvbiBGZXRjaExheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmZXRjaGxheWVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZldGNoTGF5ZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShvcHRpb25zKSkge1xuICAgICAgX3RoaXMub3B0aW9ucy51cmwgPSBvcHRpb25zO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy51cmwgOiB2b2lkIDApIHtcbiAgICAgIF90aGlzLm9wdGlvbnMudXJsID0gb3B0aW9ucy51cmw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgZmV0Y2hsYXllcl9jcmVhdGVDbGFzcyhGZXRjaExheWVyLCBbe1xuICAgIGtleTogXCJ1cmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXJsKF91cmwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51cmwgPSBfdXJsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyXG4gICAgICogQGZ1bmN0aW9uIEZldGNoTGF5ZXIjdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcImZldGNoOlwiLmNvbmNhdChiYXNlNjRFbmNvZGVVUkwodGhpcy5vcHRpb25zLnVybCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGZXRjaExheWVyO1xufShsYXllcl9sYXllcik7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGZldGNobGF5ZXIgPSAoZmV0Y2hsYXllcl9GZXRjaExheWVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BhcmFtZXRlcnMuanNcbmZ1bmN0aW9uIHBhcmFtZXRlcnNfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBwYXJhbWV0ZXJzX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIHBhcmFtZXRlcnNfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2YobywgcCkgeyBwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHBhcmFtZXRlcnNfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gcGFyYW1ldGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHBhcmFtZXRlcnNfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHBhcmFtZXRlcnNfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKG8pIHsgcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHBhcmFtZXRlcnNfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHBhcmFtZXRlcnNfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlcnNcbiAqIERlcGVuZHMgb24gJ3V0aWwnLCAndHJhbnNmb3JtYXRpb24nXG4gKi9cblxudmFyIHBhcmFtZXRlcnNfUGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNpbmdsZSBwYXJhbWV0ZXIuXG4gICAqIEBjbGFzcyBQYXJhbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIHZhbHVlIGlzIG5vdCBwcm92aWRlZCwgdGhlIHBhcmFtZXRlciB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvY2Vzcz1VdGlsLmlkZW50aXR5IF0gLSBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBQYXJhbShuYW1lLCBzaG9ydE5hbWUpIHtcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0LmE7XG5cbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcmFtKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gUGFyYW0jbmFtZVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBQYXJhbSNzaG9ydE5hbWVcbiAgICAgKi9cblxuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICAgIC8qKlxuICAgICAqIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAgICogQG1lbWJlciB7ZnVuY3Rpb259IFBhcmFtI3Byb2Nlc3NcbiAgICAgKi9cblxuICAgIHRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhICh1bnByb2Nlc3NlZCkgdmFsdWUgZm9yIHRoaXMgcGFyYW1ldGVyXG4gICAqIEBmdW5jdGlvbiBQYXJhbSNzZXRcbiAgICogQHBhcmFtIHsqfSBvcmlnVmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlclxuICAgKiBAcmV0dXJuIHtQYXJhbX0gc2VsZiBmb3IgY2hhaW5pbmdcbiAgICovXG5cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKFBhcmFtLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG9yaWdWYWx1ZSkge1xuICAgICAgdGhpcy5vcmlnVmFsdWUgPSBvcmlnVmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQGZ1bmN0aW9uIFBhcmFtI3NlcmlhbGl6ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHZhbCwgdmFsaWQ7XG4gICAgICB2YWwgPSB0aGlzLnZhbHVlKCk7XG4gICAgICB2YWxpZCA9IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YWwpIHx8IGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKSh2YWwpIHx8IGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHZhbCkgPyAhaXNFbXB0eSh2YWwpIDogdmFsICE9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLnNob3J0TmFtZSAhPSBudWxsICYmIHZhbGlkKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnNob3J0TmFtZSwgXCJfXCIpLmNvbmNhdCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHByb2Nlc3NlZCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQGZ1bmN0aW9uIFBhcmFtI3ZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModGhpcy5vcmlnVmFsdWUpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5vcm1fY29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybV9jb2xvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZS5yZXBsYWNlKC9eIy8sICdyZ2I6JykgOiB2b2lkIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkX2FycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkX2FycmF5KGFyZykge1xuICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKGFyZykpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbYXJnXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBDb3ZlcnQgdmFsdWUgdG8gdmlkZW8gY29kZWMgc3RyaW5nLlxuICAgICpcbiAgICAqIElmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0LFxuICAgICogQHBhcmFtIHsoc3RyaW5nfE9iamVjdCl9IHBhcmFtIC0gdGhlIHZpZGVvIGNvZGVjIGFzIGVpdGhlciBhIFN0cmluZyBvciBhIEhhc2hcbiAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHZpZGVvIGNvZGVjIHN0cmluZyBpbiB0aGUgZm9ybWF0IGNvZGVjOnByb2ZpbGU6bGV2ZWw6Yl9mcmFtZXNcbiAgICAqIEBleGFtcGxlXG4gICAgKiB2Y19bIDpwcm9maWxlIDogW2xldmVsIDogW2JfZnJhbWVzXV1dXG4gICAgKiBvclxuICAgICAgeyBjb2RlYzogJ2gyNjQnLCBwcm9maWxlOiAnYmFzaWMnLCBsZXZlbDogJzMuMScsIGJfZnJhbWVzOiBmYWxzZSB9XG4gICAgKiBAaWdub3JlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzX3ZpZGVvX3BhcmFtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzX3ZpZGVvX3BhcmFtcyhwYXJhbSkge1xuICAgICAgdmFyIHZpZGVvO1xuXG4gICAgICBzd2l0Y2ggKHBhcmFtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgIHZpZGVvID0gXCJcIjtcblxuICAgICAgICAgIGlmICgnY29kZWMnIGluIHBhcmFtKSB7XG4gICAgICAgICAgICB2aWRlbyA9IHBhcmFtLmNvZGVjO1xuXG4gICAgICAgICAgICBpZiAoJ3Byb2ZpbGUnIGluIHBhcmFtKSB7XG4gICAgICAgICAgICAgIHZpZGVvICs9IFwiOlwiICsgcGFyYW0ucHJvZmlsZTtcblxuICAgICAgICAgICAgICBpZiAoJ2xldmVsJyBpbiBwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZpZGVvICs9IFwiOlwiICsgcGFyYW0ubGV2ZWw7XG5cbiAgICAgICAgICAgICAgICBpZiAoJ2JfZnJhbWVzJyBpbiBwYXJhbSAmJiBwYXJhbS5iX2ZyYW1lcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIHZpZGVvICs9IFwiOmJmcmFtZXNfbm9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmlkZW87XG5cbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgcmV0dXJuIHBhcmFtO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhcmFtO1xufSgpO1xuXG52YXIgcGFyYW1ldGVyc19BcnJheVBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW0pIHtcbiAgcGFyYW1ldGVyc19pbmhlcml0cyhBcnJheVBhcmFtLCBfUGFyYW0pO1xuXG4gIHZhciBfc3VwZXIgPSBwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyKEFycmF5UGFyYW0pO1xuXG4gIC8qKlxuICAgKiBBIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiBzbmFrZV9jYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGUgcGFyYW1ldGVyIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwPScuJ10gLSBUaGUgc2VwYXJhdG9yIHRvIHVzZSB3aGVuIGpvaW5pbmcgdGhlIGFycmF5IGVsZW1lbnRzIHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPVV0aWwuaWRlbnRpdHkgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBjbGFzcyBBcnJheVBhcmFtXG4gICAqIEBleHRlbmRzIFBhcmFtXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEFycmF5UGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJy4nO1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG5cbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFycmF5UGFyYW0pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBzaG9ydE5hbWUsIHByb2Nlc3MpO1xuICAgIF90aGlzLnNlcCA9IHNlcDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKEFycmF5UGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICBpZiAodGhpcy5zaG9ydE5hbWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgYXJyYXlWYWx1ZSA9IHRoaXMudmFsdWUoKTtcblxuICAgICAgICBpZiAoaXNFbXB0eShhcnJheVZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShhcnJheVZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnNob3J0TmFtZSwgXCJfXCIpLmNvbmNhdChhcnJheVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmxhdCA9IGFycmF5VmFsdWUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHQuc2VyaWFsaXplKSA/IHQuc2VyaWFsaXplKCkgOiB0O1xuICAgICAgICAgIH0pLmpvaW4odGhpcy5zZXApO1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnNob3J0TmFtZSwgXCJfXCIpLmNvbmNhdChmbGF0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnVmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9jZXNzKHYpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModGhpcy5vcmlnVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG9yaWdWYWx1ZSkge1xuICAgICAgaWYgKG9yaWdWYWx1ZSA9PSBudWxsIHx8IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShvcmlnVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoQXJyYXlQYXJhbS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIG9yaWdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2dldChwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKEFycmF5UGFyYW0ucHJvdG90eXBlKSwgXCJzZXRcIiwgdGhpcykuY2FsbCh0aGlzLCBbb3JpZ1ZhbHVlXSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFycmF5UGFyYW07XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG52YXIgcGFyYW1ldGVyc19UcmFuc2Zvcm1hdGlvblBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW0yKSB7XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoVHJhbnNmb3JtYXRpb25QYXJhbSwgX1BhcmFtMik7XG5cbiAgdmFyIF9zdXBlcjIgPSBwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyKFRyYW5zZm9ybWF0aW9uUGFyYW0pO1xuXG4gIC8qKlxuICAgKiBBIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgYSB0cmFuc2Zvcm1hdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nob3J0TmFtZT0ndCddIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwPScuJ10gLSBUaGUgc2VwYXJhdG9yIHRvIHVzZSB3aGVuIGpvaW5pbmcgdGhlIGFycmF5IGVsZW1lbnRzIHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPVV0aWwuaWRlbnRpdHkgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblBhcmFtXG4gICAqIEBleHRlbmRzIFBhcmFtXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uUGFyYW0obmFtZSkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICB2YXIgc2hvcnROYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcInRcIjtcbiAgICB2YXIgc2VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnLic7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcblxuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtYXRpb25QYXJhbSk7XG5cbiAgICBfdGhpczMgPSBfc3VwZXIyLmNhbGwodGhpcywgbmFtZSwgc2hvcnROYW1lLCBwcm9jZXNzKTtcbiAgICBfdGhpczMuc2VwID0gc2VwO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHN0cmluZyByZXByZXNlbnRhdGlvbnMgb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBlaXRoZXIgdGhlIHRyYW5zZm9ybWF0aW9uIGFzIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBzdHJpbmcgcmVwcmVzZW50YXRpb25zLlxuICAgKi9cblxuXG4gIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoVHJhbnNmb3JtYXRpb25QYXJhbSwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZSgpO1xuXG4gICAgICBpZiAoaXNFbXB0eSh2YWwpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IC8vIHZhbCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIHNvIGpvaW4gdGhlbVxuXG5cbiAgICAgIGlmIChiYXNldXRpbF9hbGxTdHJpbmdzKHZhbCkpIHtcbiAgICAgICAgdmFyIGpvaW5lZCA9IHZhbC5qb2luKHRoaXMuc2VwKTsgLy8gY3JlYXRlcyB0MS50Mi50MyBpbiBjYXNlIG11bHRpcGxlIG5hbWVkIHRyYW5zZm9ybWF0aW9ucyB3ZXJlIGNvbmZpZ3VyZWRcblxuICAgICAgICBpZiAoIWlzRW1wdHkoam9pbmVkKSkge1xuICAgICAgICAgIC8vIGluIGNhc2Ugb3B0aW9ucy50cmFuc2Zvcm1hdGlvbiB3YXMgbm90IHNldCB3aXRoIGFuIGVtcHR5IHN0cmluZyAodmFsICE9IFsnJ10pO1xuICAgICAgICAgIHJlc3VsdCA9IFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KGpvaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnZlcnQgdmFsIHRvIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgICAgcmVzdWx0ID0gdmFsLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh0KSAmJiAhaXNFbXB0eSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KF90aGlzNC5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0LnNlcmlhbGl6ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnNlcmlhbGl6ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkodCkgJiYgIWlzRW1wdHkodCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKHQpLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChvcmlnVmFsdWUxKSB7XG4gICAgICB0aGlzLm9yaWdWYWx1ZSA9IG9yaWdWYWx1ZTE7XG5cbiAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoVHJhbnNmb3JtYXRpb25QYXJhbS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMub3JpZ1ZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoVHJhbnNmb3JtYXRpb25QYXJhbS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIFt0aGlzLm9yaWdWYWx1ZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2Zvcm1hdGlvblBhcmFtO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcblxudmFyIG51bWJlcl9wYXR0ZXJuID0gXCIoWzAtOV0qKVxcXFwuKFswLTldKyl8KFswLTldKylcIjtcbnZhciBvZmZzZXRfYW55X3BhdHRlcm4gPSBcIihcIiArIG51bWJlcl9wYXR0ZXJuICsgXCIpKFslcFBdKT9cIjtcblxudmFyIHBhcmFtZXRlcnNfUmFuZ2VQYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtMykge1xuICBwYXJhbWV0ZXJzX2luaGVyaXRzKFJhbmdlUGFyYW0sIF9QYXJhbTMpO1xuXG4gIHZhciBfc3VwZXIzID0gcGFyYW1ldGVyc19jcmVhdGVTdXBlcihSYW5nZVBhcmFtKTtcblxuICAvKipcbiAgICogQSBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIGEgcmFuZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIHZhbHVlIGlzIG5vdCBwcm92aWRlZCwgdGhlIHBhcmFtZXRlciB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvY2Vzcz1ub3JtX3JhbmdlX3ZhbHVlIF0gLSBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgKiBAY2xhc3MgUmFuZ2VQYXJhbVxuICAgKiBAZXh0ZW5kcyBQYXJhbVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBSYW5nZVBhcmFtKG5hbWUsIHNob3J0TmFtZSkge1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBSYW5nZVBhcmFtLm5vcm1fcmFuZ2VfdmFsdWU7XG5cbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlUGFyYW0pO1xuXG4gICAgcmV0dXJuIF9zdXBlcjMuY2FsbCh0aGlzLCBuYW1lLCBzaG9ydE5hbWUsIHByb2Nlc3MpO1xuICB9XG5cbiAgcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhSYW5nZVBhcmFtLCBudWxsLCBbe1xuICAgIGtleTogXCJub3JtX3JhbmdlX3ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1fcmFuZ2VfdmFsdWUodmFsdWUpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBTdHJpbmcodmFsdWUpLm1hdGNoKG5ldyBSZWdFeHAoJ14nICsgb2Zmc2V0X2FueV9wYXR0ZXJuICsgJyQnKSk7XG5cbiAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVyID0gb2Zmc2V0WzVdICE9IG51bGwgPyAncCcgOiAnJztcbiAgICAgICAgdmFsdWUgPSAob2Zmc2V0WzFdIHx8IG9mZnNldFs0XSkgKyBtb2RpZmllcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKHZhbHVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFuZ2VQYXJhbTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG5cbnZhciBwYXJhbWV0ZXJzX1Jhd1BhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW00KSB7XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoUmF3UGFyYW0sIF9QYXJhbTQpO1xuXG4gIHZhciBfc3VwZXI0ID0gcGFyYW1ldGVyc19jcmVhdGVTdXBlcihSYXdQYXJhbSk7XG5cbiAgZnVuY3Rpb24gUmF3UGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hO1xuXG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBSYXdQYXJhbSk7XG5cbiAgICByZXR1cm4gX3N1cGVyNC5jYWxsKHRoaXMsIG5hbWUsIHNob3J0TmFtZSwgcHJvY2Vzcyk7XG4gIH1cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKFJhd1BhcmFtLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmF3UGFyYW07XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG52YXIgcGFyYW1ldGVyc19MYXllclBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW01KSB7XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoTGF5ZXJQYXJhbSwgX1BhcmFtNSk7XG5cbiAgdmFyIF9zdXBlcjUgPSBwYXJhbWV0ZXJzX2NyZWF0ZVN1cGVyKExheWVyUGFyYW0pO1xuXG4gIGZ1bmN0aW9uIExheWVyUGFyYW0oKSB7XG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXllclBhcmFtKTtcblxuICAgIHJldHVybiBfc3VwZXI1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKExheWVyUGFyYW0sIFt7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IC8vIFBhcnNlIGxheWVyIG9wdGlvbnNcbiAgICAvLyBAcmV0dXJuIFtzdHJpbmddIGxheWVyIHRyYW5zZm9ybWF0aW9uIHN0cmluZ1xuICAgIC8vIEBwcml2YXRlXG4gICAgZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5vcmlnVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICh0aGlzLm9yaWdWYWx1ZSBpbnN0YW5jZW9mIGxheWVyX2xheWVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMub3JpZ1ZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgIHZhciBsYXllck9wdGlvbnMgPSB3aXRoQ2FtZWxDYXNlS2V5cyh0aGlzLm9yaWdWYWx1ZSk7XG5cbiAgICAgICAgaWYgKGxheWVyT3B0aW9ucy5yZXNvdXJjZVR5cGUgPT09IFwidGV4dFwiIHx8IGxheWVyT3B0aW9ucy50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgdGV4dGxheWVyKGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5ZXJPcHRpb25zLnJlc291cmNlVHlwZSA9PT0gXCJzdWJ0aXRsZXNcIikge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBzdWJ0aXRsZXNsYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGxheWVyT3B0aW9ucy5yZXNvdXJjZVR5cGUgPT09IFwiZmV0Y2hcIiB8fCBsYXllck9wdGlvbnMudXJsICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgZmV0Y2hsYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBsYXllcl9sYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICBpZiAoL15mZXRjaDouKy8udGVzdCh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgZmV0Y2hsYXllcih0aGlzLm9yaWdWYWx1ZS5zdWJzdHIoNikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMub3JpZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInRleHRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0U3R5bGUobGF5ZXIpIHtcbiAgICAgIHJldHVybiBuZXcgdGV4dGxheWVyKGxheWVyKS50ZXh0U3R5bGVJZGVudGlmaWVyKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExheWVyUGFyYW07XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG52YXIgcGFyYW1ldGVyc19FeHByZXNzaW9uUGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbTYpIHtcbiAgcGFyYW1ldGVyc19pbmhlcml0cyhFeHByZXNzaW9uUGFyYW0sIF9QYXJhbTYpO1xuXG4gIHZhciBfc3VwZXI2ID0gcGFyYW1ldGVyc19jcmVhdGVTdXBlcihFeHByZXNzaW9uUGFyYW0pO1xuXG4gIGZ1bmN0aW9uIEV4cHJlc3Npb25QYXJhbSgpIHtcbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4cHJlc3Npb25QYXJhbSk7XG5cbiAgICByZXR1cm4gX3N1cGVyNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhFeHByZXNzaW9uUGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbi5ub3JtYWxpemUoX2dldChwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKEV4cHJlc3Npb25QYXJhbS5wcm90b3R5cGUpLCBcInNlcmlhbGl6ZVwiLCB0aGlzKS5jYWxsKHRoaXMpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXhwcmVzc2lvblBhcmFtO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90cmFuc2Zvcm1hdGlvbi5qc1xuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiB0cmFuc2Zvcm1hdGlvbl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCB0cmFuc2Zvcm1hdGlvbl90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSB0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YobywgcCkgeyB0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHRyYW5zZm9ybWF0aW9uX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gdHJhbnNmb3JtYXRpb25fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAodHJhbnNmb3JtYXRpb25fdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZihvKSB7IHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gdHJhbnNmb3JtYXRpb25fYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCB0cmFuc2Zvcm1hdGlvbl9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHRyYW5zZm9ybWF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgdHJhbnNmb3JtYXRpb25fbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gdHJhbnNmb3JtYXRpb25fYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgdHJhbnNmb3JtYXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG5cblxuXG5cbi8qKlxuICogQXNzaWduIGtleSwgdmFsdWUgdG8gdGFyZ2V0LCB3aGVuIHZhbHVlIGlzIG5vdCBudWxsLjxicj5cbiAqICAgVGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSB0YXJnZXQhXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IHRoZSBvYmplY3QgdG8gYXNzaWduIHRoZSB2YWx1ZXMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2VzIG9uZSBvciBtb3JlIG9iamVjdHMgdG8gZ2V0IHZhbHVlcyBmcm9tXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgdGFyZ2V0IGFmdGVyIHRoZSBhc3NpZ25tZW50XG4gKi9cblxuZnVuY3Rpb24gYXNzaWduTm90TnVsbCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKHNvdXJjZVtrZXldICE9IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uQmFzZVxuICogRGVwZW5kcyBvbiAnY29uZmlndXJhdGlvbicsICdwYXJhbWV0ZXJzJywndXRpbCdcbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBUaGUgYmFzZSBjbGFzcyBmb3IgdHJhbnNmb3JtYXRpb25zLlxuICAgKiBNZW1iZXJzIG9mIHRoaXMgY2xhc3MgYXJlIGRvY3VtZW50ZWQgYXMgYmVsb25naW5nIHRvIHRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IGNsYXNzIGZvciBjb252ZW5pZW5jZS5cbiAgICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uQmFzZVxuICAgKi9cbiAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb25CYXNlKG9wdGlvbnMpIHtcbiAgICB0cmFuc2Zvcm1hdGlvbl9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2Zvcm1hdGlvbkJhc2UpO1xuXG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB2YXIgcGFyZW50LCB0cmFucztcbiAgICBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdHJhbnMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gb3B0aW9ucyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gaWRlbnRpY2FsIFRyYW5zZm9ybWF0aW9uXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3RvT3B0aW9uc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyB0cmFuc2Zvcm1hdGlvblxuICAgICAqL1xuXG4gICAgdGhpcy50b09wdGlvbnMgPSBmdW5jdGlvbiAod2l0aENoYWluKSB7XG4gICAgICB2YXIgb3B0ID0ge307XG5cbiAgICAgIGlmICh3aXRoQ2hhaW4gPT0gbnVsbCkge1xuICAgICAgICB3aXRoQ2hhaW4gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBPYmplY3Qua2V5cyh0cmFucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBvcHRba2V5XSA9IHRyYW5zW2tleV0ub3JpZ1ZhbHVlO1xuICAgICAgfSk7XG4gICAgICBhc3NpZ25Ob3ROdWxsKG9wdCwgdGhpcy5vdGhlck9wdGlvbnMpO1xuXG4gICAgICBpZiAod2l0aENoYWluICYmICFpc0VtcHR5KHRoaXMuY2hhaW5lZCkpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmNoYWluZWQubWFwKGZ1bmN0aW9uICh0cikge1xuICAgICAgICAgIHJldHVybiB0ci50b09wdGlvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3QucHVzaChvcHQpO1xuICAgICAgICBvcHQgPSB7fTtcbiAgICAgICAgYXNzaWduTm90TnVsbChvcHQsIHRoaXMub3RoZXJPcHRpb25zKTtcbiAgICAgICAgb3B0LnRyYW5zZm9ybWF0aW9uID0gbGlzdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIHBhcmVudCBmb3IgdGhpcyBvYmplY3QgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3NldFBhcmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSB0aGUgcGFyZW50IHRvIGJlIGFzc2lnbmVkIHRvXG4gICAgICogQHJldHVybnMge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuXG5cbiAgICB0aGlzLnNldFBhcmVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHBhcmVudCA9IG9iamVjdDtcblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZnJvbU9wdGlvbnModHlwZW9mIG9iamVjdC50b09wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IG9iamVjdC50b09wdGlvbnMoKSA6IHZvaWQgMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0IGluIHRoZSBjaGFpblxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNnZXRQYXJlbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBvYmplY3QgaWYgdGhlcmUgaXMgYW55XG4gICAgICovXG5cblxuICAgIHRoaXMuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9OyAvLyBIZWxwZXIgbWV0aG9kcyB0byBjcmVhdGUgcGFyYW1ldGVyIG1ldGhvZHNcbiAgICAvLyBUaGVzZSBtZXRob2RzIGFyZSBkZWZpbmVkIGhlcmUgYmVjYXVzZSB0aGV5IGFjY2VzcyBgdHJhbnNgIHdoaWNoIGlzXG4gICAgLy8gYSBwcml2YXRlIG1lbWJlciBvZiBgVHJhbnNmb3JtYXRpb25CYXNlYFxuXG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cblxuXG4gICAgdGhpcy5wYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJiciwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICBpZiAocHJvY2VzcyA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgIHByb2Nlc3MgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2VzcyA9IGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfUGFyYW0obmFtZSwgYWJiciwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cblxuXG4gICAgdGhpcy5yYXdQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJiciwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1Jhd1BhcmFtKG5hbWUsIGFiYnIsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG5cblxuICAgIHRoaXMucmFuZ2VQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJiciwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1JhbmdlUGFyYW0obmFtZSwgYWJiciwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cblxuXG4gICAgdGhpcy5hcnJheVBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyKSB7XG4gICAgICB2YXIgc2VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcIjpcIjtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xuICAgICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MgPSBsYXN0QXJnQ2FsbGJhY2soYXJndW1lbnRzKTtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfQXJyYXlQYXJhbShuYW1lLCBhYmJyLCBzZXAsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG5cblxuICAgIHRoaXMudHJhbnNmb3JtYXRpb25QYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJicikge1xuICAgICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCIuXCI7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2VzcyA9IGxhc3RBcmdDYWxsYmFjayhhcmd1bWVudHMpO1xuICAgICAgdHJhbnNbbmFtZV0gPSBuZXcgcGFyYW1ldGVyc19UcmFuc2Zvcm1hdGlvblBhcmFtKG5hbWUsIGFiYnIsIHNlcCwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmxheWVyUGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGFiYnIpIHtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfTGF5ZXJQYXJhbShuYW1lLCBhYmJyKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTsgLy8gRW5kIEhlbHBlciBtZXRob2RzXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jZ2V0VmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgcHJvY2Vzc2VkIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgICAqIEBkZXNjcmlwdGlvbiBVc2Uge0BsaW5rIGdldH0ub3JpZ1ZhbHVlIGZvciB0aGUgdmFsdWUgb3JpZ2luYWxseSBwcm92aWRlZCBmb3IgdGhlIHBhcmFtZXRlclxuICAgICAqL1xuXG5cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRyYW5zW25hbWVdICYmIHRyYW5zW25hbWVdLnZhbHVlKCk7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy5vdGhlck9wdGlvbnNbbmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmFtZXRlciBvYmplY3QgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZVxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNnZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVyXG4gICAgICogQHJldHVybnMge1BhcmFtfSB0aGUgcGFyYW0gb2JqZWN0IGZvciB0aGUgZ2l2ZW4gbmFtZSwgb3IgdW5kZWZpbmVkXG4gICAgICovXG5cblxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiB0cmFuc1tuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHRyYW5zZm9ybWF0aW9uIG9wdGlvbiBmcm9tIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jcmVtb3ZlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIG9wdGlvbiB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwgaWYgbm8gb3B0aW9uIGJ5IHRoYXQgbmFtZSB3YXMgZm91bmQuIFRoZSB0eXBlIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICByZXR1cm5lZCB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB2YWx1ZS5cbiAgICAgKi9cblxuXG4gICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHRlbXA7XG5cbiAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgY2FzZSB0cmFuc1tuYW1lXSA9PSBudWxsOlxuICAgICAgICAgIHRlbXAgPSB0cmFuc1tuYW1lXTtcbiAgICAgICAgICBkZWxldGUgdHJhbnNbbmFtZV07XG4gICAgICAgICAgcmV0dXJuIHRlbXAub3JpZ1ZhbHVlO1xuXG4gICAgICAgIGNhc2UgdGhpcy5vdGhlck9wdGlvbnNbbmFtZV0gPT0gbnVsbDpcbiAgICAgICAgICB0ZW1wID0gdGhpcy5vdGhlck9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgZGVsZXRlIHRoaXMub3RoZXJPcHRpb25zW25hbWVdO1xuICAgICAgICAgIHJldHVybiB0ZW1wO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgYWxsIHRoZSBrZXlzIChvcHRpb24gbmFtZXMpIGluIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSB0aGUga2V5cyBpbiBzbmFrZUNhc2UgZm9ybWF0XG4gICAgICovXG5cblxuICAgIHRoaXMua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvciAoa2V5IGluIHRyYW5zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goa2V5Lm1hdGNoKFZBUl9OQU1FX1JFKSA/IGtleSA6IHNuYWtlQ2FzZShrZXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0oKS5zb3J0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi4gVmFsdWVzIGFyZSBwcm9jZXNzZWQuXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3RvUGxhaW5PYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zIGFzIHBsYWluIG9iamVjdFxuICAgICAqL1xuXG5cbiAgICB0aGlzLnRvUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGFzaCwga2V5LCBsaXN0O1xuICAgICAgaGFzaCA9IHt9O1xuXG4gICAgICBmb3IgKGtleSBpbiB0cmFucykge1xuICAgICAgICBoYXNoW2tleV0gPSB0cmFuc1trZXldLnZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShoYXNoW2tleV0pKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKShoYXNoW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLmNoYWluZWQpKSB7XG4gICAgICAgIGxpc3QgPSB0aGlzLmNoYWluZWQubWFwKGZ1bmN0aW9uICh0cikge1xuICAgICAgICAgIHJldHVybiB0ci50b1BsYWluT2JqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0LnB1c2goaGFzaCk7XG4gICAgICAgIGhhc2ggPSB7XG4gICAgICAgICAgdHJhbnNmb3JtYXRpb246IGxpc3RcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhbmQgY2hhaW4gdG8gYSBuZXcgb25lLlxuICAgICAqIEluIHRoZSBVUkwsIHRyYW5zZm9ybWF0aW9ucyBhcmUgY2hhaW5lZCB0b2dldGhlciBieSBzbGFzaGVzLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNjaGFpblxuICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgdHJhbnNmb3JtYXRpb24gZm9yIGNoYWluaW5nXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgdHIgPSBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uLm5ldygpO1xuICAgICAqIHRyLndpZHRoKDEwKS5jcm9wKCdmaXQnKS5jaGFpbigpLmFuZ2xlKDE1KS5zZXJpYWxpemUoKVxuICAgICAqIC8vIHByb2R1Y2VzIFwiY19maXQsd18xMC9hXzE1XCJcbiAgICAgKi9cblxuXG4gICAgdGhpcy5jaGFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lcywgdHI7XG4gICAgICBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRyYW5zKTtcblxuICAgICAgaWYgKG5hbWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0ciA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudG9PcHRpb25zKGZhbHNlKSk7XG4gICAgICAgIHRoaXMucmVzZXRUcmFuc2Zvcm1hdGlvbnMoKTtcbiAgICAgICAgdGhpcy5jaGFpbmVkLnB1c2godHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldFRyYW5zZm9ybWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYW5zID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5vdGhlck9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmNoYWluZWQgPSBbXTtcbiAgICB0aGlzLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZSB0aGUgcHJvdmlkZWQgb3B0aW9ucyB3aXRoIG93bidzIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBrZXktdmFsdWUgbGlzdCBvZiBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtUcmFuc2Zvcm1hdGlvbn0gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgKi9cblxuXG4gIHRyYW5zZm9ybWF0aW9uX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybWF0aW9uQmFzZSwgW3tcbiAgICBrZXk6IFwiZnJvbU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgVHJhbnNmb3JtYXRpb25CYXNlKSB7XG4gICAgICAgIHRoaXMuZnJvbVRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKG9wdGlvbnMpIHx8IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShvcHRpb25zKSkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbjogb3B0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKShvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUcmFuc2Zvcm1hdGlvbkJhc2UgfHwgdmFsdWUgaW5zdGFuY2VvZiBMYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZS5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIEhhbmRsaW5nIG9mIFwiaWZcIiBzdGF0ZW1lbnRzIHByZWNlZGVzIG90aGVyIG9wdGlvbnMgYXMgaXQgY3JlYXRlcyBhIGNoYWluZWQgdHJhbnNmb3JtYXRpb25cblxuICAgICAgICBpZiAob3B0aW9uc1tcImlmXCJdKSB7XG4gICAgICAgICAgdGhpcy5zZXQoXCJpZlwiLCBvcHRpb25zW1wiaWZcIl0pO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW1wiaWZcIl07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHZhciBvcHQgPSBvcHRpb25zW2tleV07XG5cbiAgICAgICAgICBpZiAob3B0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrZXkubWF0Y2goVkFSX05BTUVfUkUpKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgIT09ICckYXR0cicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCgndmFyaWFibGUnLCBrZXksIG9wdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgb3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21UcmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tVHJhbnNmb3JtYXRpb24ob3RoZXIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFRyYW5zZm9ybWF0aW9uQmFzZSkge1xuICAgICAgICBvdGhlci5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNldChrZXksIG90aGVyLmdldChrZXkpLm9yaWdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgcGFyYW1ldGVyLlxuICAgICAqIFRoZSBwYXJhbWV0ZXIgbmFtZSBga2V5YCBpcyBjb252ZXJ0ZWQgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVzIC0gdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNmb3JtYXRpb259IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5KSB7XG4gICAgICB2YXIgY2FtZWxLZXk7XG4gICAgICBjYW1lbEtleSA9IGNhbWVsQ2FzZShrZXkpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHZhbHVlc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHMsIGNhbWVsS2V5KSkge1xuICAgICAgICB0aGlzW2NhbWVsS2V5XS5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vdGhlck9wdGlvbnNba2V5XSA9IHZhbHVlc1swXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0xheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0xheWVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoXCJvdmVybGF5XCIpIHx8IHRoaXMuZ2V0VmFsdWUoXCJ1bmRlcmxheVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNzZXJpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyYW5zZm9ybWF0aW9uIGFzIGEgc3RyaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIGlmUGFyYW0sIGosIGxlbiwgcGFyYW1MaXN0LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlc3VsdEFycmF5LCB0LCB0cmFuc2Zvcm1hdGlvbkxpc3QsIHRyYW5zZm9ybWF0aW9uU3RyaW5nLCB0cmFuc2Zvcm1hdGlvbnMsIHZhbHVlLCB2YXJpYWJsZXMsIHZhcnM7XG4gICAgICByZXN1bHRBcnJheSA9IHRoaXMuY2hhaW5lZC5tYXAoZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgIHJldHVybiB0ci5zZXJpYWxpemUoKTtcbiAgICAgIH0pO1xuICAgICAgcGFyYW1MaXN0ID0gdGhpcy5rZXlzKCk7XG4gICAgICB0cmFuc2Zvcm1hdGlvbnMgPSAocmVmID0gdGhpcy5nZXQoXCJ0cmFuc2Zvcm1hdGlvblwiKSkgIT0gbnVsbCA/IHJlZi5zZXJpYWxpemUoKSA6IHZvaWQgMDtcbiAgICAgIGlmUGFyYW0gPSAocmVmMSA9IHRoaXMuZ2V0KFwiaWZcIikpICE9IG51bGwgPyByZWYxLnNlcmlhbGl6ZSgpIDogdm9pZCAwO1xuICAgICAgdmFyaWFibGVzID0gcHJvY2Vzc1ZhcigocmVmMiA9IHRoaXMuZ2V0KFwidmFyaWFibGVzXCIpKSAhPSBudWxsID8gcmVmMi52YWx1ZSgpIDogdm9pZCAwKTtcbiAgICAgIHBhcmFtTGlzdCA9IGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlX2RlZmF1bHQoKShwYXJhbUxpc3QsIFtcInRyYW5zZm9ybWF0aW9uXCIsIFwiaWZcIiwgXCJ2YXJpYWJsZXNcIl0pO1xuICAgICAgdmFycyA9IFtdO1xuICAgICAgdHJhbnNmb3JtYXRpb25MaXN0ID0gW107XG5cbiAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHBhcmFtTGlzdC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICB0ID0gcGFyYW1MaXN0W2pdO1xuXG4gICAgICAgIGlmICh0Lm1hdGNoKFZBUl9OQU1FX1JFKSkge1xuICAgICAgICAgIHZhcnMucHVzaCh0ICsgXCJfXCIgKyBleHByZXNzaW9uLm5vcm1hbGl6ZSgocmVmMyA9IHRoaXMuZ2V0KHQpKSAhPSBudWxsID8gcmVmMy52YWx1ZSgpIDogdm9pZCAwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnB1c2goKHJlZjQgPSB0aGlzLmdldCh0KSkgIT0gbnVsbCA/IHJlZjQuc2VyaWFsaXplKCkgOiB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgY2FzZSAhaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25zKTpcbiAgICAgICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QucHVzaCh0cmFuc2Zvcm1hdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgIWlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh0cmFuc2Zvcm1hdGlvbnMpOlxuICAgICAgICAgIHJlc3VsdEFycmF5ID0gcmVzdWx0QXJyYXkuY29uY2F0KHRyYW5zZm9ybWF0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGssIGxlbjEsIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gdHJhbnNmb3JtYXRpb25MaXN0Lmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgIHZhbHVlID0gdHJhbnNmb3JtYXRpb25MaXN0W2tdO1xuXG4gICAgICAgICAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YWx1ZSkgJiYgIWlzRW1wdHkodmFsdWUpIHx8ICFpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodmFsdWUpICYmIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSgpO1xuXG4gICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QgPSB2YXJzLnNvcnQoKS5jb25jYXQodmFyaWFibGVzKS5jb25jYXQodHJhbnNmb3JtYXRpb25MaXN0LnNvcnQoKSk7XG5cbiAgICAgIGlmIChpZlBhcmFtID09PSBcImlmX2VuZFwiKSB7XG4gICAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdC5wdXNoKGlmUGFyYW0pO1xuICAgICAgfSBlbHNlIGlmICghaXNFbXB0eShpZlBhcmFtKSkge1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QudW5zaGlmdChpZlBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNmb3JtYXRpb25TdHJpbmcgPSBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25MaXN0KS5qb2luKHRoaXMucGFyYW1fc2VwYXJhdG9yKTtcblxuICAgICAgaWYgKCFpc0VtcHR5KHRyYW5zZm9ybWF0aW9uU3RyaW5nKSkge1xuICAgICAgICByZXN1bHRBcnJheS5wdXNoKHRyYW5zZm9ybWF0aW9uU3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShyZXN1bHRBcnJheSkuam9pbih0aGlzLnRyYW5zX3NlcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBsaXN0IG9mIGFsbCB0aGUgdmFsaWQgdHJhbnNmb3JtYXRpb24gb3B0aW9uIG5hbWVzXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI2xpc3ROYW1lc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gYSBhcnJheSBvZiBhbGwgdGhlIHZhbGlkIG9wdGlvbiBuYW1lc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9IdG1sQXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF0dHJpYnV0ZXMgZm9yIGFuIEhUTUwgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5LnRvSHRtbEF0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJuIFBsYWluT2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IdG1sQXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgYXR0ck5hbWUsIGhlaWdodCwgb3B0aW9ucywgcmVmMiwgcmVmMywgdmFsdWUsIHdpZHRoO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIHNuYWtlQ2FzZUtleTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub3RoZXJPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFsdWUgPSBfdGhpczIub3RoZXJPcHRpb25zW2tleV07XG4gICAgICAgIHNuYWtlQ2FzZUtleSA9IHNuYWtlQ2FzZShrZXkpO1xuXG4gICAgICAgIGlmICghaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24uUEFSQU1fTkFNRVMsIHNuYWtlQ2FzZUtleSkgJiYgIWluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKFVSTF9LRVlTLCBzbmFrZUNhc2VLZXkpKSB7XG4gICAgICAgICAgYXR0ck5hbWUgPSAvXmh0bWxfLy50ZXN0KGtleSkgPyBrZXkuc2xpY2UoNSkgOiBrZXk7XG4gICAgICAgICAgb3B0aW9uc1thdHRyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIGNvbnZlcnQgYWxsIFwiaHRtbF9rZXlcIiB0byBcImtleVwiIHdpdGggdGhlIHNhbWUgdmFsdWVcblxuICAgICAgdGhpcy5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICgvXmh0bWxfLy50ZXN0KGtleSkpIHtcbiAgICAgICAgICBvcHRpb25zW2NhbWVsQ2FzZShrZXkuc2xpY2UoNSkpXSA9IF90aGlzMi5nZXRWYWx1ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCEodGhpcy5oYXNMYXllcigpIHx8IHRoaXMuZ2V0VmFsdWUoXCJhbmdsZVwiKSB8fCBpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKShbXCJmaXRcIiwgXCJsaW1pdFwiLCBcImxmaWxsXCJdLCB0aGlzLmdldFZhbHVlKFwiY3JvcFwiKSkpKSB7XG4gICAgICAgIHdpZHRoID0gKHJlZjIgPSB0aGlzLmdldChcIndpZHRoXCIpKSAhPSBudWxsID8gcmVmMi5vcmlnVmFsdWUgOiB2b2lkIDA7XG4gICAgICAgIGhlaWdodCA9IChyZWYzID0gdGhpcy5nZXQoXCJoZWlnaHRcIikpICE9IG51bGwgPyByZWYzLm9yaWdWYWx1ZSA6IHZvaWQgMDtcblxuICAgICAgICBpZiAocGFyc2VGbG9hdCh3aWR0aCkgPj0gMS4wKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KGhlaWdodCkgPj0gMS4wKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9IdG1sXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgdG8gdGhlIHBhcmVudCAodXAgdGhlIGNhbGwgY2hhaW4pIHRvIHByb2R1Y2UgSFRNTFxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiN0b0h0bWxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhcmVudCBpZiBwb3NzaWJsZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRhZyA9IGNsb3VkaW5hcnkuSW1hZ2VUYWcubmV3KFwic2FtcGxlXCIsIHtjbG91ZF9uYW1lOiBcImRlbW9cIn0pXG4gICAgICogLy8gSW1hZ2VUYWcge25hbWU6IFwiaW1nXCIsIHB1YmxpY0lkOiBcInNhbXBsZVwifVxuICAgICAqIHRhZy50b0h0bWwoKVxuICAgICAqIC8vIDxpbWcgc3JjPVwiaHR0cDovL3Jlcy5jbG91ZGluYXJ5LmNvbS9kZW1vL2ltYWdlL3VwbG9hZC9zYW1wbGVcIj5cbiAgICAgKiB0YWcudHJhbnNmb3JtYXRpb24oKS5jcm9wKFwiZml0XCIpLndpZHRoKDMwMCkudG9IdG1sKClcbiAgICAgKiAvLyA8aW1nIHNyYz1cImh0dHA6Ly9yZXMuY2xvdWRpbmFyeS5jb20vZGVtby9pbWFnZS91cGxvYWQvY19maXQsd18zMDAvc2FtcGxlXCI+XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IdG1sKCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiAocmVmID0gdGhpcy5nZXRQYXJlbnQoKSkgIT0gbnVsbCA/IHR5cGVvZiByZWYudG9IdG1sID09PSBcImZ1bmN0aW9uXCIgPyByZWYudG9IdG1sKCkgOiB2b2lkIDAgOiB2b2lkIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudG9PcHRpb25zKHRydWUpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJsaXN0TmFtZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdE5hbWVzKCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRQYXJhbU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZFBhcmFtTmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcy5pbmRleE9mKGNhbWVsQ2FzZShuYW1lKSkgPj0gMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhbnNmb3JtYXRpb25CYXNlO1xufSgpO1xuXG52YXIgVkFSX05BTUVfUkUgPSAvXlxcJFthLXpBLVowLTldKyQvO1xudHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlLnByb3RvdHlwZS50cmFuc19zZXBhcmF0b3IgPSAnLyc7XG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UucHJvdG90eXBlLnBhcmFtX3NlcGFyYXRvciA9ICcsJztcblxuZnVuY3Rpb24gbGFzdEFyZ0NhbGxiYWNrKGFyZ3MpIHtcbiAgdmFyIGNhbGxiYWNrO1xuICBjYWxsYmFjayA9IGFyZ3MgIT0gbnVsbCA/IGFyZ3NbYXJncy5sZW5ndGggLSAxXSA6IHZvaWQgMDtcblxuICBpZiAoaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGNhbGxiYWNrKSkge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NWYXIodmFyQXJyYXkpIHtcbiAgdmFyIGosIGxlbiwgbmFtZSwgcmVzdWx0cywgdjtcblxuICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhckFycmF5KSkge1xuICAgIHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAoaiA9IDAsIGxlbiA9IHZhckFycmF5Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgX3ZhckFycmF5JGogPSB0cmFuc2Zvcm1hdGlvbl9zbGljZWRUb0FycmF5KHZhckFycmF5W2pdLCAyKTtcblxuICAgICAgbmFtZSA9IF92YXJBcnJheSRqWzBdO1xuICAgICAgdiA9IF92YXJBcnJheSRqWzFdO1xuICAgICAgcmVzdWx0cy5wdXNoKFwiXCIuY29uY2F0KG5hbWUsIFwiX1wiKS5jb25jYXQoZXhwcmVzc2lvbi5ub3JtYWxpemUodikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFyQXJyYXk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0N1c3RvbUZ1bmN0aW9uKF9yZWYpIHtcbiAgdmFyIGZ1bmN0aW9uX3R5cGUgPSBfcmVmLmZ1bmN0aW9uX3R5cGUsXG4gICAgICBzb3VyY2UgPSBfcmVmLnNvdXJjZTtcblxuICBpZiAoZnVuY3Rpb25fdHlwZSA9PT0gJ3JlbW90ZScpIHtcbiAgICByZXR1cm4gW2Z1bmN0aW9uX3R5cGUsIGJ0b2Eoc291cmNlKV0uam9pbihcIjpcIik7XG4gIH0gZWxzZSBpZiAoZnVuY3Rpb25fdHlwZSA9PT0gJ3dhc20nKSB7XG4gICAgcmV0dXJuIFtmdW5jdGlvbl90eXBlLCBzb3VyY2VdLmpvaW4oXCI6XCIpO1xuICB9XG59XG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIENsYXNzIG1ldGhvZHMuXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiB0aGUgcGFyYW1ldGVycyBkZWZpbmVkIGluIFRyYW5zZm9ybWF0aW9uLlxuICogVmFsdWVzIGFyZSBjYW1lbENhc2VkLlxuICogQGNvbnN0IFRyYW5zZm9ybWF0aW9uLm1ldGhvZHNcbiAqIEBwcml2YXRlXG4gKiBAaWdub3JlXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAqL1xuXG4vKipcbiAqIFBhcmFtZXRlcnMgdGhhdCBhcmUgZmlsdGVyZWQgb3V0IGJlZm9yZSBwYXNzaW5nIHRoZSBvcHRpb25zIHRvIGFuIEhUTUwgdGFnLlxuICpcbiAqIFRoZSBsaXN0IG9mIHBhcmFtZXRlcnMgaXMgYSBjb21iaW5hdGlvbiBvZiBgVHJhbnNmb3JtYXRpb246Om1ldGhvZHNgIGFuZCBgQ29uZmlndXJhdGlvbjo6Q09ORklHX1BBUkFNU2BcbiAqIEBjb25zdCB7QXJyYXk8c3RyaW5nPn0gVHJhbnNmb3JtYXRpb24uUEFSQU1fTkFNRVNcbiAqIEBwcml2YXRlXG4gKiBAaWdub3JlXG4gKiBAc2VlIHRvSHRtbEF0dHJpYnV0ZXNcbiAqL1xuXG5cbnZhciB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RyYW5zZm9ybWF0aW9uQmFzZSkge1xuICB0cmFuc2Zvcm1hdGlvbl9pbmhlcml0cyhUcmFuc2Zvcm1hdGlvbiwgX1RyYW5zZm9ybWF0aW9uQmFzZSk7XG5cbiAgdmFyIF9zdXBlciA9IHRyYW5zZm9ybWF0aW9uX2NyZWF0ZVN1cGVyKFRyYW5zZm9ybWF0aW9uKTtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNpbmdsZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXG4gICAqIEBleGFtcGxlXG4gICAqIHQgPSBuZXcgY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbigpO1xuICAgKiB0LmFuZ2xlKDIwKS5jcm9wKFwic2NhbGVcIikud2lkdGgoXCJhdXRvXCIpO1xuICAgKlxuICAgKiAvLyBvclxuICAgKlxuICAgKiB0ID0gbmV3IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24oIHthbmdsZTogMjAsIGNyb3A6IFwic2NhbGVcIiwgd2lkdGg6IFwiYXV0b1wifSk7XG4gICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIlxuICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgKi9cbiAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24ob3B0aW9ucykge1xuICAgIHRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybWF0aW9uKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7VHJhbnNmb3JtYXRpb259XG4gICAqIEBleGFtcGxlIGNsID0gY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbi5uZXcoIHthbmdsZTogMjAsIGNyb3A6IFwic2NhbGVcIiwgd2lkdGg6IFwiYXV0b1wifSlcbiAgICovXG5cblxuICB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyhUcmFuc2Zvcm1hdGlvbiwgW3tcbiAgICBrZXk6IFwiYW5nbGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKlxuICAgICAgVHJhbnNmb3JtYXRpb24gUGFyYW1ldGVyc1xuICAgICovXG4gICAgZnVuY3Rpb24gYW5nbGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwiYW5nbGVcIiwgXCJhXCIsIFwiLlwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvQ29kZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXVkaW9Db2RlYyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYXVkaW9fY29kZWNcIiwgXCJhY1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXVkaW9GcmVxdWVuY3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXVkaW9GcmVxdWVuY3kodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImF1ZGlvX2ZyZXF1ZW5jeVwiLCBcImFmXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYXNwZWN0X3JhdGlvXCIsIFwiYXJcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhY2tncm91bmQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImJhY2tncm91bmRcIiwgXCJiXCIsIHBhcmFtZXRlcnNfUGFyYW0ubm9ybV9jb2xvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpdFJhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYml0UmF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYml0X3JhdGVcIiwgXCJiclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJvcmRlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYm9yZGVyXCIsIFwiYm9cIiwgZnVuY3Rpb24gKGJvcmRlcikge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKGJvcmRlcikpIHtcbiAgICAgICAgICBib3JkZXIgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHt9LCB7XG4gICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxuICAgICAgICAgICAgd2lkdGg6IDJcbiAgICAgICAgICB9LCBib3JkZXIpO1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChib3JkZXIud2lkdGgsIFwicHhfc29saWRfXCIpLmNvbmNhdChwYXJhbWV0ZXJzX1BhcmFtLm5vcm1fY29sb3IoYm9yZGVyLmNvbG9yKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjb2xvclwiLCBcImNvXCIsIHBhcmFtZXRlcnNfUGFyYW0ubm9ybV9jb2xvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbG9yU3BhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3JTcGFjZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiY29sb3Jfc3BhY2VcIiwgXCJjc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcm9wKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjcm9wXCIsIFwiY1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VzdG9tRnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VzdG9tRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImN1c3RvbV9mdW5jdGlvblwiLCBcImZuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NDdXN0b21GdW5jdGlvbih2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VzdG9tUHJlRnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VzdG9tUHJlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmdldCgnY3VzdG9tX2Z1bmN0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yYXdQYXJhbSh2YWx1ZSwgXCJjdXN0b21fZnVuY3Rpb25cIiwgXCJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWx1ZSA9IHByb2Nlc3NDdXN0b21GdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IFwiZm5fcHJlOlwiLmNvbmNhdCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWZhdWx0SW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdEltYWdlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJkZWZhdWx0X2ltYWdlXCIsIFwiZFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImRlbGF5XCIsIFwiZGxcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbnNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVuc2l0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZGVuc2l0eVwiLCBcImRuXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2VQYXJhbSh2YWx1ZSwgXCJkdXJhdGlvblwiLCBcImR1XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHByKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJkcHJcIiwgXCJkcHJcIiwgZnVuY3Rpb24gKGRwcikge1xuICAgICAgICBkcHIgPSBkcHIudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAoZHByICE9IG51bGwgPyBkcHIubWF0Y2goL15cXGQrJC8pIDogdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGRwciArIFwiLjBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ub3JtYWxpemUoZHByKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVmZmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZmZlY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwiZWZmZWN0XCIsIFwiZVwiLCBcIjpcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbHNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbHNlKCkge1xuICAgICAgcmV0dXJuIHRoaXNbXCJpZlwiXSgnZWxzZScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRJZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRJZigpIHtcbiAgICAgIHJldHVybiB0aGlzW1wiaWZcIl0oJ2VuZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2Zmc2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZVBhcmFtKHZhbHVlLCBcImVuZF9vZmZzZXRcIiwgXCJlb1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmFsbGJhY2tDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhbGxiYWNrQ29udGVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZmFsbGJhY2tfY29udGVudFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2hGb3JtYXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImZldGNoX2Zvcm1hdFwiLCBcImZcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImZvcm1hdFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmxhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmxhZ3ModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwiZmxhZ3NcIiwgXCJmbFwiLCBcIi5cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyYXZpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3Jhdml0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZ3Jhdml0eVwiLCBcImdcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZwc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcHModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImZwc1wiLCBcImZwc1wiLCBmdW5jdGlvbiAoZnBzKSB7XG4gICAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShmcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZwcztcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoZnBzKSkge1xuICAgICAgICAgIHJldHVybiBmcHMuam9pbihcIi1cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZwcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWlnaHQodmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJoZWlnaHRcIiwgXCJoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMy5nZXRWYWx1ZShcImNyb3BcIikgfHwgX3RoaXMzLmdldFZhbHVlKFwib3ZlcmxheVwiKSB8fCBfdGhpczMuZ2V0VmFsdWUoXCJ1bmRlcmxheVwiKSkge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodG1sSGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGh0bWxIZWlnaHQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImh0bWxfaGVpZ2h0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodG1sV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaHRtbFdpZHRoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJodG1sX3dpZHRoXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaWYoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiXCI7XG4gICAgICB2YXIgaSwgaWZWYWwsIGosIHJlZiwgdHJJZiwgdHJSZXN0O1xuXG4gICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJlbHNlXCI6XG4gICAgICAgICAgdGhpcy5jaGFpbigpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImlmXCIsIFwiaWZcIik7XG5cbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHRoaXMuY2hhaW4oKTtcblxuICAgICAgICAgIGZvciAoaSA9IGogPSByZWYgPSB0aGlzLmNoYWluZWQubGVuZ3RoIC0gMTsgaiA+PSAwOyBpID0gaiArPSAtMSkge1xuICAgICAgICAgICAgaWZWYWwgPSB0aGlzLmNoYWluZWRbaV0uZ2V0VmFsdWUoXCJpZlwiKTtcblxuICAgICAgICAgICAgaWYgKGlmVmFsID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZlZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRySWYgPSBUcmFuc2Zvcm1hdGlvbltcIm5ld1wiXSgpW1wiaWZcIl0oaWZWYWwpO1xuICAgICAgICAgICAgICB0aGlzLmNoYWluZWRbaV0ucmVtb3ZlKFwiaWZcIik7XG4gICAgICAgICAgICAgIHRyUmVzdCA9IHRoaXMuY2hhaW5lZFtpXTtcbiAgICAgICAgICAgICAgdGhpcy5jaGFpbmVkW2ldID0gVHJhbnNmb3JtYXRpb25bXCJuZXdcIl0oKS50cmFuc2Zvcm1hdGlvbihbdHJJZiwgdHJSZXN0XSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlmVmFsICE9PSBcImVsc2VcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaWZcIiwgXCJpZlwiKTtcblxuICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbltcIm5ld1wiXSgpLnNldFBhcmVudCh0aGlzKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImlmXCIsIFwiaWZcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uW1wibmV3XCJdKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJrZXlmcmFtZUludGVydmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleWZyYW1lSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImtleWZyYW1lX2ludGVydmFsXCIsIFwia2lcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9jclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvY3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcIm9jclwiLCBcIm9jclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZnNldCh2YWx1ZSkge1xuICAgICAgdmFyIGVuZF9vLCBzdGFydF9vO1xuXG4gICAgICB2YXIgX3JlZjIgPSBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodmFsdWUgIT0gbnVsbCA/IHZhbHVlLnNwbGl0IDogdm9pZCAwKSA/IHZhbHVlLnNwbGl0KCcuLicpIDogaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbHVlKSA/IHZhbHVlIDogW251bGwsIG51bGxdO1xuXG4gICAgICB2YXIgX3JlZjMgPSB0cmFuc2Zvcm1hdGlvbl9zbGljZWRUb0FycmF5KF9yZWYyLCAyKTtcblxuICAgICAgc3RhcnRfbyA9IF9yZWYzWzBdO1xuICAgICAgZW5kX28gPSBfcmVmM1sxXTtcblxuICAgICAgaWYgKHN0YXJ0X28gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXJ0T2Zmc2V0KHN0YXJ0X28pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kX28gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRPZmZzZXQoZW5kX28pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wYWNpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcIm9wYWNpdHlcIiwgXCJvXCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3ZlcmxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdmVybGF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXllclBhcmFtKHZhbHVlLCBcIm92ZXJsYXlcIiwgXCJsXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInBhZ2VcIiwgXCJwZ1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3Rlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwicG9zdGVyXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlZml4KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJwcmVmaXhcIiwgXCJwXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWFsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1YWxpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInF1YWxpdHlcIiwgXCJxXCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFkaXVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhZGl1cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJyYWRpdXNcIiwgXCJyXCIsIFwiOlwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhd1RyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhd1RyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYXdQYXJhbSh2YWx1ZSwgXCJyYXdfdHJhbnNmb3JtYXRpb25cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2l6ZSh2YWx1ZSkge1xuICAgICAgdmFyIGhlaWdodCwgd2lkdGg7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodmFsdWUgIT0gbnVsbCA/IHZhbHVlLnNwbGl0IDogdm9pZCAwKSkge1xuICAgICAgICB2YXIgX3ZhbHVlJHNwbGl0ID0gdmFsdWUuc3BsaXQoJ3gnKTtcblxuICAgICAgICB2YXIgX3ZhbHVlJHNwbGl0MiA9IHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkoX3ZhbHVlJHNwbGl0LCAyKTtcblxuICAgICAgICB3aWR0aCA9IF92YWx1ZSRzcGxpdDJbMF07XG4gICAgICAgIGhlaWdodCA9IF92YWx1ZSRzcGxpdDJbMV07XG4gICAgICAgIHRoaXMud2lkdGgod2lkdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQoaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic291cmNlVHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc291cmNlVHlwZXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInNvdXJjZV90eXBlc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic291cmNlVHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc291cmNlVHJhbnNmb3JtYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInNvdXJjZV90cmFuc2Zvcm1hdGlvblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRPZmZzZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlUGFyYW0odmFsdWUsIFwic3RhcnRfb2Zmc2V0XCIsIFwic29cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0cmVhbWluZ1Byb2ZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtaW5nUHJvZmlsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwic3RyZWFtaW5nX3Byb2ZpbGVcIiwgXCJzcFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uUGFyYW0odmFsdWUsIFwidHJhbnNmb3JtYXRpb25cIiwgXCJ0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmRlcmxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmRlcmxheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5ZXJQYXJhbSh2YWx1ZSwgXCJ1bmRlcmxheVwiLCBcInVcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhcmlhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgbmFtZSwgbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhcmlhYmxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YXJpYWJsZXModmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVBhcmFtKHZhbHVlcywgXCJ2YXJpYWJsZXNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvQ29kZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9Db2RlYyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwidmlkZW9fY29kZWNcIiwgXCJ2Y1wiLCBwYXJhbWV0ZXJzX1BhcmFtLnByb2Nlc3NfdmlkZW9fcGFyYW1zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9TYW1wbGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb1NhbXBsaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ2aWRlb19zYW1wbGluZ1wiLCBcInZzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aCh2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcIndpZHRoXCIsIFwid1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczQuZ2V0VmFsdWUoXCJjcm9wXCIpIHx8IF90aGlzNC5nZXRWYWx1ZShcIm92ZXJsYXlcIikgfHwgX3RoaXM0LmdldFZhbHVlKFwidW5kZXJsYXlcIikpIHtcbiAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ub3JtYWxpemUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB4KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ4XCIsIFwieFwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwieVwiLCBcInlcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ6b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb20odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInpvb21cIiwgXCJ6XCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJuZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25ldyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2Zvcm1hdGlvbjtcbn0odHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlKTtcbi8qKlxuICogVHJhbnNmb3JtYXRpb24gQ2xhc3MgbWV0aG9kcy5cbiAqIFRoaXMgaXMgYSBsaXN0IG9mIHRoZSBwYXJhbWV0ZXJzIGRlZmluZWQgaW4gVHJhbnNmb3JtYXRpb24uXG4gKiBWYWx1ZXMgYXJlIGNhbWVsQ2FzZWQuXG4gKi9cblxuXG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzID0gW1wiYW5nbGVcIiwgXCJhdWRpb0NvZGVjXCIsIFwiYXVkaW9GcmVxdWVuY3lcIiwgXCJhc3BlY3RSYXRpb1wiLCBcImJhY2tncm91bmRcIiwgXCJiaXRSYXRlXCIsIFwiYm9yZGVyXCIsIFwiY29sb3JcIiwgXCJjb2xvclNwYWNlXCIsIFwiY3JvcFwiLCBcImN1c3RvbUZ1bmN0aW9uXCIsIFwiY3VzdG9tUHJlRnVuY3Rpb25cIiwgXCJkZWZhdWx0SW1hZ2VcIiwgXCJkZWxheVwiLCBcImRlbnNpdHlcIiwgXCJkdXJhdGlvblwiLCBcImRwclwiLCBcImVmZmVjdFwiLCBcImVsc2VcIiwgXCJlbmRJZlwiLCBcImVuZE9mZnNldFwiLCBcImZhbGxiYWNrQ29udGVudFwiLCBcImZldGNoRm9ybWF0XCIsIFwiZm9ybWF0XCIsIFwiZmxhZ3NcIiwgXCJncmF2aXR5XCIsIFwiZnBzXCIsIFwiaGVpZ2h0XCIsIFwiaHRtbEhlaWdodFwiLCBcImh0bWxXaWR0aFwiLCBcImlmXCIsIFwia2V5ZnJhbWVJbnRlcnZhbFwiLCBcIm9jclwiLCBcIm9mZnNldFwiLCBcIm9wYWNpdHlcIiwgXCJvdmVybGF5XCIsIFwicGFnZVwiLCBcInBvc3RlclwiLCBcInByZWZpeFwiLCBcInF1YWxpdHlcIiwgXCJyYWRpdXNcIiwgXCJyYXdUcmFuc2Zvcm1hdGlvblwiLCBcInNpemVcIiwgXCJzb3VyY2VUeXBlc1wiLCBcInNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsIFwic3RhcnRPZmZzZXRcIiwgXCJzdHJlYW1pbmdQcm9maWxlXCIsIFwidHJhbnNmb3JtYXRpb25cIiwgXCJ1bmRlcmxheVwiLCBcInZhcmlhYmxlXCIsIFwidmFyaWFibGVzXCIsIFwidmlkZW9Db2RlY1wiLCBcInZpZGVvU2FtcGxpbmdcIiwgXCJ3aWR0aFwiLCBcInhcIiwgXCJ5XCIsIFwiem9vbVwiXTtcbi8qKlxuICogUGFyYW1ldGVycyB0aGF0IGFyZSBmaWx0ZXJlZCBvdXQgYmVmb3JlIHBhc3NpbmcgdGhlIG9wdGlvbnMgdG8gYW4gSFRNTCB0YWcuXG4gKlxuICogVGhlIGxpc3Qgb2YgcGFyYW1ldGVycyBpcyBhIGNvbWJpbmF0aW9uIG9mIGBUcmFuc2Zvcm1hdGlvbjo6bWV0aG9kc2AgYW5kIGBDb25maWd1cmF0aW9uOjpDT05GSUdfUEFSQU1TYFxuICovXG5cbnRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLlBBUkFNX05BTUVTID0gdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcy5tYXAoc25ha2VDYXNlKS5jb25jYXQoc3JjX2NvbmZpZ3VyYXRpb24uQ09ORklHX1BBUkFNUyk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfdHJhbnNmb3JtYXRpb24gPSAodHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9odG1sdGFnLmpzXG5mdW5jdGlvbiBodG1sdGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gaHRtbHRhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gaHRtbHRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBHZW5lcmljIEhUTUwgdGFnXG4gKiBEZXBlbmRzIG9uICd0cmFuc2Zvcm1hdGlvbicsICd1dGlsJ1xuICovXG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEhUTUwgKERPTSkgdGFnXG4gKiBAY29uc3RydWN0b3IgSHRtbFRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBleGFtcGxlIHRhZyA9IG5ldyBIdG1sVGFnKCAnZGl2JywgeyAnd2lkdGgnOiAxMH0pXG4gKi9cblxudmFyIGh0bWx0YWdfSHRtbFRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEh0bWxUYWcobmFtZSwgcHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICBodG1sdGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEh0bWxUYWcpO1xuXG4gICAgdmFyIHRyYW5zZm9ybWF0aW9uO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wdWJsaWNJZCA9IHB1YmxpY0lkO1xuXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShwdWJsaWNJZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHB1YmxpY0lkO1xuICAgICAgICB0aGlzLnB1YmxpY0lkID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYW5zZm9ybWF0aW9uID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihvcHRpb25zKTtcbiAgICB0cmFuc2Zvcm1hdGlvbi5zZXRQYXJlbnQodGhpcyk7XG5cbiAgICB0aGlzLnRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGNvbnN0cnVjdG9yXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gSFRNTCAoRE9NKSB0YWdcbiAgICogQGZ1bmN0aW9uIEh0bWxUYWcubmV3XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHRhZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtIdG1sVGFnfVxuICAgKiBAZXhhbXBsZSB0YWcgPSBIdG1sVGFnLm5ldyggJ2RpdicsIHsgJ3dpZHRoJzogMTB9KVxuICAgKi9cblxuXG4gIGh0bWx0YWdfY3JlYXRlQ2xhc3MoSHRtbFRhZywgW3tcbiAgICBrZXk6IFwiaHRtbEF0dHJzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogY29tYmluZSBrZXkgYW5kIHZhbHVlIGZyb20gdGhlIGBhdHRyYCB0byBnZW5lcmF0ZSBhbiBIVE1MIHRhZyBhdHRyaWJ1dGVzIHN0cmluZy5cbiAgICAgKiBgVHJhbnNmb3JtYXRpb246OnRvSHRtbFRhZ09wdGlvbnNgIGlzIHVzZWQgdG8gZmlsdGVyIG91dCB0cmFuc2Zvcm1hdGlvbiBhbmQgY29uZmlndXJhdGlvbiBrZXlzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cnNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBhdHRyaWJ1dGVzIGluIHRoZSBmb3JtYXQgYCdrZXkxPVwidmFsdWUxXCIga2V5Mj1cInZhbHVlMlwiJ2BcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaHRtbEF0dHJzKGF0dHJzKSB7XG4gICAgICB2YXIga2V5LCBwYWlycywgdmFsdWU7XG4gICAgICByZXR1cm4gcGFpcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHRzO1xuICAgICAgICByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICB2YWx1ZSA9IGVzY2FwZVF1b3RlcyhhdHRyc1trZXldKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGh0bWx0YWdfdG9BdHRyaWJ1dGUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSgpLnNvcnQoKS5qb2luKCcgJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgb3B0aW9ucyByZWxhdGVkIHRvIHRoaXMgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2dldE9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgb3B0aW9uc1xuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbigpLnRvT3B0aW9ucygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIG9wdGlvbiBgbmFtZWBcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNnZXRPcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvblxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcHRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZ2V0VmFsdWUobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2F0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICAvLyBUaGUgYXR0cmlidXRlcyBhcmUgYmUgY29tcHV0ZWQgZnJvbSB0aGUgb3B0aW9ucyBldmVyeSB0aW1lIHRoaXMgbWV0aG9kIGlzIGludm9rZWQuXG4gICAgICB2YXIgaHRtbEF0dHJpYnV0ZXMgPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkudG9IdG1sQXR0cmlidXRlcygpO1xuICAgICAgT2JqZWN0LmtleXMoaHRtbEF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKGh0bWxBdHRyaWJ1dGVzW2tleV0pKSB7XG4gICAgICAgICAgZGVsZXRlIGh0bWxBdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaHRtbEF0dHJpYnV0ZXMuYXR0cmlidXRlcykge1xuICAgICAgICAvLyBDdXJyZW50bHkgSFRNTCBhdHRyaWJ1dGVzIGFyZSBkZWZpbmVkIGJvdGggYXQgdGhlIHRvcCBsZXZlbCBhbmQgdW5kZXIgJ2F0dHJpYnV0ZXMnXG4gICAgICAgIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKGh0bWxBdHRyaWJ1dGVzLCBodG1sQXR0cmlidXRlcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgZGVsZXRlIGh0bWxBdHRyaWJ1dGVzLmF0dHJpYnV0ZXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBodG1sQXR0cmlidXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgdGFnIGF0dHJpYnV0ZSBuYW1lZCBgbmFtZWAgdG8gYHZhbHVlYFxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI3NldEF0dHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuc2V0KFwiaHRtbF9cIi5jb25jYXQobmFtZSksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSB0YWcgYXR0cmlidXRlIGBuYW1lYFxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2dldEF0dHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEF0dHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXR0cihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzKClbXCJodG1sX1wiLmNvbmNhdChuYW1lKV0gfHwgdGhpcy5hdHRyaWJ1dGVzKClbbmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgdGFnIGF0dHJpYnV0ZWQgbmFtZWQgYG5hbWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjcmVtb3ZlQXR0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdHRyKG5hbWUpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICByZXR1cm4gKHJlZiA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5yZW1vdmUoXCJodG1sX1wiLmNvbmNhdChuYW1lKSkpICE9IG51bGwgPyByZWYgOiB0aGlzLnRyYW5zZm9ybWF0aW9uKCkucmVtb3ZlKG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNjb250ZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNvcGVuVGFnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5UYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlblRhZygpIHtcbiAgICAgIHZhciB0YWcgPSBcIjxcIiArIHRoaXMubmFtZTtcbiAgICAgIHZhciBodG1sQXR0cnMgPSB0aGlzLmh0bWxBdHRycyh0aGlzLmF0dHJpYnV0ZXMoKSk7XG5cbiAgICAgIGlmIChodG1sQXR0cnMgJiYgaHRtbEF0dHJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGFnICs9IFwiIFwiICsgaHRtbEF0dHJzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFnICsgXCI+XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2Nsb3NlVGFnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiPC9cIi5jb25jYXQodGhpcy5uYW1lLCBcIj5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0YWcuXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjdG9IdG1sXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBIVE1MIGluIHN0cmluZyBmb3JtYXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvSHRtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0h0bWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGVuVGFnKCkgKyB0aGlzLmNvbnRlbnQoKSArIHRoaXMuY2xvc2VUYWcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERPTSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0YWcuXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjdG9ET01cbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgICAgdmFyIGVsZW1lbnQsIG5hbWUsIHJlZiwgdmFsdWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudCAhPT0gbnVsbCA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgOiB2b2lkIDApKSB7XG4gICAgICAgIHRocm93IFwiQ2FuJ3QgY3JlYXRlIERPTSBpZiBkb2N1bWVudCBpcyBub3QgcHJlc2VudCFcIjtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5uYW1lKTtcbiAgICAgIHJlZiA9IHRoaXMuYXR0cmlidXRlcygpO1xuXG4gICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgIHZhbHVlID0gcmVmW25hbWVdO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5ld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KG5hbWUsIHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMobmFtZSwgcHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1Jlc3BvbnNpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZXNwb25zaXZlKHRhZywgcmVzcG9uc2l2ZUNsYXNzKSB7XG4gICAgICB2YXIgZGF0YVNyYztcbiAgICAgIGRhdGFTcmMgPSBsb2Rhc2hfZ2V0RGF0YSh0YWcsICdzcmMtY2FjaGUnKSB8fCBsb2Rhc2hfZ2V0RGF0YSh0YWcsICdzcmMnKTtcbiAgICAgIHJldHVybiBsb2Rhc2hfaGFzQ2xhc3ModGFnLCByZXNwb25zaXZlQ2xhc3MpICYmIC9cXGJ3X2F1dG9cXGIvLmV4ZWMoZGF0YVNyYyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEh0bWxUYWc7XG59KCk7XG5cbjtcbi8qKlxuICogUmVwcmVzZW50IHRoZSBnaXZlbiBrZXkgYW5kIHZhbHVlIGFzIGFuIEhUTUwgYXR0cmlidXRlLlxuICogQGZ1bmN0aW9uIHRvQXR0cmlidXRlXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gYXR0cmlidXRlIG5hbWVcbiAqIEBwYXJhbSB7Knxib29sZWFufSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLiBJZiB0aGUgdmFsdWUgaXMgYm9vbGVhbiBgdHJ1ZWAsIHJldHVybiB0aGUga2V5IG9ubHkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYXR0cmlidXRlXG4gKlxuICovXG5cbmZ1bmN0aW9uIGh0bWx0YWdfdG9BdHRyaWJ1dGUoa2V5LCB2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBrZXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCI9XFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIlwiKTtcbiAgfVxufVxuLyoqXG4gKiBJZiBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZywgcmVwbGFjZXMgcXVvdGVzIHdpdGggY2hhcmFjdGVyIGVudGl0aWVzICgmIzM0OywgJiMzOTspXG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBjaGFuZ2VcbiAqIEByZXR1cm5zIHsqfSBjaGFuZ2VkIHZhbHVlXG4gKi9cblxuXG5mdW5jdGlvbiBlc2NhcGVRdW90ZXModmFsdWUpIHtcbiAgcmV0dXJuIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UoJ1wiJywgJyYjMzQ7JykucmVwbGFjZShcIidcIiwgJyYjMzk7JykgOiB2YWx1ZTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHRtbHRhZyA9IChodG1sdGFnX0h0bWxUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXJsLmpzXG52YXIgX2V4Y2x1ZGVkID0gW1wicGxhY2Vob2xkZXJcIiwgXCJhY2Nlc3NpYmlsaXR5XCJdO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG4vKipcbiAqIEFkZHMgcHJvdG9jb2wsIGhvc3QsIHBhdGhuYW1lIHByZWZpeGVzIHRvIGdpdmVuIHN0cmluZ1xuICogQHBhcmFtIHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVXJsKHN0cikge1xuICB2YXIgcHJlZml4ID0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgZG9jdW1lbnQubG9jYXRpb24uaG9zdDtcblxuICBpZiAoc3RyWzBdID09PSAnPycpIHtcbiAgICBwcmVmaXggKz0gZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoc3RyWzBdICE9PSAnLycpIHtcbiAgICBwcmVmaXggKz0gZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCAnLycpO1xuICB9XG5cbiAgcmV0dXJuIHByZWZpeCArIHN0cjtcbn1cbi8qKlxuICogQ2hlY2sgaXMgZ2l2ZW4gc3RyaW5nIGlzIGEgdXJsXG4gKiBAcGFyYW0gc3RyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVXJsKHN0cikge1xuICByZXR1cm4gc3RyID8gISFzdHIubWF0Y2goL15odHRwcz86XFwvLykgOiBmYWxzZTtcbn0gLy8gUHJvZHVjZSBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDUgdG8gYmUgdXNlZCBmb3IgY2RuIHN1YiBkb21haW5zIGRlc2lnbmF0aW9uXG5cblxuZnVuY3Rpb24gY2RuU3ViZG9tYWluTnVtYmVyKHB1YmxpY0lkKSB7XG4gIHJldHVybiBzcmNfY3JjMzIocHVibGljSWQpICUgNSArIDE7XG59XG4vKipcbiAqIFJlbW92ZXMgc2lnbmF0dXJlIGZyb20gb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgc2lnbmF0dXJlXG4gKiBNYWtlcyBzdXJlIHNpZ25hdHVyZSBpcyBlbXB0eSBvciBvZiB0aGlzIGZvcm1hdDogcy0tc2lnbmF0dXJlLS1cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZm9ybWF0dGVkIHNpZ25hdHVyZVxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlU2lnbmF0dXJlKG9wdGlvbnMpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IG9wdGlvbnMuc2lnbmF0dXJlO1xuICB2YXIgaXNGb3JtYXR0ZWQgPSAhc2lnbmF0dXJlIHx8IHNpZ25hdHVyZS5pbmRleE9mKCdzLS0nKSA9PT0gMCAmJiBzaWduYXR1cmUuc3Vic3RyKC0yKSA9PT0gJy0tJztcbiAgZGVsZXRlIG9wdGlvbnMuc2lnbmF0dXJlO1xuICByZXR1cm4gaXNGb3JtYXR0ZWQgPyBzaWduYXR1cmUgOiBcInMtLVwiLmNvbmNhdChzaWduYXR1cmUsIFwiLS1cIik7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgVVJMIHByZWZpeCBmb3IgQ2xvdWRpbmFyeSByZXNvdXJjZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgdGhlIHJlc291cmNlIHB1YmxpYyBJRFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgYWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jbG91ZF9uYW1lIC0gdGhlIGNsb3VkIG5hbWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNkbl9zdWJkb21haW49ZmFsc2VdIC0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IGJ1aWxkIFVSTHMgd2l0aFxuICogIG11bHRpcGxlIENETiBzdWItZG9tYWlucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcml2YXRlX2Nkbl0gLSBCb29sZWFuIChkZWZhdWx0OiBmYWxzZSkuIFNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBmb3IgQWR2YW5jZWQgcGxhbidzIHVzZXJzXG4gKiAgdGhhdCBoYXZlIGEgcHJpdmF0ZSBDRE4gZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3RvY29sPVwiaHR0cDovL1wiXSAtIHRoZSBVUkkgcHJvdG9jb2wgdG8gdXNlLiBJZiBvcHRpb25zLnNlY3VyZSBpcyB0cnVlLFxuICogIHRoZSB2YWx1ZSBpcyBvdmVycmlkZGVuIHRvIFwiaHR0cHM6Ly9cIlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb25dIC0gVGhlIGRvbWFpbiBuYW1lIG9mIHRoZSBDRE4gZGlzdHJpYnV0aW9uIHRvIHVzZSBmb3IgYnVpbGRpbmcgSFRUUFMgVVJMcy5cbiAqICBSZWxldmFudCBvbmx5IGZvciBBZHZhbmNlZCBwbGFuJ3MgdXNlcnMgdGhhdCBoYXZlIGEgcHJpdmF0ZSBDRE4gZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNuYW1lXSAtIEN1c3RvbSBkb21haW4gbmFtZSB0byB1c2UgZm9yIGJ1aWxkaW5nIEhUVFAgVVJMcy5cbiAqICBSZWxldmFudCBvbmx5IGZvciBBZHZhbmNlZCBwbGFuJ3MgdXNlcnMgdGhhdCBoYXZlIGEgcHJpdmF0ZSBDRE4gZGlzdHJpYnV0aW9uIGFuZCBhIGN1c3RvbSBDTkFNRS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nkbl9zdWJkb21haW49dHJ1ZV0gLSBXaGVuIG9wdGlvbnMuc2VjdXJlIGlzIHRydWUgYW5kIHRoaXMgcGFyYW1ldGVyIGlzIGZhbHNlLFxuICogIHRoZSBzdWJkb21haW4gaXMgc2V0IHRvIFwicmVzXCIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZT1mYWxzZV0gLSBGb3JjZSBIVFRQUyBVUkxzIG9mIGltYWdlcyBldmVuIGlmIGVtYmVkZGVkIGluIG5vbi1zZWN1cmUgSFRUUCBwYWdlcy5cbiAqICBXaGVuIHRoaXMgdmFsdWUgaXMgdHJ1ZSwgb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uIHdpbGwgYmUgdXNlZCBhcyBob3N0IGlmIHByb3ZpZGVkLCBhbmQgb3B0aW9ucy5wcm90b2NvbCBpcyBzZXRcbiAqICB0byBcImh0dHBzOi8vXCIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgVVJMIHByZWZpeCBmb3IgdGhlIHJlc291cmNlLlxuICogQHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbmRsZVByZWZpeChwdWJsaWNJZCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5jbG91ZF9uYW1lICYmIG9wdGlvbnMuY2xvdWRfbmFtZVswXSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuICcvcmVzJyArIG9wdGlvbnMuY2xvdWRfbmFtZTtcbiAgfSAvLyBkZWZhdWx0c1xuXG5cbiAgdmFyIHByb3RvY29sID0gXCJodHRwOi8vXCI7XG4gIHZhciBjZG5QYXJ0ID0gXCJcIjtcbiAgdmFyIHN1YmRvbWFpbiA9IFwicmVzXCI7XG4gIHZhciBob3N0ID0gXCIuY2xvdWRpbmFyeS5jb21cIjtcbiAgdmFyIHBhdGggPSBcIi9cIiArIG9wdGlvbnMuY2xvdWRfbmFtZTsgLy8gbW9kaWZpY2F0aW9uc1xuXG4gIGlmIChvcHRpb25zLnByb3RvY29sKSB7XG4gICAgcHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sICsgJy8vJztcbiAgfVxuXG4gIGlmIChvcHRpb25zLnByaXZhdGVfY2RuKSB7XG4gICAgY2RuUGFydCA9IG9wdGlvbnMuY2xvdWRfbmFtZSArIFwiLVwiO1xuICAgIHBhdGggPSBcIlwiO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuY2RuX3N1YmRvbWFpbikge1xuICAgIHN1YmRvbWFpbiA9IFwicmVzLVwiICsgY2RuU3ViZG9tYWluTnVtYmVyKHB1YmxpY0lkKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnNlY3VyZSkge1xuICAgIHByb3RvY29sID0gXCJodHRwczovL1wiO1xuXG4gICAgaWYgKG9wdGlvbnMuc2VjdXJlX2Nkbl9zdWJkb21haW4gPT09IGZhbHNlKSB7XG4gICAgICBzdWJkb21haW4gPSBcInJlc1wiO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gIT0gbnVsbCAmJiBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gIT09IE9MRF9BS0FNQUlfU0hBUkVEX0NETiAmJiBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gIT09IFNIQVJFRF9DRE4pIHtcbiAgICAgIGNkblBhcnQgPSBcIlwiO1xuICAgICAgc3ViZG9tYWluID0gXCJcIjtcbiAgICAgIGhvc3QgPSBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb247XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMuY25hbWUpIHtcbiAgICBwcm90b2NvbCA9IFwiaHR0cDovL1wiO1xuICAgIGNkblBhcnQgPSBcIlwiO1xuICAgIHN1YmRvbWFpbiA9IG9wdGlvbnMuY2RuX3N1YmRvbWFpbiA/ICdhJyArIChzcmNfY3JjMzIocHVibGljSWQpICUgNSArIDEpICsgJy4nIDogJyc7XG4gICAgaG9zdCA9IG9wdGlvbnMuY25hbWU7XG4gIH1cblxuICByZXR1cm4gW3Byb3RvY29sLCBjZG5QYXJ0LCBzdWJkb21haW4sIGhvc3QsIHBhdGhdLmpvaW4oXCJcIik7XG59XG4vKipcbiAqIFJldHVybiB0aGUgcmVzb3VyY2UgdHlwZSBhbmQgYWN0aW9uIHR5cGUgYmFzZWQgb24gdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb25cbiAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2hhbmRsZVJlc291cmNlVHlwZVxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSByZXNvdXJjZV90eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9J3VwbG9hZCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VybF9zdWZmaXhdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2Vfcm9vdF9wYXRoXVxuICogQHBhcmFtIHtib29sZWFufSBbc2hvcnRlbl1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJlc291cmNlX3R5cGUvdHlwZVxuICogQGlnbm9yZVxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlUmVzb3VyY2VUeXBlKF9yZWYpIHtcbiAgdmFyIF9yZWYkcmVzb3VyY2VfdHlwZSA9IF9yZWYucmVzb3VyY2VfdHlwZSxcbiAgICAgIHJlc291cmNlX3R5cGUgPSBfcmVmJHJlc291cmNlX3R5cGUgPT09IHZvaWQgMCA/IFwiaW1hZ2VcIiA6IF9yZWYkcmVzb3VyY2VfdHlwZSxcbiAgICAgIF9yZWYkdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgIHR5cGUgPSBfcmVmJHR5cGUgPT09IHZvaWQgMCA/IFwidXBsb2FkXCIgOiBfcmVmJHR5cGUsXG4gICAgICB1cmxfc3VmZml4ID0gX3JlZi51cmxfc3VmZml4LFxuICAgICAgdXNlX3Jvb3RfcGF0aCA9IF9yZWYudXNlX3Jvb3RfcGF0aCxcbiAgICAgIHNob3J0ZW4gPSBfcmVmLnNob3J0ZW47XG4gIHZhciBvcHRpb25zLFxuICAgICAgcmVzb3VyY2VUeXBlID0gcmVzb3VyY2VfdHlwZTtcblxuICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHJlc291cmNlVHlwZSkpIHtcbiAgICBvcHRpb25zID0gcmVzb3VyY2VUeXBlO1xuICAgIHJlc291cmNlVHlwZSA9IG9wdGlvbnMucmVzb3VyY2VfdHlwZTtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIHNob3J0ZW4gPSBvcHRpb25zLnNob3J0ZW47XG4gIH1cblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgdHlwZSA9ICd1cGxvYWQnO1xuICB9XG5cbiAgaWYgKHVybF9zdWZmaXggIT0gbnVsbCkge1xuICAgIHJlc291cmNlVHlwZSA9IFNFT19UWVBFU1tcIlwiLmNvbmNhdChyZXNvdXJjZVR5cGUsIFwiL1wiKS5jb25jYXQodHlwZSldO1xuICAgIHR5cGUgPSBudWxsO1xuXG4gICAgaWYgKHJlc291cmNlVHlwZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgU3VmZml4IG9ubHkgc3VwcG9ydGVkIGZvciBcIi5jb25jYXQoT2JqZWN0LmtleXMoU0VPX1RZUEVTKS5qb2luKCcsICcpKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHVzZV9yb290X3BhdGgpIHtcbiAgICBpZiAocmVzb3VyY2VUeXBlID09PSAnaW1hZ2UnICYmIHR5cGUgPT09ICd1cGxvYWQnIHx8IHJlc291cmNlVHlwZSA9PT0gXCJpbWFnZXNcIikge1xuICAgICAgcmVzb3VyY2VUeXBlID0gbnVsbDtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IHBhdGggb25seSBzdXBwb3J0ZWQgZm9yIGltYWdlL3VwbG9hZFwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2hvcnRlbiAmJiByZXNvdXJjZVR5cGUgPT09ICdpbWFnZScgJiYgdHlwZSA9PT0gJ3VwbG9hZCcpIHtcbiAgICByZXNvdXJjZVR5cGUgPSAnaXUnO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFtyZXNvdXJjZVR5cGUsIHR5cGVdLmpvaW4oXCIvXCIpO1xufVxuLyoqXG4gKiBFbmNvZGUgcHVibGljSWRcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHJldHVybnMge3N0cmluZ30gZW5jb2RlZCBwdWJsaWNJZFxuICovXG5cblxuZnVuY3Rpb24gZW5jb2RlUHVibGljSWQocHVibGljSWQpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChwdWJsaWNJZCkucmVwbGFjZSgvJTNBL2csICc6JykucmVwbGFjZSgvJTJGL2csICcvJyk7XG59XG4vKipcbiAqIEVuY29kZSBhbmQgZm9ybWF0IHB1YmxpY0lkXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBwdWJsaWNJZFxuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0UHVibGljSWQocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgaWYgKGlzVXJsKHB1YmxpY0lkKSkge1xuICAgIHB1YmxpY0lkID0gZW5jb2RlUHVibGljSWQocHVibGljSWQpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICAvLyBNYWtlIHN1cmUgcHVibGljSWQgaXMgVVJJIGVuY29kZWQuXG4gICAgICBwdWJsaWNJZCA9IGRlY29kZVVSSUNvbXBvbmVudChwdWJsaWNJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgICBwdWJsaWNJZCA9IGVuY29kZVB1YmxpY0lkKHB1YmxpY0lkKTtcblxuICAgIGlmIChvcHRpb25zLnVybF9zdWZmaXgpIHtcbiAgICAgIHB1YmxpY0lkID0gcHVibGljSWQgKyAnLycgKyBvcHRpb25zLnVybF9zdWZmaXg7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICBpZiAoIW9wdGlvbnMudHJ1c3RfcHVibGljX2lkKSB7XG4gICAgICAgIHB1YmxpY0lkID0gcHVibGljSWQucmVwbGFjZSgvXFwuKGpwZ3xwbmd8Z2lmfHdlYnApJC8sICcnKTtcbiAgICAgIH1cblxuICAgICAgcHVibGljSWQgPSBwdWJsaWNJZCArICcuJyArIG9wdGlvbnMuZm9ybWF0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwdWJsaWNJZDtcbn1cbi8qKlxuICogR2V0IGFueSBlcnJvciB3aXRoIHVybCBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gaWYgZXJyb3IsIG90aGVyd2lzZSByZXR1cm4gdW5kZWZpbmVkXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG4gIHZhciBjbG91ZF9uYW1lID0gb3B0aW9ucy5jbG91ZF9uYW1lLFxuICAgICAgdXJsX3N1ZmZpeCA9IG9wdGlvbnMudXJsX3N1ZmZpeDtcblxuICBpZiAoIWNsb3VkX25hbWUpIHtcbiAgICByZXR1cm4gJ1Vua25vd24gY2xvdWRfbmFtZSc7XG4gIH1cblxuICBpZiAodXJsX3N1ZmZpeCAmJiB1cmxfc3VmZml4Lm1hdGNoKC9bXFwuXFwvXS8pKSB7XG4gICAgcmV0dXJuICd1cmxfc3VmZml4IHNob3VsZCBub3QgaW5jbHVkZSAuIG9yIC8nO1xuICB9XG59XG4vKipcbiAqIEdldCB2ZXJzaW9uIHBhcnQgb2YgdGhlIHVybFxuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbmRsZVZlcnNpb24ocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgLy8gZm9yY2VfdmVyc2lvbiBwYXJhbSBtZWFucyB0byBtYWtlIHN1cmUgdGhlcmUgaXMgYSB2ZXJzaW9uIGluIHRoZSB1cmwgKERlZmF1bHQgaXMgdHJ1ZSlcbiAgdmFyIGlzRm9yY2VWZXJzaW9uID0gb3B0aW9ucy5mb3JjZV92ZXJzaW9uIHx8IHR5cGVvZiBvcHRpb25zLmZvcmNlX3ZlcnNpb24gPT09ICd1bmRlZmluZWQnOyAvLyBJcyB2ZXJzaW9uIGluY2x1ZGVkIGluIHB1YmxpY0lkIG9yIGluIG9wdGlvbnMsIG9yIHB1YmxpY0lkIGlzIGEgdXJsIChkb2Vzbid0IG5lZWQgdmVyc2lvbilcblxuICB2YXIgaXNWZXJzaW9uRXhpc3QgPSBwdWJsaWNJZC5pbmRleE9mKCcvJykgPCAwIHx8IHB1YmxpY0lkLm1hdGNoKC9edlswLTldKy8pIHx8IGlzVXJsKHB1YmxpY0lkKSB8fCBvcHRpb25zLnZlcnNpb247XG5cbiAgaWYgKGlzRm9yY2VWZXJzaW9uICYmICFpc1ZlcnNpb25FeGlzdCkge1xuICAgIG9wdGlvbnMudmVyc2lvbiA9IDE7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucy52ZXJzaW9uID8gXCJ2XCIuY29uY2F0KG9wdGlvbnMudmVyc2lvbikgOiAnJztcbn1cbi8qKlxuICogR2V0IGZpbmFsIHRyYW5zZm9ybWF0aW9uIGNvbXBvbmVudCBmb3IgdXJsIHN0cmluZ1xuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVUcmFuc2Zvcm1hdGlvbihvcHRpb25zKSB7XG4gIHZhciBfcmVmMiA9IG9wdGlvbnMgfHwge30sXG4gICAgICBwbGFjZWhvbGRlciA9IF9yZWYyLnBsYWNlaG9sZGVyLFxuICAgICAgYWNjZXNzaWJpbGl0eSA9IF9yZWYyLmFjY2Vzc2liaWxpdHksXG4gICAgICBvdGhlck9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIF9leGNsdWRlZCk7XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24ob3RoZXJPcHRpb25zKTsgLy8gQXBwZW5kIGFjY2Vzc2liaWxpdHkgdHJhbnNmb3JtYXRpb25zXG5cbiAgaWYgKGFjY2Vzc2liaWxpdHkgJiYgQUNDRVNTSUJJTElUWV9NT0RFU1thY2Nlc3NpYmlsaXR5XSkge1xuICAgIHJlc3VsdC5jaGFpbigpLmVmZmVjdChBQ0NFU1NJQklMSVRZX01PREVTW2FjY2Vzc2liaWxpdHldKTtcbiAgfSAvLyBBcHBlbmQgcGxhY2Vob2xkZXIgdHJhbnNmb3JtYXRpb25zXG5cblxuICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICBpZiAocGxhY2Vob2xkZXIgPT09IFwicHJlZG9taW5hbnQtY29sb3JcIiAmJiByZXN1bHQuZ2V0VmFsdWUoJ3dpZHRoJykgJiYgcmVzdWx0LmdldFZhbHVlKCdoZWlnaHQnKSkge1xuICAgICAgcGxhY2Vob2xkZXIgKz0gJy1waXhlbCc7XG4gICAgfVxuXG4gICAgdmFyIHBsYWNlaG9sZGVyVHJhbnNmb3JtYXRpb25zID0gUExBQ0VIT0xERVJfSU1BR0VfTU9ERVNbcGxhY2Vob2xkZXJdIHx8IFBMQUNFSE9MREVSX0lNQUdFX01PREVTLmJsdXI7XG4gICAgcGxhY2Vob2xkZXJUcmFuc2Zvcm1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jaGFpbigpLnRyYW5zZm9ybWF0aW9uKHQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5zZXJpYWxpemUoKTtcbn1cbi8qKlxuICogSWYgdHlwZSBpcyAnZmV0Y2gnLCB1cGRhdGUgcHVibGljSWQgdG8gYmUgYSB1cmxcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlUHVibGljSWQocHVibGljSWQsIF9yZWYzKSB7XG4gIHZhciB0eXBlID0gX3JlZjMudHlwZTtcbiAgcmV0dXJuICFpc1VybChwdWJsaWNJZCkgJiYgdHlwZSA9PT0gJ2ZldGNoJyA/IG1ha2VVcmwocHVibGljSWQpIDogcHVibGljSWQ7XG59XG4vKipcbiAqIEdlbmVyYXRlIHVybCBzdHJpbmdcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGZpbmFsIHVybFxuICovXG5cblxuZnVuY3Rpb24gdXJsU3RyaW5nKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gIGlmIChpc1VybChwdWJsaWNJZCkgJiYgKG9wdGlvbnMudHlwZSA9PT0gJ3VwbG9hZCcgfHwgb3B0aW9ucy50eXBlID09PSAnYXNzZXQnKSkge1xuICAgIHJldHVybiBwdWJsaWNJZDtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gaGFuZGxlVmVyc2lvbihwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHZhciB0cmFuc2Zvcm1hdGlvblN0cmluZyA9IGhhbmRsZVRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICB2YXIgcHJlZml4ID0gaGFuZGxlUHJlZml4KHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgdmFyIHNpZ25hdHVyZSA9IGhhbmRsZVNpZ25hdHVyZShvcHRpb25zKTtcbiAgdmFyIHJlc291cmNlVHlwZSA9IGhhbmRsZVJlc291cmNlVHlwZShvcHRpb25zKTtcbiAgcHVibGljSWQgPSBmb3JtYXRQdWJsaWNJZChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoW3ByZWZpeCwgcmVzb3VyY2VUeXBlLCBzaWduYXR1cmUsIHRyYW5zZm9ybWF0aW9uU3RyaW5nLCB2ZXJzaW9uLCBwdWJsaWNJZF0pLmpvaW4oJy8nKS5yZXBsYWNlKC8oW146XSlcXC8rL2csICckMS8nKSAvLyByZXBsYWNlICcvLy8nIHdpdGggJy8vJ1xuICAucmVwbGFjZSgnICcsICclMjAnKTtcbn1cbi8qKlxuICogTWVyZ2Ugb3B0aW9ucyBhbmQgY29uZmlnIHdpdGggZGVmYXVsdHNcbiAqIHVwZGF0ZSBvcHRpb25zIGZldGNoX2Zvcm1hdCBhY2NvcmRpbmcgdG8gJ3R5cGUnIHBhcmFtXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGNvbmZpZ1xuICogQHJldHVybnMgeyp9IHVwZGF0ZWQgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gcHJlcGFyZU9wdGlvbnMob3B0aW9ucywgY29uZmlnKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2Ygc3JjX3RyYW5zZm9ybWF0aW9uKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMudG9PcHRpb25zKCk7XG4gIH1cblxuICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIGNvbmZpZywgREVGQVVMVF9JTUFHRV9QQVJBTVMpO1xuXG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdmZXRjaCcpIHtcbiAgICBvcHRpb25zLmZldGNoX2Zvcm1hdCA9IG9wdGlvbnMuZmV0Y2hfZm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0O1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYW55IGFzc2V0IGluIHlvdXIgTWVkaWEgbGlicmFyeS5cbiAqIEBmdW5jdGlvbiB1cmxcbiAqIEBpZ25vcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIG1lZGlhIGFzc2V0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgVVJMLlxuICogQHBhcmFtIHtvYmplY3R9IFtjb25maWc9e31dIC0gVVJMIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAqICBGb3IgZGV0YWlscyBvbiBhbGwgZmV0Y2ggdHlwZXMsIHNlZVxuICogPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbnMjZmV0Y2hpbmdfaW1hZ2VzX2Zyb21fcmVtb3RlX2xvY2F0aW9uc1wiXG4gKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmV0Y2ggdHlwZXM8L2E+LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJlc291cmNlX3R5cGU9J2ltYWdlJ10gLSBUaGUgdHlwZSBvZiBhc3NldC4gPHA+UG9zc2libGUgdmFsdWVzOjxici8+XG4gKiAgLSBgaW1hZ2VgPGJyLz5cbiAqICAtIGB2aWRlb2A8YnIvPlxuICogIC0gYHJhd2BcbiAqIEBwYXJhbSB7c2lnbmF0dXJlfSBbb3B0aW9ucy5zaWduYXR1cmU9J3MtLTEyMzQ1Njc4LS0nXSAtIFRoZSBzaWduYXR1cmUgY29tcG9uZW50IG9mIGFcbiAqICBzaWduZWQgZGVsaXZlcnkgVVJMIG9mIHRoZSBmb3JtYXQ6IC9zLS1TSUdOQVRVUkUtLS8uXG4gKiAgRm9yIGRldGFpbHMgb24gc2lnbmF0dXJlcywgc2VlXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NpZ25hdHVyZXNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5TaWduYXR1cmVzPC9hPi5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG1lZGlhIGFzc2V0IFVSTC5cbiAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gKi9cblxuXG5mdW5jdGlvbiB1cmxfdXJsKHB1YmxpY0lkKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgaWYgKCFwdWJsaWNJZCkge1xuICAgIHJldHVybiBwdWJsaWNJZDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBwcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBjb25maWcpO1xuICBwdWJsaWNJZCA9IHByZXBhcmVQdWJsaWNJZChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHZhciBlcnJvciA9IHZhbGlkYXRlKG9wdGlvbnMpO1xuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHJlc3VsdFVybCA9IHVybFN0cmluZyhwdWJsaWNJZCwgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMudXJsQW5hbHl0aWNzKSB7XG4gICAgdmFyIGFuYWx5dGljc09wdGlvbnMgPSBnZXRBbmFseXRpY3NPcHRpb25zKG9wdGlvbnMpO1xuICAgIHZhciBzZGtBbmFseXRpY3NTaWduYXR1cmUgPSBnZXRTREtBbmFseXRpY3NTaWduYXR1cmUoYW5hbHl0aWNzT3B0aW9ucyk7IC8vIHVybCBtaWdodCBhbHJlYWR5IGhhdmUgYSAnPycgcXVlcnkgcGFyYW1cblxuICAgIHZhciBhcHBlbmRlciA9ICc/JztcblxuICAgIGlmIChyZXN1bHRVcmwuaW5kZXhPZignPycpID49IDApIHtcbiAgICAgIGFwcGVuZGVyID0gJyYnO1xuICAgIH1cblxuICAgIHJlc3VsdFVybCA9IFwiXCIuY29uY2F0KHJlc3VsdFVybCkuY29uY2F0KGFwcGVuZGVyLCBcIl9hPVwiKS5jb25jYXQoc2RrQW5hbHl0aWNzU2lnbmF0dXJlKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF1dGhfdG9rZW4pIHtcbiAgICB2YXIgX2FwcGVuZGVyID0gcmVzdWx0VXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nO1xuXG4gICAgcmVzdWx0VXJsID0gXCJcIi5jb25jYXQocmVzdWx0VXJsKS5jb25jYXQoX2FwcGVuZGVyLCBcIl9fY2xkX3Rva2VuX189XCIpLmNvbmNhdChvcHRpb25zLmF1dGhfdG9rZW4pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFVybDtcbn1cbjtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZ2VuZXJhdGVCcmVha3BvaW50cy5qc1xuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheVdpdGhIb2xlcyhhcnIpIHx8IGdlbmVyYXRlQnJlYWtwb2ludHNfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBnZW5lcmF0ZUJyZWFrcG9pbnRzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgZ2VuZXJhdGVCcmVha3BvaW50c19ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2V0cyBvciBwb3B1bGF0ZXMgc3Jjc2V0IGJyZWFrcG9pbnRzIHVzaW5nIHByb3ZpZGVkIHBhcmFtZXRlcnNcbiAqIEVpdGhlciB0aGUgYnJlYWtwb2ludHMgb3IgbWluX3dpZHRoLCBtYXhfd2lkdGgsIG1heF9pbWFnZXMgbXVzdCBiZSBwcm92aWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzcmNzZXR9IHNyY3NldCBPcHRpb25zIHdpdGggZWl0aGVyIGBicmVha3BvaW50c2Agb3IgYG1pbl93aWR0aGAsIGBtYXhfd2lkdGhgLCBhbmQgYG1heF9pbWFnZXNgXG4gKlxuICogQHJldHVybiB7bnVtYmVyW119IEFycmF5IG9mIGJyZWFrcG9pbnRzXG4gKlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzKHNyY3NldCkge1xuICB2YXIgYnJlYWtwb2ludHMgPSBzcmNzZXQuYnJlYWtwb2ludHMgfHwgW107XG5cbiAgaWYgKGJyZWFrcG9pbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBicmVha3BvaW50cztcbiAgfVxuXG4gIHZhciBfbWFwID0gW3NyY3NldC5taW5fd2lkdGgsIHNyY3NldC5tYXhfd2lkdGgsIHNyY3NldC5tYXhfaW1hZ2VzXS5tYXAoTnVtYmVyKSxcbiAgICAgIF9tYXAyID0gZ2VuZXJhdGVCcmVha3BvaW50c19zbGljZWRUb0FycmF5KF9tYXAsIDMpLFxuICAgICAgbWluX3dpZHRoID0gX21hcDJbMF0sXG4gICAgICBtYXhfd2lkdGggPSBfbWFwMlsxXSxcbiAgICAgIG1heF9pbWFnZXMgPSBfbWFwMlsyXTtcblxuICBpZiAoW21pbl93aWR0aCwgbWF4X3dpZHRoLCBtYXhfaW1hZ2VzXS5zb21lKGlzTmFOKSkge1xuICAgIHRocm93ICdFaXRoZXIgKG1pbl93aWR0aCwgbWF4X3dpZHRoLCBtYXhfaW1hZ2VzKSAnICsgJ29yIGJyZWFrcG9pbnRzIG11c3QgYmUgcHJvdmlkZWQgdG8gdGhlIGltYWdlIHNyY3NldCBhdHRyaWJ1dGUnO1xuICB9XG5cbiAgaWYgKG1pbl93aWR0aCA+IG1heF93aWR0aCkge1xuICAgIHRocm93ICdtaW5fd2lkdGggbXVzdCBiZSBsZXNzIHRoYW4gbWF4X3dpZHRoJztcbiAgfVxuXG4gIGlmIChtYXhfaW1hZ2VzIDw9IDApIHtcbiAgICB0aHJvdyAnbWF4X2ltYWdlcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcic7XG4gIH0gZWxzZSBpZiAobWF4X2ltYWdlcyA9PT0gMSkge1xuICAgIG1pbl93aWR0aCA9IG1heF93aWR0aDtcbiAgfVxuXG4gIHZhciBzdGVwU2l6ZSA9IE1hdGguY2VpbCgobWF4X3dpZHRoIC0gbWluX3dpZHRoKSAvIE1hdGgubWF4KG1heF9pbWFnZXMgLSAxLCAxKSk7XG5cbiAgZm9yICh2YXIgY3VycmVudCA9IG1pbl93aWR0aDsgY3VycmVudCA8IG1heF93aWR0aDsgY3VycmVudCArPSBzdGVwU2l6ZSkge1xuICAgIGJyZWFrcG9pbnRzLnB1c2goY3VycmVudCk7XG4gIH1cblxuICBicmVha3BvaW50cy5wdXNoKG1heF93aWR0aCk7XG4gIHJldHVybiBicmVha3BvaW50cztcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvc3Jjc2V0VXRpbHMuanNcblxudmFyIHNyY3NldFV0aWxzX2lzRW1wdHkgPSBpc0VtcHR5O1xuXG5cblxuLyoqXG4gKiBPcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHNyY3NldCBhdHRyaWJ1dGUuXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBzcmNzZXRcbiAqIEBwcm9wZXJ0eSB7KG51bWJlcltdfHN0cmluZ1tdKX0gICBbYnJlYWtwb2ludHNdIEFuIGFycmF5IG9mIGJyZWFrcG9pbnRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9ICAgICAgICAgICAgICAgIFttaW5fd2lkdGhdICAgTWluaW1hbCB3aWR0aCBvZiB0aGUgc3Jjc2V0IGltYWdlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgICAgICAgICAgICAgICBbbWF4X3dpZHRoXSAgIE1heGltYWwgd2lkdGggb2YgdGhlIHNyY3NldCBpbWFnZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gICAgICAgICAgICAgICAgW21heF9pbWFnZXNdICBOdW1iZXIgb2Ygc3Jjc2V0IGltYWdlcyB0byBnZW5lcmF0ZS5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fHN0cmluZ30gICAgICAgICBbdHJhbnNmb3JtYXRpb25dIFRoZSB0cmFuc2Zvcm1hdGlvbiB0byB1c2UgaW4gdGhlIHNyY3NldCB1cmxzLlxuICogQHByb3BlcnR5IHtib29sZWFufSAgICAgICAgICAgICAgIFtzaXplc10gV2hldGhlciB0byBjYWxjdWxhdGUgYW5kIGFkZCB0aGUgc2l6ZXMgYXR0cmlidXRlLlxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZW5lcmF0ZXMgYSBzaW5nbGUgc3Jjc2V0IGl0ZW0gdXJsXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNfaWQgIFB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggICAgICBXaWR0aCBpbiBwaXhlbHMgb2YgdGhlIHNyY3NldCBpdGVtLlxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSB0cmFuc2Zvcm1hdGlvblxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgQWRkaXRpb25hbCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0aW5nIFVSTCBvZiB0aGUgaXRlbVxuICovXG5cbmZ1bmN0aW9uIHNjYWxlZFVybChwdWJsaWNfaWQsIHdpZHRoLCB0cmFuc2Zvcm1hdGlvbikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHZhciBjb25maWdQYXJhbXMgPSBleHRyYWN0VXJsUGFyYW1zKG9wdGlvbnMpO1xuICB0cmFuc2Zvcm1hdGlvbiA9IHRyYW5zZm9ybWF0aW9uIHx8IG9wdGlvbnM7XG4gIGNvbmZpZ1BhcmFtcy5yYXdfdHJhbnNmb3JtYXRpb24gPSBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKFttZXJnZV9yb290X21lcmdlX2RlZmF1bHQuYSh7fSwgdHJhbnNmb3JtYXRpb24pLCB7XG4gICAgY3JvcDogJ3NjYWxlJyxcbiAgICB3aWR0aDogd2lkdGhcbiAgfV0pLnRvU3RyaW5nKCk7XG4gIHJldHVybiB1cmxfdXJsKHB1YmxpY19pZCwgY29uZmlnUGFyYW1zKTtcbn1cbi8qKlxuICogSWYgY2FjaGUgaXMgZW5hYmxlZCwgZ2V0IHRoZSBicmVha3BvaW50cyBmcm9tIHRoZSBjYWNoZS4gSWYgdGhlIHZhbHVlcyB3ZXJlIG5vdCBmb3VuZCBpbiB0aGUgY2FjaGUsXG4gKiBvciBjYWNoZSBpcyBub3QgZW5hYmxlZCwgZ2VuZXJhdGUgdGhlIHZhbHVlcy5cbiAqIEBwYXJhbSB7c3Jjc2V0fSBzcmNzZXQgVGhlIHNyY3NldCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNfaWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHsqfEFycmF5fVxuICovXG5cbmZ1bmN0aW9uIGdldE9yR2VuZXJhdGVCcmVha3BvaW50cyhwdWJsaWNfaWQpIHtcbiAgdmFyIHNyY3NldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgcmV0dXJuIGdlbmVyYXRlQnJlYWtwb2ludHMoc3Jjc2V0KTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZW5lcmF0ZXMgc3Jjc2V0IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgSFRNTCBpbWcgdGFnXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNfaWQgIFB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyW119IGJyZWFrcG9pbnRzIEFuIGFycmF5IG9mIGJyZWFrcG9pbnRzIChpbiBwaXhlbHMpXG4gKiBAcGFyYW0ge29iamVjdH0gdHJhbnNmb3JtYXRpb24gVGhlIHRyYW5zZm9ybWF0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBJbmNsdWRlcyBodG1sIHRhZyBvcHRpb25zLCB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdGluZyBzcmNzZXQgYXR0cmlidXRlIHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdGVTcmNzZXRBdHRyaWJ1dGUocHVibGljX2lkLCBicmVha3BvaW50cywgdHJhbnNmb3JtYXRpb24sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0LmEob3B0aW9ucyk7XG4gIHBhdGNoRmV0Y2hGb3JtYXQob3B0aW9ucyk7XG4gIHJldHVybiBicmVha3BvaW50cy5tYXAoZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHNjYWxlZFVybChwdWJsaWNfaWQsIHdpZHRoLCB0cmFuc2Zvcm1hdGlvbiwgb3B0aW9ucyksIFwiIFwiKS5jb25jYXQod2lkdGgsIFwid1wiKTtcbiAgfSkuam9pbignLCAnKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZW5lcmF0ZXMgc2l6ZXMgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBIVE1MIGltZyB0YWdcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcltdfSBicmVha3BvaW50cyBBbiBhcnJheSBvZiBicmVha3BvaW50cy5cbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0aW5nIHNpemVzIGF0dHJpYnV0ZSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2l6ZXNBdHRyaWJ1dGUoYnJlYWtwb2ludHMpIHtcbiAgaWYgKGJyZWFrcG9pbnRzID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gYnJlYWtwb2ludHMubWFwKGZ1bmN0aW9uICh3aWR0aCkge1xuICAgIHJldHVybiBcIihtYXgtd2lkdGg6IFwiLmNvbmNhdCh3aWR0aCwgXCJweCkgXCIpLmNvbmNhdCh3aWR0aCwgXCJweFwiKTtcbiAgfSkuam9pbignLCAnKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZW5lcmF0ZXMgc3Jjc2V0IGFuZCBzaXplcyBhdHRyaWJ1dGVzIG9mIHRoZSBpbWFnZSB0YWdcbiAqXG4gKiBHZW5lcmF0ZWQgYXR0cmlidXRlcyBhcmUgYWRkZWQgdG8gYXR0cmlidXRlcyBhcmd1bWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgcHVibGljSWQgIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlXG4gKiBAcGFyYW0ge29iamVjdH0gICAgYXR0cmlidXRlcyBFeGlzdGluZyBIVE1MIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge3NyY3NldH0gICAgc3Jjc2V0RGF0YVxuICogQHBhcmFtIHtvYmplY3R9ICAgIG9wdGlvbnMgICAgQWRkaXRpb25hbCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gYXJyYXkgVGhlIHJlc3BvbnNpdmUgYXR0cmlidXRlc1xuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyhwdWJsaWNJZCkge1xuICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBzcmNzZXREYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAvLyBDcmVhdGUgYm90aCBzcmNzZXQgYW5kIHNpemVzIGhlcmUgdG8gYXZvaWQgZmV0Y2hpbmcgYnJlYWtwb2ludHMgdHdpY2VcbiAgdmFyIHJlc3BvbnNpdmVBdHRyaWJ1dGVzID0ge307XG5cbiAgaWYgKHNyY3NldFV0aWxzX2lzRW1wdHkoc3Jjc2V0RGF0YSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2l2ZUF0dHJpYnV0ZXM7XG4gIH1cblxuICB2YXIgZ2VuZXJhdGVTaXplcyA9ICFhdHRyaWJ1dGVzLnNpemVzICYmIHNyY3NldERhdGEuc2l6ZXMgPT09IHRydWU7XG4gIHZhciBnZW5lcmF0ZVNyY3NldCA9ICFhdHRyaWJ1dGVzLnNyY3NldDtcblxuICBpZiAoZ2VuZXJhdGVTcmNzZXQgfHwgZ2VuZXJhdGVTaXplcykge1xuICAgIHZhciBicmVha3BvaW50cyA9IGdldE9yR2VuZXJhdGVCcmVha3BvaW50cyhwdWJsaWNJZCwgc3Jjc2V0RGF0YSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoZ2VuZXJhdGVTcmNzZXQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbiA9IHNyY3NldERhdGEudHJhbnNmb3JtYXRpb247XG4gICAgICB2YXIgc3Jjc2V0QXR0ciA9IGdlbmVyYXRlU3Jjc2V0QXR0cmlidXRlKHB1YmxpY0lkLCBicmVha3BvaW50cywgdHJhbnNmb3JtYXRpb24sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXNyY3NldFV0aWxzX2lzRW1wdHkoc3Jjc2V0QXR0cikpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMuc3Jjc2V0ID0gc3Jjc2V0QXR0cjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2VuZXJhdGVTaXplcykge1xuICAgICAgdmFyIHNpemVzQXR0ciA9IGdlbmVyYXRlU2l6ZXNBdHRyaWJ1dGUoYnJlYWtwb2ludHMpO1xuXG4gICAgICBpZiAoIXNyY3NldFV0aWxzX2lzRW1wdHkoc2l6ZXNBdHRyKSkge1xuICAgICAgICByZXNwb25zaXZlQXR0cmlidXRlcy5zaXplcyA9IHNpemVzQXR0cjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2l2ZUF0dHJpYnV0ZXM7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEgbWVkaWEgcXVlcnlcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG9wdGlvbnMubWluX3dpZHRoXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG9wdGlvbnMubWF4X3dpZHRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgbWVkaWEgcXVlcnkgc3RyaW5nXG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdGVNZWRpYUF0dHIob3B0aW9ucykge1xuICB2YXIgbWVkaWFRdWVyeSA9IFtdO1xuXG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICBpZiAob3B0aW9ucy5taW5fd2lkdGggIT0gbnVsbCkge1xuICAgICAgbWVkaWFRdWVyeS5wdXNoKFwiKG1pbi13aWR0aDogXCIuY29uY2F0KG9wdGlvbnMubWluX3dpZHRoLCBcInB4KVwiKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWF4X3dpZHRoICE9IG51bGwpIHtcbiAgICAgIG1lZGlhUXVlcnkucHVzaChcIihtYXgtd2lkdGg6IFwiLmNvbmNhdChvcHRpb25zLm1heF93aWR0aCwgXCJweClcIikpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZWRpYVF1ZXJ5LmpvaW4oJyBhbmQgJyk7XG59XG52YXIgc3Jjc2V0VXJsID0gc2NhbGVkVXJsO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9pbWFnZXRhZy5qc1xuZnVuY3Rpb24gaW1hZ2V0YWdfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBpbWFnZXRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBpbWFnZXRhZ190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGltYWdldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBpbWFnZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBpbWFnZXRhZ19nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IGltYWdldGFnX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBpbWFnZXRhZ19zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBpbWFnZXRhZ19nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBpbWFnZXRhZ19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyBpbWFnZXRhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gaW1hZ2V0YWdfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGltYWdldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGltYWdldGFnX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gaW1hZ2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIGltYWdldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoaW1hZ2V0YWdfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIGltYWdldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZihvKSB7IGltYWdldGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKipcbiAqIEltYWdlIFRhZ1xuICogRGVwZW5kcyBvbiAndGFncy9odG1sdGFnJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUwgKERPTSkgSW1hZ2UgdGFnIHVzaW5nIENsb3VkaW5hcnkgYXMgdGhlIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvciBJbWFnZVRhZ1xuICogQGV4dGVuZHMgSHRtbFRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xuXG52YXIgaW1hZ2V0YWdfSW1hZ2VUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIGltYWdldGFnX2luaGVyaXRzKEltYWdlVGFnLCBfSHRtbFRhZyk7XG5cbiAgdmFyIF9zdXBlciA9IGltYWdldGFnX2NyZWF0ZVN1cGVyKEltYWdlVGFnKTtcblxuICBmdW5jdGlvbiBJbWFnZVRhZyhwdWJsaWNJZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGltYWdldGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlVGFnKTtcblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImltZ1wiLCBwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqL1xuXG5cbiAgaW1hZ2V0YWdfY3JlYXRlQ2xhc3MoSW1hZ2VUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBhdHRyLCBvcHRpb25zLCBzcmNBdHRyaWJ1dGU7XG4gICAgICBhdHRyID0gaW1hZ2V0YWdfZ2V0KGltYWdldGFnX2dldFByb3RvdHlwZU9mKEltYWdlVGFnLnByb3RvdHlwZSksIFwiYXR0cmlidXRlc1wiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IHt9O1xuICAgICAgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmdldE9wdGlvbignYXR0cmlidXRlcycpIHx8IHt9O1xuICAgICAgdmFyIHNyY3NldFBhcmFtID0gdGhpcy5nZXRPcHRpb24oJ3NyY3NldCcpIHx8IGF0dHJpYnV0ZXMuc3Jjc2V0O1xuICAgICAgdmFyIHJlc3BvbnNpdmVBdHRyaWJ1dGVzID0ge307XG5cbiAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShzcmNzZXRQYXJhbSkpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMuc3Jjc2V0ID0gc3Jjc2V0UGFyYW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zaXZlQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyh0aGlzLnB1YmxpY0lkLCBhdHRyaWJ1dGVzLCBzcmNzZXRQYXJhbSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNFbXB0eShyZXNwb25zaXZlQXR0cmlidXRlcykpIHtcbiAgICAgICAgZGVsZXRlIGF0dHIud2lkdGg7XG4gICAgICAgIGRlbGV0ZSBhdHRyLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoYXR0ciwgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMpO1xuICAgICAgc3JjQXR0cmlidXRlID0gb3B0aW9ucy5yZXNwb25zaXZlICYmICFvcHRpb25zLmNsaWVudF9oaW50cyA/ICdkYXRhLXNyYycgOiAnc3JjJztcblxuICAgICAgaWYgKGF0dHJbc3JjQXR0cmlidXRlXSA9PSBudWxsKSB7XG4gICAgICAgIGF0dHJbc3JjQXR0cmlidXRlXSA9IHVybF91cmwodGhpcy5wdWJsaWNJZCwgdGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2VUYWc7XG59KGh0bWx0YWcpO1xuXG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpbWFnZXRhZyA9IChpbWFnZXRhZ19JbWFnZVRhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL3NvdXJjZXRhZy5qc1xuZnVuY3Rpb24gc291cmNldGFnX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gc291cmNldGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIHNvdXJjZXRhZ190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHNvdXJjZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgc291cmNldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBzb3VyY2V0YWdfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBzb3VyY2V0YWdfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IHNvdXJjZXRhZ19zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBzb3VyY2V0YWdfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gc291cmNldGFnX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgc291cmNldGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHNvdXJjZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gc291cmNldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChzb3VyY2V0YWdfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHNvdXJjZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gc291cmNldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHNvdXJjZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YobykgeyBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vKipcbiAqIEltYWdlIFRhZ1xuICogRGVwZW5kcyBvbiAndGFncy9odG1sdGFnJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUwgKERPTSkgSW1hZ2UgdGFnIHVzaW5nIENsb3VkaW5hcnkgYXMgdGhlIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvciBTb3VyY2VUYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cblxudmFyIHNvdXJjZXRhZ19Tb3VyY2VUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIHNvdXJjZXRhZ19pbmhlcml0cyhTb3VyY2VUYWcsIF9IdG1sVGFnKTtcblxuICB2YXIgX3N1cGVyID0gc291cmNldGFnX2NyZWF0ZVN1cGVyKFNvdXJjZVRhZyk7XG5cbiAgZnVuY3Rpb24gU291cmNlVGFnKHB1YmxpY0lkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgc291cmNldGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvdXJjZVRhZyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJzb3VyY2VcIiwgcHVibGljSWQsIG9wdGlvbnMpO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKi9cblxuXG4gIHNvdXJjZXRhZ19jcmVhdGVDbGFzcyhTb3VyY2VUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBzcmNzZXRQYXJhbSA9IHRoaXMuZ2V0T3B0aW9uKCdzcmNzZXQnKTtcbiAgICAgIHZhciBhdHRyID0gc291cmNldGFnX2dldChzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YoU291cmNlVGFnLnByb3RvdHlwZSksIFwiYXR0cmlidXRlc1wiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IHt9O1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKGF0dHIsIGdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyh0aGlzLnB1YmxpY0lkLCBhdHRyLCBzcmNzZXRQYXJhbSwgb3B0aW9ucykpO1xuXG4gICAgICBpZiAoIWF0dHIuc3Jjc2V0KSB7XG4gICAgICAgIGF0dHIuc3Jjc2V0ID0gdXJsX3VybCh0aGlzLnB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdHRyLm1lZGlhICYmIG9wdGlvbnMubWVkaWEpIHtcbiAgICAgICAgYXR0ci5tZWRpYSA9IGdlbmVyYXRlTWVkaWFBdHRyKG9wdGlvbnMubWVkaWEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU291cmNlVGFnO1xufShodG1sdGFnKTtcblxuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc291cmNldGFnID0gKHNvdXJjZXRhZ19Tb3VyY2VUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9waWN0dXJldGFnLmpzXG5mdW5jdGlvbiBwaWN0dXJldGFnX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gcGljdHVyZXRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBwaWN0dXJldGFnX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgcGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgcGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IHBpY3R1cmV0YWdfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBwaWN0dXJldGFnX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBwaWN0dXJldGFnX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIHBpY3R1cmV0YWdfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgcGljdHVyZXRhZ19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IHBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcGljdHVyZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBwaWN0dXJldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAocGljdHVyZXRhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gcGljdHVyZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gcGljdHVyZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBwaWN0dXJldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YobykgeyBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cblxuXG5cbnZhciBwaWN0dXJldGFnX1BpY3R1cmVUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIHBpY3R1cmV0YWdfaW5oZXJpdHMoUGljdHVyZVRhZywgX0h0bWxUYWcpO1xuXG4gIHZhciBfc3VwZXIgPSBwaWN0dXJldGFnX2NyZWF0ZVN1cGVyKFBpY3R1cmVUYWcpO1xuXG4gIGZ1bmN0aW9uIFBpY3R1cmVUYWcocHVibGljSWQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHNvdXJjZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXG4gICAgcGljdHVyZXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBQaWN0dXJlVGFnKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ3BpY3R1cmUnLCBwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgX3RoaXMud2lkdGhMaXN0ID0gc291cmNlcztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqIEBvdmVycmlkZSAqL1xuXG5cbiAgcGljdHVyZXRhZ19jcmVhdGVDbGFzcyhQaWN0dXJlVGFnLCBbe1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMud2lkdGhMaXN0Lm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbWluX3dpZHRoID0gX3JlZi5taW5fd2lkdGgsXG4gICAgICAgICAgICBtYXhfd2lkdGggPSBfcmVmLm1heF93aWR0aCxcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uID0gX3JlZi50cmFuc2Zvcm1hdGlvbjtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IF90aGlzMi5nZXRPcHRpb25zKCk7XG5cbiAgICAgICAgdmFyIHNvdXJjZVRyYW5zZm9ybWF0aW9uID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihvcHRpb25zKTtcbiAgICAgICAgc291cmNlVHJhbnNmb3JtYXRpb24uY2hhaW4oKS5mcm9tT3B0aW9ucyh0eXBlb2YgdHJhbnNmb3JtYXRpb24gPT09ICdzdHJpbmcnID8ge1xuICAgICAgICAgIHJhd190cmFuc2Zvcm1hdGlvbjogdHJhbnNmb3JtYXRpb25cbiAgICAgICAgfSA6IHRyYW5zZm9ybWF0aW9uKTtcbiAgICAgICAgb3B0aW9ucyA9IGV4dHJhY3RVcmxQYXJhbXMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMubWVkaWEgPSB7XG4gICAgICAgICAgbWluX3dpZHRoOiBtaW5fd2lkdGgsXG4gICAgICAgICAgbWF4X3dpZHRoOiBtYXhfd2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy50cmFuc2Zvcm1hdGlvbiA9IHNvdXJjZVRyYW5zZm9ybWF0aW9uO1xuICAgICAgICByZXR1cm4gbmV3IHNvdXJjZXRhZyhfdGhpczIucHVibGljSWQsIG9wdGlvbnMpLnRvSHRtbCgpO1xuICAgICAgfSkuam9pbignJykgKyBuZXcgaW1hZ2V0YWcodGhpcy5wdWJsaWNJZCwgdGhpcy5nZXRPcHRpb25zKCkpLnRvSHRtbCgpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgYXR0ciA9IHBpY3R1cmV0YWdfZ2V0KHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YoUGljdHVyZVRhZy5wcm90b3R5cGUpLCBcImF0dHJpYnV0ZXNcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgZGVsZXRlIGF0dHIud2lkdGg7XG4gICAgICBkZWxldGUgYXR0ci5oZWlnaHQ7XG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCI8L1wiICsgdGhpcy5uYW1lICsgXCI+XCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBpY3R1cmVUYWc7XG59KGh0bWx0YWcpO1xuXG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwaWN0dXJldGFnID0gKHBpY3R1cmV0YWdfUGljdHVyZVRhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL3ZpZGVvdGFnLmpzXG5mdW5jdGlvbiB2aWRlb3RhZ190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHZpZGVvdGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIHZpZGVvdGFnX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgdmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHZpZGVvdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IHZpZGVvdGFnX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsgfSBlbHNlIHsgdmlkZW90YWdfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IHZpZGVvdGFnX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIHZpZGVvdGFnX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHZpZGVvdGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IHZpZGVvdGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiB2aWRlb3RhZ19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiB2aWRlb3RhZ19jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gdmlkZW90YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gdmlkZW90YWdfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiB2aWRlb3RhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gdmlkZW90YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmICh2aWRlb3RhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gdmlkZW90YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKG8pIHsgdmlkZW90YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogVmlkZW8gVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAndXRpbCcsICdjbG91ZGluYXJ5J1xuICovXG5cblxuXG5cbnZhciBWSURFT19UQUdfUEFSQU1TID0gWydzb3VyY2VfdHlwZXMnLCAnc291cmNlX3RyYW5zZm9ybWF0aW9uJywgJ2ZhbGxiYWNrX2NvbnRlbnQnLCAncG9zdGVyJywgJ3NvdXJjZXMnXTtcbnZhciB2aWRlb3RhZ19ERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyA9IFsnd2VibScsICdtcDQnLCAnb2d2J107XG52YXIgdmlkZW90YWdfREVGQVVMVF9QT1NURVJfT1BUSU9OUyA9IHtcbiAgZm9ybWF0OiAnanBnJyxcbiAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJ1xufTtcbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIFZpZGVvIHRhZyB1c2luZyBDbG91ZGluYXJ5IGFzIHRoZSBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3IgVmlkZW9UYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cblxudmFyIHZpZGVvdGFnX1ZpZGVvVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSHRtbFRhZykge1xuICB2aWRlb3RhZ19pbmhlcml0cyhWaWRlb1RhZywgX0h0bWxUYWcpO1xuXG4gIHZhciBfc3VwZXIgPSB2aWRlb3RhZ19jcmVhdGVTdXBlcihWaWRlb1RhZyk7XG5cbiAgZnVuY3Rpb24gVmlkZW9UYWcocHVibGljSWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2aWRlb3RhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWRlb1RhZyk7XG5cbiAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIERFRkFVTFRfVklERU9fUEFSQU1TKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJ2aWRlb1wiLCBwdWJsaWNJZC5yZXBsYWNlKC9cXC4obXA0fG9ndnx3ZWJtKSQvLCAnJyksIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IG9uIGVhY2ggc291cmNlXG4gICAqIEBmdW5jdGlvbiBWaWRlb1RhZyNzZXRTb3VyY2VUcmFuc2Zvcm1hdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYW4gb2JqZWN0IHdpdGggcGFpcnMgb2Ygc291cmNlIHR5cGUgYW5kIHNvdXJjZSB0cmFuc2Zvcm1hdGlvblxuICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAqL1xuXG5cbiAgdmlkZW90YWdfY3JlYXRlQ2xhc3MoVmlkZW9UYWcsIFt7XG4gICAga2V5OiBcInNldFNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNvdXJjZVRyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuc291cmNlVHJhbnNmb3JtYXRpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc291cmNlIHR5cGVzIHRvIGluY2x1ZGUgaW4gdGhlIHZpZGVvIHRhZ1xuICAgICAqIEBmdW5jdGlvbiBWaWRlb1RhZyNzZXRTb3VyY2VUeXBlc1xuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYW4gYXJyYXkgb2Ygc291cmNlIHR5cGVzXG4gICAgICogQHJldHVybnMge1ZpZGVvVGFnfSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U291cmNlVHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U291cmNlVHlwZXModmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5zb3VyY2VUeXBlcyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwb3N0ZXIgdG8gYmUgdXNlZCBpbiB0aGUgdmlkZW8gdGFnXG4gICAgICogQGZ1bmN0aW9uIFZpZGVvVGFnI3NldFBvc3RlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gdmFsdWVcbiAgICAgKiAtIHN0cmluZzogYSBVUkwgdG8gdXNlIGZvciB0aGUgcG9zdGVyXG4gICAgICogLSBPYmplY3Q6IHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlcnMgdG8gYXBwbHkgdG8gdGhlIHBvc3Rlci4gTWF5IG9wdGlvbmFsbHkgaW5jbHVkZSBhIHB1YmxpY19pZCB0byB1c2UgaW5zdGVhZCBvZiB0aGUgdmlkZW8gcHVibGljX2lkLlxuICAgICAqIEByZXR1cm5zIHtWaWRlb1RhZ30gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFBvc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3N0ZXIodmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5wb3N0ZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udGVudCB0byB1c2UgYXMgZmFsbGJhY2sgaW4gdGhlIHZpZGVvIHRhZ1xuICAgICAqIEBmdW5jdGlvbiBWaWRlb1RhZyNzZXRGYWxsYmFja0NvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgY29udGVudCB0byB1c2UsIGluIEhUTUwgZm9ybWF0XG4gICAgICogQHJldHVybnMge1ZpZGVvVGFnfSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmFsbGJhY2tDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZhbGxiYWNrQ29udGVudCh2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLmZhbGxiYWNrQ29udGVudCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZVR5cGVzID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLmdldFZhbHVlKCdzb3VyY2VfdHlwZXMnKTtcbiAgICAgIHZhciBzb3VyY2VUcmFuc2Zvcm1hdGlvbiA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5nZXRWYWx1ZSgnc291cmNlX3RyYW5zZm9ybWF0aW9uJyk7XG4gICAgICB2YXIgZmFsbGJhY2sgPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZ2V0VmFsdWUoJ2ZhbGxiYWNrX2NvbnRlbnQnKTtcbiAgICAgIHZhciBzb3VyY2VzID0gdGhpcy5nZXRPcHRpb24oJ3NvdXJjZXMnKTtcbiAgICAgIHZhciBpbm5lclRhZ3MgPSBbXTtcblxuICAgICAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShzb3VyY2VzKSAmJiAhaXNFbXB0eShzb3VyY2VzKSkge1xuICAgICAgICBpbm5lclRhZ3MgPSBzb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgdmFyIHNyYyA9IHVybF91cmwoX3RoaXMucHVibGljSWQsIGRlZmF1bHRzKHt9LCBzb3VyY2UudHJhbnNmb3JtYXRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICByZXNvdXJjZV90eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgZm9ybWF0OiBzb3VyY2UudHlwZVxuICAgICAgICAgIH0pLCBfdGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVTb3VyY2VUYWcoc3JjLCBzb3VyY2UudHlwZSwgc291cmNlLmNvZGVjcyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRW1wdHkoc291cmNlVHlwZXMpKSB7XG4gICAgICAgICAgc291cmNlVHlwZXMgPSB2aWRlb3RhZ19ERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoc291cmNlVHlwZXMpKSB7XG4gICAgICAgICAgaW5uZXJUYWdzID0gc291cmNlVHlwZXMubWFwKGZ1bmN0aW9uIChzcmNUeXBlKSB7XG4gICAgICAgICAgICB2YXIgc3JjID0gdXJsX3VybChfdGhpcy5wdWJsaWNJZCwgZGVmYXVsdHMoe30sIHNvdXJjZVRyYW5zZm9ybWF0aW9uW3NyY1R5cGVdIHx8IHt9LCB7XG4gICAgICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICAgIGZvcm1hdDogc3JjVHlwZVxuICAgICAgICAgICAgfSksIF90aGlzLmdldE9wdGlvbnMoKSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlU291cmNlVGFnKHNyYywgc3JjVHlwZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlubmVyVGFncy5qb2luKCcnKSArIGZhbGxiYWNrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgc291cmNlVHlwZXMgPSB0aGlzLmdldE9wdGlvbignc291cmNlX3R5cGVzJyk7XG4gICAgICB2YXIgcG9zdGVyID0gdGhpcy5nZXRPcHRpb24oJ3Bvc3RlcicpO1xuXG4gICAgICBpZiAocG9zdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9zdGVyID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkocG9zdGVyKSkge1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBwb3N0ZXIucHVibGljX2lkICE9IG51bGwgPyBERUZBVUxUX0lNQUdFX1BBUkFNUyA6IHZpZGVvdGFnX0RFRkFVTFRfUE9TVEVSX09QVElPTlM7XG4gICAgICAgIHBvc3RlciA9IHVybF91cmwocG9zdGVyLnB1YmxpY19pZCB8fCB0aGlzLnB1YmxpY0lkLCBkZWZhdWx0cyh7fSwgcG9zdGVyLCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHIgPSB2aWRlb3RhZ19nZXQodmlkZW90YWdfZ2V0UHJvdG90eXBlT2YoVmlkZW9UYWcucHJvdG90eXBlKSwgXCJhdHRyaWJ1dGVzXCIsIHRoaXMpLmNhbGwodGhpcykgfHwge307XG4gICAgICBhdHRyID0gb21pdChhdHRyLCBWSURFT19UQUdfUEFSQU1TKTtcbiAgICAgIHZhciBzb3VyY2VzID0gdGhpcy5nZXRPcHRpb24oJ3NvdXJjZXMnKTsgLy8gSW4gY2FzZSBvZiBlbXB0eSBzb3VyY2VUeXBlcyAtIGZhbGxiYWNrIHRvIGRlZmF1bHQgc291cmNlIHR5cGVzIGlzIHVzZWQuXG5cbiAgICAgIHZhciBoYXNTb3VyY2VUYWdzID0gIWlzRW1wdHkoc291cmNlcykgfHwgaXNFbXB0eShzb3VyY2VUeXBlcykgfHwgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHNvdXJjZVR5cGVzKTtcblxuICAgICAgaWYgKCFoYXNTb3VyY2VUYWdzKSB7XG4gICAgICAgIGF0dHJbXCJzcmNcIl0gPSB1cmxfdXJsKHRoaXMucHVibGljSWQsIHRoaXMuZ2V0T3B0aW9ucygpLCB7XG4gICAgICAgICAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICBmb3JtYXQ6IHNvdXJjZVR5cGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zdGVyICE9IG51bGwpIHtcbiAgICAgICAgYXR0cltcInBvc3RlclwiXSA9IHBvc3RlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVNvdXJjZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTb3VyY2VUYWcoc3JjLCBzb3VyY2VUeXBlKSB7XG4gICAgICB2YXIgY29kZWNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIG1pbWVUeXBlID0gbnVsbDtcblxuICAgICAgaWYgKCFpc0VtcHR5KHNvdXJjZVR5cGUpKSB7XG4gICAgICAgIHZhciB2aWRlb1R5cGUgPSBzb3VyY2VUeXBlID09PSAnb2d2JyA/ICdvZ2cnIDogc291cmNlVHlwZTtcbiAgICAgICAgbWltZVR5cGUgPSAndmlkZW8vJyArIHZpZGVvVHlwZTtcblxuICAgICAgICBpZiAoIWlzRW1wdHkoY29kZWNzKSkge1xuICAgICAgICAgIHZhciBjb2RlY3NTdHIgPSBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoY29kZWNzKSA/IGNvZGVjcy5qb2luKCcsICcpIDogY29kZWNzO1xuICAgICAgICAgIG1pbWVUeXBlICs9ICc7IGNvZGVjcz0nICsgY29kZWNzU3RyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIjxzb3VyY2UgXCIgKyB0aGlzLmh0bWxBdHRycyh7XG4gICAgICAgIHNyYzogc3JjLFxuICAgICAgICB0eXBlOiBtaW1lVHlwZVxuICAgICAgfSkgKyBcIj5cIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmlkZW9UYWc7XG59KGh0bWx0YWcpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB2aWRlb3RhZyA9ICh2aWRlb3RhZ19WaWRlb1RhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL2NsaWVudGhpbnRzbWV0YXRhZy5qc1xuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGNsaWVudGhpbnRzbWV0YXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgY2xpZW50aGludHNtZXRhdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IGNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gY2xpZW50aGludHNtZXRhdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBjbGllbnRoaW50c21ldGF0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZihvKSB7IGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxuICogSW1hZ2UgVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAnY2xvdWRpbmFyeSdcbiAqL1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIE1ldGEgdGFnIHRoYXQgZW5hYmxlcyBDbGllbnQtSGludHMgZm9yIHRoZSBIVE1MIHBhZ2UuIDxici8+XG4gKiAgU2VlXG4gKiAgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9yZXNwb25zaXZlX2ltYWdlcyNhdXRvbWF0aW5nX3Jlc3BvbnNpdmVfaW1hZ2VzX3dpdGhfY2xpZW50X2hpbnRzXCJcbiAqICB0YXJnZXQ9XCJfbmV3XCI+QXV0b21hdGluZyByZXNwb25zaXZlIGltYWdlcyB3aXRoIENsaWVudCBIaW50czwvYT4gZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBjb25zdHJ1Y3RvciBDbGllbnRIaW50c01ldGFUYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAZXhhbXBsZVxuICogdGFnID0gbmV3IENsaWVudEhpbnRzTWV0YVRhZygpXG4gKiAvL3JldHVybnM6IDxtZXRhIGh0dHAtZXF1aXY9XCJBY2NlcHQtQ0hcIiBjb250ZW50PVwiRFBSLCBWaWV3cG9ydC1XaWR0aCwgV2lkdGhcIj5cbiAqL1xuXG52YXIgY2xpZW50aGludHNtZXRhdGFnX0NsaWVudEhpbnRzTWV0YVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgY2xpZW50aGludHNtZXRhdGFnX2luaGVyaXRzKENsaWVudEhpbnRzTWV0YVRhZywgX0h0bWxUYWcpO1xuXG4gIHZhciBfc3VwZXIgPSBjbGllbnRoaW50c21ldGF0YWdfY3JlYXRlU3VwZXIoQ2xpZW50SGludHNNZXRhVGFnKTtcblxuICBmdW5jdGlvbiBDbGllbnRIaW50c01ldGFUYWcob3B0aW9ucykge1xuICAgIGNsaWVudGhpbnRzbWV0YXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGllbnRIaW50c01ldGFUYWcpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsICdtZXRhJywgdm9pZCAwLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgIFwiaHR0cC1lcXVpdlwiOiBcIkFjY2VwdC1DSFwiLFxuICAgICAgY29udGVudDogXCJEUFIsIFZpZXdwb3J0LVdpZHRoLCBXaWR0aFwiXG4gICAgfSwgb3B0aW9ucykpO1xuICB9XG4gIC8qKiBAb3ZlcnJpZGUgKi9cblxuXG4gIGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyhDbGllbnRIaW50c01ldGFUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENsaWVudEhpbnRzTWV0YVRhZztcbn0oaHRtbHRhZyk7XG5cbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsaWVudGhpbnRzbWV0YXRhZyA9IChjbGllbnRoaW50c21ldGF0YWdfQ2xpZW50SGludHNNZXRhVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvcGFyc2Uvbm9ybWFsaXplVG9BcnJheS5qc1xuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBub3JtYWxpemVUb0FycmF5X2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vcm1hbGl6ZVRvQXJyYXlfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub3JtYWxpemVUb0FycmF5X25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuXG4vKipcbiAqIEBkZXNjIG5vcm1hbGl6ZSBlbGVtZW50cywgc3VwcG9ydCBhIHNpbmdsZSBlbGVtZW50LCBhcnJheSBvciBub2RlbGlzdCwgYWx3YXlzIG91dHB1dHMgYXJyYXlcbiAqIEBwYXJhbSBlbGVtZW50czxIVE1MRWxlbWVudFtdPlxuICogQHJldHVybnMge1tdfVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXkoZWxlbWVudHMpIHtcbiAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShlbGVtZW50cykpIHtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0gZWxzZSBpZiAoZWxlbWVudHMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJOb2RlTGlzdFwiKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfdG9Db25zdW1hYmxlQXJyYXkoZWxlbWVudHMpOyAvLyBlbnN1cmUgYW4gYXJyYXkgaXMgYWx3YXlzIHJldHVybmVkLCBldmVuIGlmIG5vZGVsaXN0XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoZWxlbWVudHMpKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHMpLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2VsZW1lbnRzXTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL21vdW50Q2xvdWRpbmFyeVZpZGVvVGFnLmpzXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxFbENvbnRhaW5lclxuICogQHBhcmFtIHtvYmplY3R9IGNsSW5zdGFuY2UgY2xvdWRpbmFyeSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRyYW5zZm9ybWF0aW9uT3B0aW9uc1xuICogQHJldHVybnMgUHJvbWlzZTxIVE1MRWxlbWVudD5cbiAqL1xuZnVuY3Rpb24gbW91bnRDbG91ZGluYXJ5VmlkZW9UYWcoaHRtbEVsQ29udGFpbmVyLCBjbEluc3RhbmNlLCBwdWJsaWNJZCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGh0bWxFbENvbnRhaW5lci5pbm5lckhUTUwgPSBjbEluc3RhbmNlLnZpZGVvVGFnKHB1YmxpY0lkLCBvcHRpb25zKS50b0h0bWwoKTsgLy8gQWxsIHZpZGVvcyB1bmRlciB0aGUgaHRtbCBjb250YWluZXIgbXVzdCBoYXZlIGEgd2lkdGggb2YgMTAwJSwgb3IgdGhleSBtaWdodCBvdmVyZmxvdyBmcm9tIHRoZSBjb250YWluZXJcblxuICAgIHZhciBjbG91ZGluYXJ5VmlkZW9FbGVtZW50ID0gaHRtbEVsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5jbGQtdHJhbnNwYXJlbnQtdmlkZW8nKTtcbiAgICBjbG91ZGluYXJ5VmlkZW9FbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHJlc29sdmUoaHRtbEVsQ29udGFpbmVyKTtcbiAgfSk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9fbW91bnRDbG91ZGluYXJ5VmlkZW9UYWcgPSAobW91bnRDbG91ZGluYXJ5VmlkZW9UYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC90cmFuc2Zvcm1hdGlvbnMvYWRkRmxhZy5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBGdW5jdGlvbiB3aWxsIHB1c2ggYSBmbGFnIHRvIGluY29taW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7e3RyYW5zZm9ybWF0aW9ufSB8IHsuLi50cmFuc2Zvcm1hdGlvbn19IG9wdGlvbnMgLSBUaGVzZSBvcHRpb25zIGFyZSB0aGUgc2FtZSBvcHRpb25zIHByb3ZpZGVkIHRvIGFsbCBvdXIgU0RLIG1ldGhvZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgV2UgZXhwZWN0IG9wdGlvbnMgdG8gZWl0aGVyIGJlIHRoZSB0cmFuc2Zvcm1hdGlvbiBpdHNlbGYsIG9yIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9uc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbGFnXG4gKiBAcmV0dXJucyB0aGUgbXV0YXRlZCBvcHRpb25zIG9iamVjdFxuICovXG5mdW5jdGlvbiBhZGRGbGFnVG9PcHRpb25zKG9wdGlvbnMsIGZsYWcpIHtcbiAgLy8gRG8gd2UgaGF2ZSB0cmFuc2Zvcm1hdGlvblxuICBpZiAob3B0aW9ucy50cmFuc2Zvcm1hdGlvbikge1xuICAgIG9wdGlvbnMudHJhbnNmb3JtYXRpb24ucHVzaCh7XG4gICAgICBmbGFnczogW2ZsYWddXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm8gdHJhbnNmb3JtYXRpb25cbiAgICAvLyBlbnN1cmUgdGhlIGZsYWdzIGFyZSBleHRlbmRlZFxuICAgIGlmICghb3B0aW9ucy5mbGFncykge1xuICAgICAgb3B0aW9ucy5mbGFncyA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbGFncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMuZmxhZ3MgPSBbb3B0aW9ucy5mbGFnc107XG4gICAgfVxuXG4gICAgb3B0aW9ucy5mbGFncy5wdXNoKGZsYWcpO1xuICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGFkZEZsYWcgPSAoYWRkRmxhZ1RvT3B0aW9ucyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvLmpzXG5cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBFbmZvcmNlIG9wdGlvbiBzdHJ1Y3R1cmUsIHNldHMgZGVmYXVsdHMgYW5kIGVuc3VyZXMgYWxwaGEgZmxhZyBleGlzdHNcbiAqIEBwYXJhbSBvcHRpb25zIHtUcmFuc2Zvcm1hdGlvbk9wdGlvbnN9XG4gKi9cblxuZnVuY3Rpb24gZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5hdXRvcGxheSA9IHRydWU7XG4gIG9wdGlvbnMubXV0ZWQgPSB0cnVlO1xuICBvcHRpb25zLmNvbnRyb2xzID0gZmFsc2U7XG4gIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMgPSBvcHRpb25zLm1heF90aW1lb3V0X21zIHx8IERFRkFVTFRfVElNRU9VVF9NUztcbiAgb3B0aW9uc1tcImNsYXNzXCJdID0gb3B0aW9uc1tcImNsYXNzXCJdIHx8ICcnO1xuICBvcHRpb25zW1wiY2xhc3NcIl0gKz0gJyBjbGQtdHJhbnNwYXJlbnQtdmlkZW8nO1xuICBvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzID0gb3B0aW9ucy5leHRlcm5hbExpYnJhcmllcyB8fCB7fTtcblxuICBpZiAoIW9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMuc2VlVGhydSkge1xuICAgIG9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMuc2VlVGhydSA9IERFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTLnNlZVRocnU7XG4gIH0gLy8gZW5zdXJlIHRoZXJlJ3MgYW4gYWxwaGEgdHJhbnNmb3JtYXRpb24gcHJlc2VudFxuICAvLyB0aGlzIGlzIGEgbm9uIGRvY3VtZW50ZWQgaW50ZXJuYWwgZmxhZ1xuXG5cbiAgYWRkRmxhZyhvcHRpb25zLCAnYWxwaGEnKTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8gPSAoZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwveGhyL2xvYWRTY3JpcHQuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gR2l2ZW4gYSBzdHJpbmcgVVJMLCB0aGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCB0aGUgc2NyaXB0IGFuZCByZXNvbHZlIHRoZSBwcm9taXNlLlxuICogICAgICAgICAgICAgICAgVGhlIGZ1bmN0aW9uIGRvZXNuJ3QgcmVzb2x2ZSBhbnkgdmFsdWUsXG4gKiAgICAgICAgICAgICAgICB0aGlzIGlzIG5vdCBhIFVNRCBsb2FkZXIgd2hlcmUgeW91IGNhbiBnZXQgeW91ciBsaWJyYXJ5IG5hbWUgYmFjay5cbiAqIEBwYXJhbSBzY3JpcHRVUkwge3N0cmluZ31cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhfdGltZW91dF9tcyAtIFRpbWUgdG8gZWxhcHNlIGJlZm9yZSBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcGFyYW0gaXNBbHJlYWR5TG9hZGVkIHtib29sZWFufSBpZiB0cnVlLCB0aGUgbG9hZFNjcmlwdCByZXNvbHZlcyBpbW1lZGlhdGVseVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBpcyB1c2VkIGZvciBtdWx0aXBsZSBpbnZvY2F0aW9ucyAtIHByZXZlbnRzIHRoZSBzY3JpcHQgZnJvbSBiZWluZyBsb2FkZWQgbXVsdGlwbGUgdGltZXNcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55IHwge3N0YXR1czpzdHJpbmcsIG1lc3NhZ2U6c3RyaW5nfT59XG4gKi9cbmZ1bmN0aW9uIGxvYWRTY3JpcHQoc2NyaXB0VVJMLCBtYXhfdGltZW91dF9tcywgaXNBbHJlYWR5TG9hZGVkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGlzQWxyZWFkeUxvYWRlZCkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRUYWcuc3JjID0gc2NyaXB0VVJMO1xuICAgICAgdmFyIHRpbWVySUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogXCJUaW1lb3V0IGxvYWRpbmcgc2NyaXB0IFwiLmNvbmNhdChzY3JpcHRVUkwpXG4gICAgICAgIH0pO1xuICAgICAgfSwgbWF4X3RpbWVvdXRfbXMpOyAvLyAxMCBzZWNvbmRzIGZvciB0aW1lb3V0XG5cbiAgICAgIHNjcmlwdFRhZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7IC8vIGNsZWFyIHRpbWVvdXQgcmVqZWN0IGVycm9yXG5cbiAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogXCJFcnJvciBsb2FkaW5nIFwiLmNvbmNhdChzY3JpcHRVUkwpXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgc2NyaXB0VGFnLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpOyAvLyBjbGVhciB0aW1lb3V0IHJlamVjdCBlcnJvclxuXG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG5cbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0VGFnKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJfbG9hZFNjcmlwdCA9IChsb2FkU2NyaXB0KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwveGhyL2dldEJsb2JGcm9tVVJMLmpzXG4vKipcbiAqIFJlamVjdCBvbiB0aW1lb3V0XG4gKiBAcGFyYW0gbWF4VGltZW91dE1TXG4gKiBAcGFyYW0gcmVqZWN0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aW1lcklEXG4gKi9cbmZ1bmN0aW9uIHJlamVjdE9uVGltZW91dChtYXhUaW1lb3V0TVMsIHJlamVjdCkge1xuICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmVqZWN0KHtcbiAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgIG1lc3NhZ2U6ICdUaW1lb3V0IGxvYWRpbmcgQmxvYiBVUkwnXG4gICAgfSk7XG4gIH0sIG1heFRpbWVvdXRNUyk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDb252ZXJ0cyBhIFVSTCB0byBhIEJMT0IgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsVG9Mb2FkXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4X3RpbWVvdXRfbXMgLSBUaW1lIHRvIGVsYXBzZSBiZWZvcmUgcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybiB7UHJvbWlzZTx7XG4gKiAgIHN0YXR1czogJ3N1Y2Nlc3MnIHwgJ2Vycm9yJ1xuICogICBtZXNzYWdlPzogc3RyaW5nLFxuICogICAgcGF5bG9hZDoge1xuICogICAgICB1cmw6IHN0cmluZ1xuICogICAgfVxuICogfT59XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRCbG9iRnJvbVVSTCh1cmxUb0xvYWQsIG1heFRpbWVvdXRNUykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB0aW1lcklEID0gcmVqZWN0T25UaW1lb3V0KG1heFRpbWVvdXRNUywgcmVqZWN0KTsgLy8gSWYgZmV0Y2ggZXhpc3RzLCB1c2UgaXQgdG8gZmV0Y2ggYmxvYiwgb3RoZXJ3aXNlIHVzZSBYSFIuXG4gICAgLy8gWEhSIGNhdXNlcyBpc3N1ZXMgb24gc2FmYXJpIDE0LjEgc28gd2UgcHJlZmVyIGZldGNoXG5cbiAgICB2YXIgZmV0Y2hCbG9iID0gdHlwZW9mIGZldGNoICE9PSAndW5kZWZpbmVkJyAmJiBmZXRjaCA/IGxvYWRVcmxVc2luZ0ZldGNoIDogbG9hZFVybFVzaW5nWGhyO1xuICAgIGZldGNoQmxvYih1cmxUb0xvYWQpLnRoZW4oZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgIHJlc29sdmUoe1xuICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGJsb2JVUkw6IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdFcnJvciBsb2FkaW5nIEJsb2IgVVJMJ1xuICAgICAgfSk7XG4gICAgfSlbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIENsZWFyIHRoZSB0aW1lb3V0IHRpbWVyIG9uIGZhaWwgb3Igc3VjY2Vzcy5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIFVzZSBmZXRjaCBmdW5jdGlvbiB0byBmZXRjaCBmaWxlXG4gKiBAcGFyYW0gdXJsVG9Mb2FkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWRVcmxVc2luZ0ZldGNoKHVybFRvTG9hZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZldGNoKHVybFRvTG9hZCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJlc3BvbnNlLmJsb2IoKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgICB9KTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdCgnZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIFVzZSBYSFIgdG8gZmV0Y2ggZmlsZVxuICogQHBhcmFtIHVybFRvTG9hZFxuICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkVXJsVXNpbmdYaHIodXJsVG9Mb2FkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICByZXNvbHZlKHhoci5yZXNwb25zZSk7XG4gICAgfTtcblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KCdlcnJvcicpO1xuICAgIH07XG5cbiAgICB4aHIub3BlbignR0VUJywgdXJsVG9Mb2FkLCB0cnVlKTtcbiAgICB4aHIuc2VuZCgpO1xuICB9KTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhyX2dldEJsb2JGcm9tVVJMID0gKGdldEJsb2JGcm9tVVJMKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9jcmVhdGVIaWRkZW5WaWRlb1RhZy5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIGhpZGRlbiBIVE1MVmlkZW9FbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCB2aWRlb09wdGlvbnNcbiAqIEBwYXJhbSB7e2F1dG9wbGF5LCBwbGF5c2lubGluZSwgbG9vcCwgbXV0ZWQsIHBvc3RlciwgYmxvYlVSTCwgdmlkZW9VUkwgfX0gdmlkZW9PcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZpZGVvT3B0aW9ucy5hdXRvcGxheSAtIGF1dG9wbGF5cyB0aGUgdmlkZW8gaWYgdHJ1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZpZGVvT3B0aW9ucy5ibG9iVVJMIC0gdGhlIGJsb2JVUkwgdG8gc2V0IGFzIHZpZGVvLnNyY1xuICogQHBhcmFtIHtzdHJpbmd9IHZpZGVvT3B0aW9ucy52aWRlb1VSTCAtIHRoZSBvcmlnaW5hbCB2aWRlb1VSTCB0aGUgdXNlciBjcmVhdGVkICh3aXRoIHRyYW5zZm9ybWF0aW9ucylcbiAqIEByZXR1cm4ge0hUTUxWaWRlb0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhpZGRlblZpZGVvVGFnKHZpZGVvT3B0aW9ucykge1xuICB2YXIgYXV0b3BsYXkgPSB2aWRlb09wdGlvbnMuYXV0b3BsYXksXG4gICAgICBwbGF5c2lubGluZSA9IHZpZGVvT3B0aW9ucy5wbGF5c2lubGluZSxcbiAgICAgIGxvb3AgPSB2aWRlb09wdGlvbnMubG9vcCxcbiAgICAgIG11dGVkID0gdmlkZW9PcHRpb25zLm11dGVkLFxuICAgICAgcG9zdGVyID0gdmlkZW9PcHRpb25zLnBvc3RlcixcbiAgICAgIGJsb2JVUkwgPSB2aWRlb09wdGlvbnMuYmxvYlVSTCxcbiAgICAgIHZpZGVvVVJMID0gdmlkZW9PcHRpb25zLnZpZGVvVVJMO1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIGVsLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZWwueCA9IDA7XG4gIGVsLnkgPSAwO1xuICBlbC5zcmMgPSBibG9iVVJMO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmlkZW8tdXJsJywgdmlkZW9VUkwpOyAvLyBmb3IgZGVidWdnaW5nL3Rlc3RpbmdcblxuICBhdXRvcGxheSAmJiBlbC5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgYXV0b3BsYXkpO1xuICBwbGF5c2lubGluZSAmJiBlbC5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgcGxheXNpbmxpbmUpO1xuICBsb29wICYmIGVsLnNldEF0dHJpYnV0ZSgnbG9vcCcsIGxvb3ApO1xuICBtdXRlZCAmJiBlbC5zZXRBdHRyaWJ1dGUoJ211dGVkJywgbXV0ZWQpO1xuICBtdXRlZCAmJiAoZWwubXV0ZWQgPSBtdXRlZCk7IC8vIHRoaXMgaXMgYWxzbyBuZWVkZWQgZm9yIGF1dG9wbGF5LCBvbiB0b3Agb2Ygc2V0QXR0cmlidXRlXG5cbiAgcG9zdGVyICYmIGVsLnNldEF0dHJpYnV0ZSgncG9zdGVyJywgcG9zdGVyKTsgLy8gRnJlZSBtZW1vcnkgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZSBsb2FkaW5nLlxuXG4gIGVsLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICB9O1xuXG4gIHJldHVybiBlbDtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19jcmVhdGVIaWRkZW5WaWRlb1RhZyA9IChjcmVhdGVIaWRkZW5WaWRlb1RhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vaW5zdGFudGlhdGVTZWVUaHJ1LmpzXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgaW5zdGFuYyBlb2Ygc2VlVGhydSAoc2VlVGhydS5jcmVhdGUoKSkgYW5kIHJldHVybnMgYSBwcm9taXNlIG9mIHRoZSBzZWVUaHJ1IGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnR9IHZpZGVvRWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IG1heF90aW1lb3V0X21zIC0gVGltZSB0byBlbGFwc2UgYmVmb3JlIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXN0b21DbGFzcyAtIEEgY2xhc3NuYW1lIHRvIGJlIGFkZGVkIHRvIHRoZSBjYW52YXMgZWxlbWVudCBjcmVhdGVkIGJ5IHNlZVRocnVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b1BsYXlcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn0gU2VlVGhydSBpbnN0YW5jZSBvciByZWplY3Rpb24gZXJyb3JcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVTZWVUaHJ1KHZpZGVvRWxlbWVudCwgbWF4X3RpbWVvdXRfbXMsIGN1c3RvbUNsYXNzLCBhdXRvUGxheSkge1xuICB2YXIgX3dpbmRvdyA9IHdpbmRvdyxcbiAgICAgIHNlZVRocnUgPSBfd2luZG93LnNlZVRocnUsXG4gICAgICBzZXRUaW1lb3V0ID0gX3dpbmRvdy5zZXRUaW1lb3V0LFxuICAgICAgY2xlYXJUaW1lb3V0ID0gX3dpbmRvdy5jbGVhclRpbWVvdXQ7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHRpbWVySUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdCh7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgbWVzc2FnZTogJ1RpbWVvdXQgaW5zdGFudGlhdGluZyBzZWVUaHJ1IGluc3RhbmNlJ1xuICAgICAgfSk7XG4gICAgfSwgbWF4X3RpbWVvdXRfbXMpO1xuXG4gICAgaWYgKHNlZVRocnUpIHtcbiAgICAgIHZhciBzZWVUaHJ1SW5zdGFuY2UgPSBzZWVUaHJ1LmNyZWF0ZSh2aWRlb0VsZW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2xlYXIgdGltZW91dCByZWplY3QgZXJyb3JcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpOyAvLyBmb3JjZSBjb250YWluZXIgd2lkdGgsIGVsc2UgdGhlIGNhbnZhcyBjYW4gb3ZlcmZsb3cgb3V0XG5cbiAgICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSBzZWVUaHJ1SW5zdGFuY2UuZ2V0Q2FudmFzKCk7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuY2xhc3NOYW1lICs9ICcgJyArIGN1c3RvbUNsYXNzOyAvLyBzdGFydCB0aGUgdmlkZW8gaWYgYXV0b3BsYXkgaXMgc2V0XG5cbiAgICAgICAgaWYgKGF1dG9QbGF5KSB7XG4gICAgICAgICAgc2VlVGhydUluc3RhbmNlLnBsYXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoc2VlVGhydUluc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdFcnJvciBpbnN0YW50aWF0aW5nIHNlZVRocnUgaW5zdGFuY2UnXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX2luc3RhbnRpYXRlU2VlVGhydSA9IChpbnN0YW50aWF0ZVNlZVRocnUpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL21vdW50U2VlVGhydUNhbnZhc1RhZy5qc1xuXG5cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sRWxDb250YWluZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb1VSTFxuICogQHBhcmFtIHtUcmFuc2Zvcm1hdGlvbk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuXG5mdW5jdGlvbiBtb3VudFNlZVRocnVDYW52YXNUYWcoaHRtbEVsQ29udGFpbmVyLCB2aWRlb1VSTCwgb3B0aW9ucykge1xuICB2YXIgcG9zdGVyID0gb3B0aW9ucy5wb3N0ZXIsXG4gICAgICBhdXRvcGxheSA9IG9wdGlvbnMuYXV0b3BsYXksXG4gICAgICBwbGF5c2lubGluZSA9IG9wdGlvbnMucGxheXNpbmxpbmUsXG4gICAgICBsb29wID0gb3B0aW9ucy5sb29wLFxuICAgICAgbXV0ZWQgPSBvcHRpb25zLm11dGVkO1xuICB2aWRlb1VSTCA9IHZpZGVvVVJMICsgJy5tcDQnOyAvLyBzZWVUaHJ1IGFsd2F5cyB1c2VzIG1wNFxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgeGhyX2xvYWRTY3JpcHQob3B0aW9ucy5leHRlcm5hbExpYnJhcmllcy5zZWVUaHJ1LCBvcHRpb25zLm1heF90aW1lb3V0X21zLCB3aW5kb3cuc2VlVGhydSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB4aHJfZ2V0QmxvYkZyb21VUkwodmlkZW9VUkwsIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBfcmVmLnBheWxvYWQ7XG4gICAgICAgIHZhciB2aWRlb0VsZW1lbnQgPSB0cmFuc3BhcmVudFZpZGVvX2NyZWF0ZUhpZGRlblZpZGVvVGFnKHtcbiAgICAgICAgICBibG9iVVJMOiBwYXlsb2FkLmJsb2JVUkwsXG4gICAgICAgICAgdmlkZW9VUkw6IHZpZGVvVVJMLFxuICAgICAgICAgIC8vIGZvciBkZWJ1Z2dpbmcvdGVzdGluZ1xuICAgICAgICAgIHBvc3RlcjogcG9zdGVyLFxuICAgICAgICAgIGF1dG9wbGF5OiBhdXRvcGxheSxcbiAgICAgICAgICBwbGF5c2lubGluZTogcGxheXNpbmxpbmUsXG4gICAgICAgICAgbG9vcDogbG9vcCxcbiAgICAgICAgICBtdXRlZDogbXV0ZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGh0bWxFbENvbnRhaW5lci5hcHBlbmRDaGlsZCh2aWRlb0VsZW1lbnQpO1xuICAgICAgICB0cmFuc3BhcmVudFZpZGVvX2luc3RhbnRpYXRlU2VlVGhydSh2aWRlb0VsZW1lbnQsIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMsIG9wdGlvbnNbXCJjbGFzc1wiXSwgb3B0aW9ucy5hdXRvcGxheSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShodG1sRWxDb250YWluZXIpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7IC8vIGNhdGNoIGZvciBnZXRCbG9iRnJvbVVSTCgpXG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgc3RhdHVzID0gX3JlZjIuc3RhdHVzLFxuICAgICAgICAgICAgbWVzc2FnZSA9IF9yZWYyLm1lc3NhZ2U7XG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBjYXRjaCBmb3IgbG9hZFNjcmlwdCgpXG4gICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBzdGF0dXMgPSBfcmVmMy5zdGF0dXMsXG4gICAgICAgICAgbWVzc2FnZSA9IF9yZWYzLm1lc3NhZ2U7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX21vdW50U2VlVGhydUNhbnZhc1RhZyA9IChtb3VudFNlZVRocnVDYW52YXNUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL2NoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeS5qc1xuLyoqXG4gKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fSAtIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHJhbnNwYXJlbnQgdmlkZW9zIG9yIG5vdFxuICovXG5cblxuZnVuY3Rpb24gY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5KCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIFJlc29sdmUgZWFybHkgZm9yIHNhZmFyaS5cbiAgICAvLyBDdXJyZW50bHkgKDI5IERlY2VtYmVyIDIwMjEpIFNhZmFyaSBjYW4gcGxheSB3ZWJtL3ZwOSxcbiAgICAvLyBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydCB0cmFuc3BhcmVudCB2aWRlbyBpbiB0aGUgZm9ybWF0IHdlJ3JlIG91dHB1dHRpbmdcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB2YXIgY2FuUGxheSA9IHZpZGVvLmNhblBsYXlUeXBlICYmIHZpZGVvLmNhblBsYXlUeXBlKCd2aWRlby93ZWJtOyBjb2RlY3M9XCJ2cDlcIicpO1xuICAgIHJlc29sdmUoY2FuUGxheSA9PT0gJ21heWJlJyB8fCBjYW5QbGF5ID09PSAncHJvYmFibHknKTtcbiAgfSk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9fY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5ID0gKGNoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jbG91ZGluYXJ5LmpzXG5mdW5jdGlvbiBjbG91ZGluYXJ5X2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gY2xvdWRpbmFyeV9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gY2xvdWRpbmFyeV9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGNsb3VkaW5hcnlfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGNsb3VkaW5hcnlfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXG52YXIgYXBwbHlCcmVha3BvaW50cywgY2xvc2VzdEFib3ZlLCBkZWZhdWx0QnJlYWtwb2ludHMsIGNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoLCBjbG91ZGluYXJ5X21heFdpZHRoLCB1cGRhdGVEcHI7XG5cblxuXG5cblxuXG5cblxuXG4gLy9cblxuXG5cblxuXG5cbmRlZmF1bHRCcmVha3BvaW50cyA9IGZ1bmN0aW9uIGRlZmF1bHRCcmVha3BvaW50cyh3aWR0aCkge1xuICB2YXIgc3RlcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDtcbiAgcmV0dXJuIHN0ZXBzICogTWF0aC5jZWlsKHdpZHRoIC8gc3RlcHMpO1xufTtcblxuY2xvc2VzdEFib3ZlID0gZnVuY3Rpb24gY2xvc2VzdEFib3ZlKGxpc3QsIHZhbHVlKSB7XG4gIHZhciBpO1xuICBpID0gbGlzdC5sZW5ndGggLSAyO1xuXG4gIHdoaWxlIChpID49IDAgJiYgbGlzdFtpXSA+PSB2YWx1ZSkge1xuICAgIGktLTtcbiAgfVxuXG4gIHJldHVybiBsaXN0W2kgKyAxXTtcbn07XG5cbmFwcGx5QnJlYWtwb2ludHMgPSBmdW5jdGlvbiBhcHBseUJyZWFrcG9pbnRzKHRhZywgd2lkdGgsIHN0ZXBzLCBvcHRpb25zKSB7XG4gIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzO1xuICByZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyA9IChyZWYgPSAocmVmMSA9IChyZWYyID0gb3B0aW9uc1sncmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMnXSkgIT0gbnVsbCA/IHJlZjIgOiBvcHRpb25zWydyZXNwb25zaXZlX3VzZV9zdG9wcG9pbnRzJ10pICE9IG51bGwgPyByZWYxIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzJykpICE9IG51bGwgPyByZWYgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV91c2Vfc3RvcHBvaW50cycpO1xuXG4gIGlmICghcmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMgfHwgcmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMgPT09ICdyZXNpemUnICYmICFvcHRpb25zLnJlc2l6aW5nKSB7XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmNhbGNfYnJlYWtwb2ludCh0YWcsIHdpZHRoLCBzdGVwcyk7XG4gIH1cbn07XG5cbmNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoID0gZnVuY3Rpb24gZmluZENvbnRhaW5lcldpZHRoKGVsZW1lbnQpIHtcbiAgdmFyIGNvbnRhaW5lcldpZHRoLCBzdHlsZTtcbiAgY29udGFpbmVyV2lkdGggPSAwO1xuXG4gIHdoaWxlICgoZWxlbWVudCA9IGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQucGFyZW50Tm9kZSA6IHZvaWQgMCkgaW5zdGFuY2VvZiBFbGVtZW50ICYmICFjb250YWluZXJXaWR0aCkge1xuICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoIS9eaW5saW5lLy50ZXN0KHN0eWxlLmRpc3BsYXkpKSB7XG4gICAgICBjb250YWluZXJXaWR0aCA9IGxvZGFzaF93aWR0aChlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyV2lkdGg7XG59O1xuXG51cGRhdGVEcHIgPSBmdW5jdGlvbiB1cGRhdGVEcHIoZGF0YVNyYywgcm91bmREcHIpIHtcbiAgcmV0dXJuIGRhdGFTcmMucmVwbGFjZSgvXFxiZHByXygxXFwuMHxhdXRvKVxcYi9nLCAnZHByXycgKyB0aGlzLmRldmljZV9waXhlbF9yYXRpbyhyb3VuZERwcikpO1xufTtcblxuY2xvdWRpbmFyeV9tYXhXaWR0aCA9IGZ1bmN0aW9uIG1heFdpZHRoKHJlcXVpcmVkV2lkdGgsIHRhZykge1xuICB2YXIgaW1hZ2VXaWR0aDtcbiAgaW1hZ2VXaWR0aCA9IGxvZGFzaF9nZXREYXRhKHRhZywgJ3dpZHRoJykgfHwgMDtcblxuICBpZiAocmVxdWlyZWRXaWR0aCA+IGltYWdlV2lkdGgpIHtcbiAgICBpbWFnZVdpZHRoID0gcmVxdWlyZWRXaWR0aDtcbiAgICBsb2Rhc2hfc2V0RGF0YSh0YWcsICd3aWR0aCcsIHJlcXVpcmVkV2lkdGgpO1xuICB9XG5cbiAgcmV0dXJuIGltYWdlV2lkdGg7XG59O1xuXG52YXIgY2xvdWRpbmFyeV9DbG91ZGluYXJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQ2xvdWRpbmFyeSBpbnN0YW5jZS5cbiAgICogQGNsYXNzIENsb3VkaW5hcnlcbiAgICogQGNsYXNzZGVzYyBNYWluIGNsYXNzIGZvciBhY2Nlc3NpbmcgQ2xvdWRpbmFyeSBmdW5jdGlvbmFsaXR5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEEge0BsaW5rIENvbmZpZ3VyYXRpb259IG9iamVjdCBmb3IgZ2xvYmFsbHkgY29uZmlndXJpbmcgQ2xvdWRpbmFyeSBhY2NvdW50IHNldHRpbmdzLlxuICAgKiBAZXhhbXBsZTxici8+XG4gICAqICB2YXIgY2wgPSBuZXcgY2xvdWRpbmFyeS5DbG91ZGluYXJ5KCB7IGNsb3VkX25hbWU6IFwibXljbG91ZFwifSk7PGJyLz5cbiAgICogIHZhciBpbWdUYWcgPSBjbC5pbWFnZShcIm15UGljSURcIik7XG4gICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICogIEF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAqL1xuICBmdW5jdGlvbiBDbG91ZGluYXJ5KG9wdGlvbnMpIHtcbiAgICBjbG91ZGluYXJ5X2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsb3VkaW5hcnkpO1xuXG4gICAgdmFyIGNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmVDb25maWcgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGNvbmZpZ3VyYXRpb24gPSBuZXcgc3JjX2NvbmZpZ3VyYXRpb24ob3B0aW9ucyk7IC8vIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgICB0aGlzLmNvbmZpZyA9IGZ1bmN0aW9uIChuZXdDb25maWcsIG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbi5jb25maWcobmV3Q29uZmlnLCBuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgXFw8bWV0YVxcPiB0YWdzIGluIHRoZSBkb2N1bWVudCB0byBjb25maWd1cmUgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybiBUaGlzIHtDbG91ZGluYXJ5fSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG5cblxuICAgIHRoaXMuZnJvbURvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uZmlndXJhdGlvbi5mcm9tRG9jdW1lbnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byBjb25maWd1cmUgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybiBUaGlzIHtDbG91ZGluYXJ5fSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG5cblxuICAgIHRoaXMuZnJvbUVudmlyb25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uZmlndXJhdGlvbi5mcm9tRW52aXJvbm1lbnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdGhhdCBpbnZva2VzIGJvdGgge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50fGZyb21FbnZpcm9ubWVudCgpfVxuICAgICAqICAoTm9kZS5qcyBlbnZpcm9ubWVudCBvbmx5KSBhbmQge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbURvY3VtZW50fGZyb21Eb2N1bWVudCgpfS5cbiAgICAgKiAgSXQgZmlyc3QgdHJpZXMgdG8gcmV0cmlldmUgdGhlIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAgICogIElmIG5vdCBhdmFpbGFibGUsIGl0IHRyaWVzIGZyb20gdGhlIGRvY3VtZW50IG1ldGEgdGFncy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNpbml0XG4gICAgICogQHNlZSBDb25maWd1cmF0aW9uI2luaXRcbiAgICAgKiBAcmV0dXJuIFRoaXMge0Nsb3VkaW5hcnl9IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cblxuXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uZmlndXJhdGlvbi5pbml0KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtDbG91ZGluYXJ5fVxuICAgKiBAZXhhbXBsZSBjbCA9IGNsb3VkaW5hcnkuQ2xvdWRpbmFyeS5uZXcoIHsgY2xvdWRfbmFtZTogXCJteWNsb3VkXCJ9KVxuICAgKi9cblxuXG4gIGNsb3VkaW5hcnlfY3JlYXRlQ2xhc3MoQ2xvdWRpbmFyeSwgW3tcbiAgICBrZXk6IFwidXJsXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgVVJMIGZvciBhbnkgYXNzZXQgaW4geW91ciBNZWRpYSBsaWJyYXJ5LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3VybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIG1lZGlhIGFzc2V0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAgICAgKiBAcGFyYW0ge3R5cGV9IFtvcHRpb25zLnR5cGU9J3VwbG9hZCddIC0gVGhlIGFzc2V0J3Mgc3RvcmFnZSB0eXBlLlxuICAgICAqICBGb3IgZGV0YWlscyBvbiBhbGwgZmV0Y2ggdHlwZXMsIHNlZVxuICAgICAqIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25zI2ZldGNoaW5nX2ltYWdlc19mcm9tX3JlbW90ZV9sb2NhdGlvbnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5GZXRjaCB0eXBlczwvYT4uXG4gICAgICogQHBhcmFtIHtyZXNvdXJjZVR5cGV9IFtvcHRpb25zLnJlc291cmNlX3R5cGU9J2ltYWdlJ10gLSBUaGUgdHlwZSBvZiBhc3NldC4gUG9zc2libGUgdmFsdWVzOjxici8+XG4gICAgICogIC0gYGltYWdlYDxici8+XG4gICAgICogIC0gYHZpZGVvYDxici8+XG4gICAgICogIC0gYHJhd2BcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtZWRpYSBhc3NldCBVUkwuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cmwocHVibGljSWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiB1cmxfdXJsKHB1YmxpY0lkLCBvcHRpb25zLCB0aGlzLmNvbmZpZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdmlkZW8gYXNzZXQgVVJMLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvX3VybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAgICAgKiBAcGFyYW0ge3R5cGV9IFtvcHRpb25zLnR5cGU9J3VwbG9hZCddIC0gVGhlIGFzc2V0J3Mgc3RvcmFnZSB0eXBlLlxuICAgICAqICBGb3IgZGV0YWlscyBvbiBhbGwgZmV0Y2ggdHlwZXMsIHNlZVxuICAgICAqICA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9ucyNmZXRjaGluZ19pbWFnZXNfZnJvbV9yZW1vdGVfbG9jYXRpb25zXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmV0Y2ggdHlwZXM8L2E+LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZpZGVvIFVSTC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvX3VybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb191cmwocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJ1xuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBVUkwgZm9yIGFuIGltYWdlIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgYSB0aHVtYm5haWwgZm9yIHRoZSBzcGVjaWZpZWQgdmlkZW8uXG4gICAgICogIElkZW50aWNhbCB0byB7QGxpbmsgQ2xvdWRpbmFyeSN1cmx8dXJsfSwgZXhjZXB0IHRoYXQgdGhlIGByZXNvdXJjZV90eXBlYCBpcyBgdmlkZW9gXG4gICAgICogIGFuZCB0aGUgZGVmYXVsdCBgZm9ybWF0YCBpcyBganBnYC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb190aHVtYm5haWxfdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdmlkZW8gZnJvbSB3aGljaCB5b3Ugd2FudCB0byBnZW5lcmF0ZSBhIHRodW1ibmFpbCBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIGltYWdlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBhcHBseSB0byB0aGUgdGh1bWJuYWlsLlxuICAgICAqIEluIGFkZGl0aW9uIHRvIHN0YW5kYXJkIGltYWdlIHRyYW5zZm9ybWF0aW9ucywgeW91IGNhbiBhbHNvIHVzZSB0aGUgYHN0YXJ0X29mZnNldGAgdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVyXG4gICAgICogdG8gaW5zdHJ1Y3QgQ2xvdWRpbmFyeSB0byBnZW5lcmF0ZSB0aGUgdGh1bWJuYWlsIGZyb20gYSBmcmFtZSBvdGhlciB0aGFuIHRoZSBtaWRkbGUgZnJhbWUgb2YgdGhlIHZpZGVvLlxuICAgICAqIEZvciBkZXRhaWxzLCBzZWVcbiAgICAgKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX21hbmlwdWxhdGlvbl9hbmRfZGVsaXZlcnkjZ2VuZXJhdGluZ192aWRlb190aHVtYm5haWxzXCJcbiAgICAgKiB0YXJnZXQ9XCJfYmxhbmtcIj5HZW5lcmF0aW5nIHZpZGVvIHRodW1ibmFpbHM8L2E+IGluIHRoZSBDbG91ZGluYXJ5IGRvY3VtZW50YXRpb24uXG4gICAgICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIHZpZGVvIHRodW1ibmFpbCBpbWFnZS5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb190aHVtYm5haWxfdXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvX3RodW1ibmFpbF91cmwocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHt9LCBERUZBVUxUX1BPU1RFUl9PUFRJT05TLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnVybChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnMuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHJhbnNmb3JtYXRpb25fc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmFuc2Zvcm1hdGlvbiBzdHJpbmcuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybWF0aW9uX3N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9zdHJpbmcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBzcmNfdHJhbnNmb3JtYXRpb24ob3B0aW9ucykuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBpbWFnZSB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBET00gZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbWFnZShwdWJsaWNJZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNsaWVudF9oaW50cywgaW1nLCByZWY7XG4gICAgICBpbWcgPSB0aGlzLmltYWdlVGFnKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICAgIGNsaWVudF9oaW50cyA9IChyZWYgPSBvcHRpb25zLmNsaWVudF9oaW50cyAhPSBudWxsID8gb3B0aW9ucy5jbGllbnRfaGludHMgOiB0aGlzLmNvbmZpZygnY2xpZW50X2hpbnRzJykpICE9IG51bGwgPyByZWYgOiBmYWxzZTtcblxuICAgICAgaWYgKG9wdGlvbnMuc3JjID09IG51bGwgJiYgIWNsaWVudF9oaW50cykge1xuICAgICAgICAvLyBzcmMgbXVzdCBiZSByZW1vdmVkIGJlZm9yZSBjcmVhdGluZyB0aGUgRE9NIGVsZW1lbnQgdG8gYXZvaWQgbG9hZGluZyB0aGUgaW1hZ2VcbiAgICAgICAgaW1nLnNldEF0dHIoXCJzcmNcIiwgJycpO1xuICAgICAgfVxuXG4gICAgICBpbWcgPSBpbWcudG9ET00oKTtcblxuICAgICAgaWYgKCFjbGllbnRfaGludHMpIHtcbiAgICAgICAgLy8gY2FjaGUgdGhlIGltYWdlIHNyY1xuICAgICAgICBsb2Rhc2hfc2V0RGF0YShpbWcsICdzcmMtY2FjaGUnLCB0aGlzLnVybChwdWJsaWNJZCwgb3B0aW9ucykpOyAvLyBzZXQgaW1hZ2Ugc3JjIHRha2luZyByZXNwb25zaXZlbmVzcyBpbiBhY2NvdW50XG5cbiAgICAgICAgdGhpcy5jbG91ZGluYXJ5X3VwZGF0ZShpbWcsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW1nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEltYWdlVGFnIGluc3RhbmNlIHVzaW5nIHRoZSBjb25maWd1cmF0aW9uIGRlZmluZWQgZm9yIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2ltYWdlVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0ltYWdlVGFnfSBBbiBJbWFnZVRhZyBpbnN0YW5jZSB0aGF0IGlzIGF0dGFjaGVkIChjaGFpbmVkKSB0byB0aGlzIENsb3VkaW5hcnkgaW5zdGFuY2UuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW1hZ2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW1hZ2VUYWcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0YWc7XG4gICAgICB0YWcgPSBuZXcgaW1hZ2V0YWcocHVibGljSWQsIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdGFnLnRyYW5zZm9ybWF0aW9uKCkuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBpY3R1cmVUYWcgaW5zdGFuY2UsIGNvbmZpZ3VyZWQgdXNpbmcgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjUGljdHVyZVRhZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIHRoZSBwdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbmV3IEltYWdlVGFnIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBzb3VyY2VzIC0gdGhlIHNvdXJjZXMgZGVmaW5pdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQaWN0dXJlVGFnfSBBIFBpY3R1cmVUYWcgdGhhdCBpcyBhdHRhY2hlZCAoY2hhaW5lZCkgdG8gdGhpcyBDbG91ZGluYXJ5IGluc3RhbmNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwaWN0dXJlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBpY3R1cmVUYWcocHVibGljSWQsIG9wdGlvbnMsIHNvdXJjZXMpIHtcbiAgICAgIHZhciB0YWc7XG4gICAgICB0YWcgPSBuZXcgcGljdHVyZXRhZyhwdWJsaWNJZCwgdGhpcy5jb25maWcoKSwgc291cmNlcyk7XG4gICAgICB0YWcudHJhbnNmb3JtYXRpb24oKS5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU291cmNlVGFnIGluc3RhbmNlLCBjb25maWd1cmVkIHVzaW5nIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I1NvdXJjZVRhZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIHRoZSBwdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIG5ldyBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtTb3VyY2VUYWd9IEEgU291cmNlVGFnIHRoYXQgaXMgYXR0YWNoZWQgKGNoYWluZWQpIHRvIHRoaXMgQ2xvdWRpbmFyeSBpbnN0YW5jZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic291cmNlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvdXJjZVRhZyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHRhZztcbiAgICAgIHRhZyA9IG5ldyBzb3VyY2V0YWcocHVibGljSWQsIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdGFnLnRyYW5zZm9ybWF0aW9uKCkuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB2aWRlbyB0aHVtYm5haWwgVVJMIGZyb20gdGhlIHNwZWNpZmllZCByZW1vdGUgdmlkZW8gYW5kIGluY2x1ZGVzIGl0IGluIGFuIGltYWdlIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb190aHVtYm5haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHZpZGVvIGZyb20gdGhlIHJlbGV2YW50IHZpZGVvIHNpdGUuXG4gICAgICogIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGUgdG8gdGhlIGlkZW50aWZpZXIgdmFsdWUgb3Igc2V0XG4gICAgICogIHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgWW91VHViZSB2aWRlbyBtaWdodCBoYXZlIHRoZSBpZGVudGlmaWVyOiAnby11cm5sYUpwT0EuanBnJy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBhcHBseS5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBIVE1MIGltYWdlIHRhZyBlbGVtZW50XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9fdGh1bWJuYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvX3RodW1ibmFpbChwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKHt9LCBERUZBVUxUX1BPU1RFUl9PUFRJT05TLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBmYWNlYm9vayBwcm9maWxlIGltYWdlIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNmYWNlYm9va19wcm9maWxlX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIEZhY2Vib29rIG51bWVyaWMgSUQuIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGVcbiAgICAgKiAgdG8gdGhlIElEIG9yIHNldCB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0IGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZhY2Vib29rX3Byb2ZpbGVfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZWJvb2tfcHJvZmlsZV9pbWFnZShwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnZmFjZWJvb2snXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBUd2l0dGVyIHByb2ZpbGUgaW1hZ2UgYnkgSUQgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3R3aXR0ZXJfcHJvZmlsZV9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBUd2l0dGVyIG51bWVyaWMgSUQuIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGVcbiAgICAgKiAgdG8gdGhlIElEIG9yIHNldCB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0IGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR3aXR0ZXJfcHJvZmlsZV9pbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0d2l0dGVyX3Byb2ZpbGVfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ3R3aXR0ZXInXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBUd2l0dGVyIHByb2ZpbGUgaW1hZ2UgYnkgbmFtZSBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgVHdpdHRlciBzY3JlZW4gbmFtZS4gQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZVxuICAgICAqICB0byB0aGUgc2NyZWVuIG5hbWUgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ3R3aXR0ZXJfbmFtZSdcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIEdyYXZhdGFyIHByb2ZpbGUgaW1hZ2UgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2dyYXZhdGFyX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIGNhbGN1bGF0ZWQgaGFzaCBmb3IgdGhlIEdyYXZhdGFyIGVtYWlsIGFkZHJlc3MuXG4gICAgICogIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGUgdG8gdGhlIHNjcmVlbiBuYW1lIG9yIHNldCB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0XG4gICAgICogIGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdyYXZhdGFyX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyYXZhdGFyX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICdncmF2YXRhcidcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbiBpbWFnZSBmcm9tIGEgcmVtb3RlIFVSTCBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjZmV0Y2hfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgZnVsbCBVUkwgb2YgdGhlIGltYWdlIHRvIGZldGNoLCBpbmNsdWRpbmcgdGhlIGV4dGVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2hfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ2ZldGNoJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB2aWRlbyB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdmlkZW9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSB2aWRlby5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTFZpZGVvRWxlbWVudH0gQSB2aWRlbyB0YWcgRE9NIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW8ocHVibGljSWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiB0aGlzLnZpZGVvVGFnKHB1YmxpY0lkLCBvcHRpb25zKS50b0h0bWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWaWRlb1RhZyBpbnN0YW5jZSB1c2luZyB0aGUgY29uZmlndXJhdGlvbiBkZWZpbmVkIGZvciB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb1RhZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7VmlkZW9UYWd9IEEgVmlkZW9UYWcgdGhhdCBpcyBhdHRhY2hlZCAoY2hhaW5lZCkgdG8gdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9UYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9UYWcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgdGhpcy5jb25maWcoKSk7XG4gICAgICByZXR1cm4gbmV3IHZpZGVvdGFnKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgc3ByaXRlIFBORyBpbWFnZSB0aGF0IGNvbnRhaW5zIGFsbCBpbWFnZXMgd2l0aCB0aGUgc3BlY2lmaWVkIHRhZyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgY3NzIGZpbGUuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjc3ByaXRlX2Nzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSB0YWcgb24gd2hpY2ggdG8gYmFzZSB0aGUgc3ByaXRlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIGdlbmVyYXRlZCBDU1MgZmlsZS4gVGhlIHNwcml0ZSBpbWFnZSBoYXMgdGhlIHNhbWUgVVJMLCBidXQgd2l0aCBhIFBORyBleHRlbnNpb24uXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3Nwcml0ZV9nZW5lcmF0aW9uXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIFNwcml0ZSBnZW5lcmF0aW9uPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNwcml0ZV9jc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ByaXRlX2NzcyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnc3ByaXRlJ1xuICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICghcHVibGljSWQubWF0Y2goLy5jc3MkLykpIHtcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSAnY3NzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudXJsKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgcmVzcG9uc2l2ZSBpbWFnZSBiZWhhdmlvciBmb3IgYWxsIGltYWdlIHRhZ3Mgd2l0aCB0aGUgJ2NsZC1yZXNwb25zaXZlJ1xuICAgICAqICAob3Igb3RoZXIgZGVmaW5lZCB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmV9IGNsYXNzKS48YnIvPlxuICAgICAqICBUaGlzIG1ldGhvZCBzaG91bGQgYmUgaW52b2tlZCBhZnRlciB0aGUgcGFnZSBoYXMgbG9hZGVkLjxici8+XG4gICAgICogIDxiPk5vdGU8L2I+OiBDYWxscyB7QGxpbmsgQ2xvdWRpbmFyeSNjbG91ZGluYXJ5X3VwZGF0ZXxjbG91ZGluYXJ5X3VwZGF0ZX0gdG8gbW9kaWZ5IGltYWdlIHRhZ3MuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjcmVzcG9uc2l2ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlc3BvbnNpdmVfY2xhc3M9J2NsZC1yZXNwb25zaXZlJ10gLSBBbiBhbHRlcm5hdGl2ZSBjbGFzc1xuICAgICAqICB0byBsb2NhdGUgdGhlIHJlbGV2YW50ICZsdDtpbWcmZ3Q7IHRhZ3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3BvbnNpdmVfZGVib3VuY2U9MTAwXSAtIFRoZSBkZWJvdW5jZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYm9vdHN0cmFwPXRydWVdIElmIHRydWUsIHByb2Nlc3NlcyB0aGUgJmx0O2ltZyZndDsgdGFncyBieSBjYWxsaW5nXG4gICAgICogIHtAbGluayBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlfGNsb3VkaW5hcnlfdXBkYXRlfS4gV2hlbiBmYWxzZSwgdGhlIHRhZ3MgYXJlIHByb2Nlc3NlZFxuICAgICAqICBvbmx5IGFmdGVyIGEgcmVzaXplIGV2ZW50LlxuICAgICAqIEBzZWUge0BsaW5rIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGV8Y2xvdWRpbmFyeV91cGRhdGV9IGZvciBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9yZXNwb25zaXZlX2ltYWdlcyNhdXRvbWF0aW5nX3Jlc3BvbnNpdmVfaW1hZ2VzX3dpdGhfamF2YXNjcmlwdFwiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF1dG9tYXRpbmcgcmVzcG9uc2l2ZSBpbWFnZXMgd2l0aCBKYXZhU2NyaXB0PC9hPlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSB0aGF0IHdoZW4gY2FsbGVkLCByZW1vdmVzIHRoZSByZXNpemUgRXZlbnRMaXN0ZW5lciBhZGRlZCBieSB0aGlzIGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNwb25zaXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3BvbnNpdmUob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGJvb3RzdHJhcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlc3BvbnNpdmVDbGFzcywgcmVzcG9uc2l2ZVJlc2l6ZSwgdGltZW91dDtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZUNvbmZpZyA9IG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKHRoaXMucmVzcG9uc2l2ZUNvbmZpZyB8fCB7fSwgb3B0aW9ucyk7XG4gICAgICByZXNwb25zaXZlQ2xhc3MgPSAocmVmID0gdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfY2xhc3MpICE9IG51bGwgPyByZWYgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV9jbGFzcycpO1xuXG4gICAgICBpZiAoYm9vdHN0cmFwKSB7XG4gICAgICAgIHRoaXMuY2xvdWRpbmFyeV91cGRhdGUoXCJpbWcuXCIuY29uY2F0KHJlc3BvbnNpdmVDbGFzcywgXCIsIGltZy5jbGQtaGlkcGlcIiksIHRoaXMucmVzcG9uc2l2ZUNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIHJlc3BvbnNpdmVSZXNpemUgPSAocmVmMSA9IChyZWYyID0gdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfcmVzaXplKSAhPSBudWxsID8gcmVmMiA6IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlX3Jlc2l6ZScpKSAhPSBudWxsID8gcmVmMSA6IHRydWU7XG5cbiAgICAgIGlmIChyZXNwb25zaXZlUmVzaXplICYmICF0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzaXppbmcgPSB0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuXG4gICAgICAgIHZhciBtYWtlUmVzcG9uc2l2ZSA9IGZ1bmN0aW9uIG1ha2VSZXNwb25zaXZlKCkge1xuICAgICAgICAgIHZhciBkZWJvdW5jZSwgcmVmMywgcmVmNCwgcmVzZXQsIHJ1biwgd2FpdCwgd2FpdEZ1bmM7XG4gICAgICAgICAgZGVib3VuY2UgPSAocmVmMyA9IChyZWY0ID0gX3RoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX2RlYm91bmNlKSAhPSBudWxsID8gcmVmNCA6IF90aGlzLmNvbmZpZygncmVzcG9uc2l2ZV9kZWJvdW5jZScpKSAhPSBudWxsID8gcmVmMyA6IDEwMDtcblxuICAgICAgICAgIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY2xvdWRpbmFyeV91cGRhdGUoXCJpbWcuXCIuY29uY2F0KHJlc3BvbnNpdmVDbGFzcyksIF90aGlzLnJlc3BvbnNpdmVDb25maWcpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB3YWl0RnVuYyA9IGZ1bmN0aW9uIHdhaXRGdW5jKCkge1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBydW4oKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgd2FpdCA9IGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQod2FpdEZ1bmMsIGRlYm91bmNlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGRlYm91bmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FpdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcnVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBtYWtlUmVzcG9uc2l2ZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBtYWtlUmVzcG9uc2l2ZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2NhbGNfYnJlYWtwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY19icmVha3BvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNfYnJlYWtwb2ludChlbGVtZW50LCB3aWR0aCwgc3RlcHMpIHtcbiAgICAgIHZhciBicmVha3BvaW50cyA9IGxvZGFzaF9nZXREYXRhKGVsZW1lbnQsICdicmVha3BvaW50cycpIHx8IGxvZGFzaF9nZXREYXRhKGVsZW1lbnQsICdzdG9wcG9pbnRzJykgfHwgdGhpcy5jb25maWcoJ2JyZWFrcG9pbnRzJykgfHwgdGhpcy5jb25maWcoJ3N0b3Bwb2ludHMnKSB8fCBkZWZhdWx0QnJlYWtwb2ludHM7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoYnJlYWtwb2ludHMpKSB7XG4gICAgICAgIHJldHVybiBicmVha3BvaW50cyh3aWR0aCwgc3RlcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGJyZWFrcG9pbnRzKSkge1xuICAgICAgICAgIGJyZWFrcG9pbnRzID0gYnJlYWtwb2ludHMuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQocG9pbnQpO1xuICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9zZXN0QWJvdmUoYnJlYWtwb2ludHMsIHdpZHRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjY2FsY19zdG9wcG9pbnRcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGNhbGNfYnJlYWtwb2ludH0gaW5zdGVhZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbGNfc3RvcHBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNfc3RvcHBvaW50KGVsZW1lbnQsIHdpZHRoLCBzdGVwcykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsY19icmVha3BvaW50KGVsZW1lbnQsIHdpZHRoLCBzdGVwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2RldmljZV9waXhlbF9yYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXZpY2VfcGl4ZWxfcmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV2aWNlX3BpeGVsX3JhdGlvKHJvdW5kRHByKSB7XG4gICAgICByb3VuZERwciA9IHJvdW5kRHByID09IG51bGwgPyB0cnVlIDogcm91bmREcHI7XG4gICAgICB2YXIgZHByID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiB2b2lkIDApIHx8IDE7XG5cbiAgICAgIGlmIChyb3VuZERwcikge1xuICAgICAgICBkcHIgPSBNYXRoLmNlaWwoZHByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRwciA8PSAwIHx8IGRwciA9PT0gMCAvIDApIHtcbiAgICAgICAgZHByID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRwclN0cmluZyA9IGRwci50b1N0cmluZygpO1xuXG4gICAgICBpZiAoZHByU3RyaW5nLm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICBkcHJTdHJpbmcgKz0gJy4wJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRwclN0cmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBcHBsaWVzIHJlc3BvbnNpdmVuZXNzIHRvIGFsbCA8Y29kZT4mbHQ7aW1nJmd0OzwvY29kZT4gdGFncyB1bmRlciBlYWNoIHJlbGV2YW50IG5vZGVcbiAgICAqICAocmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSB0YWcgY29udGFpbnMgdGhlIHtAbGluayBDbG91ZGluYXJ5I3Jlc3BvbnNpdmV8cmVzcG9uc2l2ZX0gY2xhc3MpLlxuICAgICogQHBhcmFtIHtFbGVtZW50W119IG5vZGVzIFRoZSBwYXJlbnQgbm9kZXMgd2hlcmUgeW91IHdhbnQgdG8gc2VhcmNoIGZvciAmbHQ7aW1nJmd0OyB0YWdzLlxuICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUge0BsaW5rIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGV8Y2xvdWRpbmFyeV91cGRhdGV9IG9wdGlvbnMgdG8gYXBwbHkuXG4gICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCJcbiAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjcHJvY2Vzc0ltYWdlVGFnc1xuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzSW1hZ2VUYWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NJbWFnZVRhZ3Mobm9kZXMsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChpc0VtcHR5KG5vZGVzKSkge1xuICAgICAgICAvLyBzaW1pbGFyIHRvIGAkLmZuLmNsb3VkaW5hcnlgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMgfHwge30sIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdmFyIGltYWdlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gL15pbWckL2kudGVzdChub2RlLnRhZ05hbWUpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpbWdPcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgICAgd2lkdGg6IG5vZGUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLFxuICAgICAgICAgIGhlaWdodDogbm9kZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpLFxuICAgICAgICAgIHNyYzogbm9kZS5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgcHVibGljSWQgPSBpbWdPcHRpb25zWydzb3VyY2UnXSB8fCBpbWdPcHRpb25zWydzcmMnXTtcbiAgICAgICAgZGVsZXRlIGltZ09wdGlvbnNbJ3NvdXJjZSddO1xuICAgICAgICBkZWxldGUgaW1nT3B0aW9uc1snc3JjJ107XG4gICAgICAgIHZhciBhdHRyID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihpbWdPcHRpb25zKS50b0h0bWxBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGxvZGFzaF9zZXREYXRhKG5vZGUsICdzcmMtY2FjaGUnLCB1cmxfdXJsKHB1YmxpY0lkLCBpbWdPcHRpb25zKSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGF0dHIud2lkdGgpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYXR0ci5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbG91ZGluYXJ5X3VwZGF0ZShpbWFnZXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogVXBkYXRlcyB0aGUgZHByIChmb3IgYGRwcl9hdXRvYCkgYW5kIHJlc3BvbnNpdmUgKGZvciBgd19hdXRvYCkgZmllbGRzIGFjY29yZGluZyB0b1xuICAgICogIHRoZSBjdXJyZW50IGNvbnRhaW5lciBzaXplIGFuZCB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvLjxici8+XG4gICAgKiAgPGI+Tm90ZTwvYj46YHdfYXV0b2AgaXMgdXBkYXRlZCBvbmx5IGZvciBpbWFnZXMgbWFya2VkIHdpdGggdGhlIGBjbGQtcmVzcG9uc2l2ZWBcbiAgICAqICAob3Igb3RoZXIgZGVmaW5lZCB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmV9KSBjbGFzcy5cbiAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlXG4gICAgKiBAcGFyYW0geyhBcnJheXxzdHJpbmd8Tm9kZUxpc3QpfSBlbGVtZW50cyAtIFRoZSBIVE1MIGltYWdlIGVsZW1lbnRzIHRvIG1vZGlmeS5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfSBbb3B0aW9ucy5yZXNwb25zaXZlX3VzZV9icmVha3BvaW50cz10cnVlXVxuICAgICogUG9zc2libGUgdmFsdWVzOjxici8+XG4gICAgKiAgLSBgdHJ1ZWA6IEFsd2F5cyB1c2UgYnJlYWtwb2ludHMgZm9yIHdpZHRoLjxici8+XG4gICAgKiAgLSBgcmVzaXplYDogVXNlIGV4YWN0IHdpZHRoIG9uIGZpcnN0IHJlbmRlciBhbmQgYnJlYWtwb2ludHMgb24gcmVzaXplLjxici8+XG4gICAgKiAgLSBgZmFsc2VgOiBBbHdheXMgdXNlIGV4YWN0IHdpZHRoLlxuICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXNwb25zaXZlXSAtIElmIGB0cnVlYCwgZW5hYmxlIHJlc3BvbnNpdmUgb24gYWxsIHNwZWNpZmllZCBlbGVtZW50cy5cbiAgICAqICBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIGRlZmluZSBzcGVjaWZpYyBIVE1MIGVsZW1lbnRzIHRvIG1vZGlmeSBieSBhZGRpbmcgdGhlIGBjbGQtcmVzcG9uc2l2ZWBcbiAgICAqICAob3Igb3RoZXIgY3VzdG9tLWRlZmluZWQge0BsaW5rIENsb3VkaW5hcnkjcmVzcG9uc2l2ZXxyZXNwb25zaXZlX2NsYXNzfSkgY2xhc3MgdG8gdGhvc2UgZWxlbWVudHMuXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc3BvbnNpdmVfcHJlc2VydmVfaGVpZ2h0XSAtIElmIGB0cnVlYCwgb3JpZ2luYWwgY3NzIGhlaWdodCBpcyBwcmVzZXJ2ZWQuXG4gICAgKiAgU2hvdWxkIGJlIHVzZWQgb25seSBpZiB0aGUgdHJhbnNmb3JtYXRpb24gc3VwcG9ydHMgZGlmZmVyZW50IGFzcGVjdCByYXRpb3MuXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3VkaW5hcnlfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3VkaW5hcnlfdXBkYXRlKGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNvbnRhaW5lcldpZHRoLCBkYXRhU3JjLCBtYXRjaCwgcmVmNCwgcmVxdWlyZWRXaWR0aDtcblxuICAgICAgaWYgKGVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3BvbnNpdmUgPSBvcHRpb25zLnJlc3BvbnNpdmUgIT0gbnVsbCA/IG9wdGlvbnMucmVzcG9uc2l2ZSA6IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlJyk7XG4gICAgICBlbGVtZW50cyA9IG5vcm1hbGl6ZVRvQXJyYXkoZWxlbWVudHMpO1xuICAgICAgdmFyIHJlc3BvbnNpdmVDbGFzcztcblxuICAgICAgaWYgKHRoaXMucmVzcG9uc2l2ZUNvbmZpZyAmJiB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9jbGFzcyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNpdmVDbGFzcyA9IHRoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX2NsYXNzO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnJlc3BvbnNpdmVfY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICByZXNwb25zaXZlQ2xhc3MgPSBvcHRpb25zLnJlc3BvbnNpdmVfY2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zaXZlQ2xhc3MgPSB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV9jbGFzcycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm91bmREcHIgPSBvcHRpb25zLnJvdW5kX2RwciAhPSBudWxsID8gb3B0aW9ucy5yb3VuZF9kcHIgOiB0aGlzLmNvbmZpZygncm91bmRfZHByJyk7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgaWYgKC9pbWcvaS50ZXN0KHRhZy50YWdOYW1lKSkge1xuICAgICAgICAgIHZhciBzZXRVcmwgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgIGxvZGFzaF9hZGRDbGFzcyh0YWcsIHJlc3BvbnNpdmVDbGFzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YVNyYyA9IGxvZGFzaF9nZXREYXRhKHRhZywgJ3NyYy1jYWNoZScpIHx8IGxvZGFzaF9nZXREYXRhKHRhZywgJ3NyYycpO1xuXG4gICAgICAgICAgaWYgKCFpc0VtcHR5KGRhdGFTcmMpKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZHByIGFjY29yZGluZyB0byB0aGUgZGV2aWNlJ3MgZGV2aWNlUGl4ZWxSYXRpb1xuICAgICAgICAgICAgZGF0YVNyYyA9IHVwZGF0ZURwci5jYWxsKF90aGlzMiwgZGF0YVNyYywgcm91bmREcHIpO1xuXG4gICAgICAgICAgICBpZiAoaHRtbHRhZy5pc1Jlc3BvbnNpdmUodGFnLCByZXNwb25zaXZlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoID0gY2xvdWRpbmFyeV9maW5kQ29udGFpbmVyV2lkdGgodGFnKTtcblxuICAgICAgICAgICAgICBpZiAoY29udGFpbmVyV2lkdGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoL3dfYXV0bzpicmVha3BvaW50cy8udGVzdChkYXRhU3JjKSkge1xuICAgICAgICAgICAgICAgICAgcmVxdWlyZWRXaWR0aCA9IGNsb3VkaW5hcnlfbWF4V2lkdGgoY29udGFpbmVyV2lkdGgsIHRhZyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTcmMgPSBkYXRhU3JjLnJlcGxhY2UoL3dfYXV0bzpicmVha3BvaW50cyhbXzAtOV0qKSg6WzAtOV0rKT8vLCBcIndfYXV0bzpicmVha3BvaW50cyQxOlwiLmNvbmNhdChyZXF1aXJlZFdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRVcmwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWF0Y2ggPSAvd19hdXRvKDooXFxkKykpPy8uZXhlYyhkYXRhU3JjKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkV2lkdGggPSBhcHBseUJyZWFrcG9pbnRzLmNhbGwoX3RoaXMyLCB0YWcsIGNvbnRhaW5lcldpZHRoLCBtYXRjaFsyXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkV2lkdGggPSBjbG91ZGluYXJ5X21heFdpZHRoKHJlcXVpcmVkV2lkdGgsIHRhZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhU3JjID0gZGF0YVNyYy5yZXBsYWNlKC93X2F1dG9bXixcXC9dKi9nLCBcIndfXCIuY29uY2F0KHJlcXVpcmVkV2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRVcmwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUodGFnLCAnd2lkdGgnKTtcblxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5yZXNwb25zaXZlX3ByZXNlcnZlX2hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgbG9kYXNoX3JlbW92ZUF0dHJpYnV0ZSh0YWcsICdoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udGFpbmVyIGRvZXNuJ3Qga25vdyB0aGUgc2l6ZSB5ZXQgLSB1c3VhbGx5IGJlY2F1c2UgdGhlIGltYWdlIGlzIGhpZGRlbiBvciBvdXRzaWRlIHRoZSBET00uXG4gICAgICAgICAgICAgICAgc2V0VXJsID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzTGF6eUxvYWRpbmcgPSBvcHRpb25zLmxvYWRpbmcgPT09ICdsYXp5JyAmJiAhX3RoaXMyLmlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSAmJiBfdGhpczIuaXNMYXp5TG9hZFN1cHBvcnRlZCgpICYmICFlbGVtZW50c1swXS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gICAgICAgICAgICBpZiAoc2V0VXJsIHx8IGlzTGF6eUxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgLy8gSWYgZGF0YS13aWR0aCBleGlzdHMsIHNldCB3aWR0aCB0byBiZSBkYXRhLXdpZHRoXG4gICAgICAgICAgICAgIF90aGlzMi5zZXRBdHRyaWJ1dGVJZkV4aXN0cyhlbGVtZW50c1swXSwgJ3dpZHRoJywgJ2RhdGEtd2lkdGgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldFVybCAmJiAhaXNMYXp5TG9hZGluZykge1xuICAgICAgICAgICAgICBsb2Rhc2hfc2V0QXR0cmlidXRlKHRhZywgJ3NyYycsIGRhdGFTcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBlbGVtZW50W3RvQXR0cmlidXRlXSA9IGVsZW1lbnRbZnJvbUF0dHJpYnV0ZV0gaWYgZWxlbWVudFtmcm9tQXR0cmlidXRlXSBpcyBzZXRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB0b0F0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSBmcm9tQXR0cmlidXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRBdHRyaWJ1dGVJZkV4aXN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVJZkV4aXN0cyhlbGVtZW50LCB0b0F0dHJpYnV0ZSwgZnJvbUF0dHJpYnV0ZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoZnJvbUF0dHJpYnV0ZSk7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGxvZGFzaF9zZXRBdHRyaWJ1dGUoZWxlbWVudCwgdG9BdHRyaWJ1dGUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIEludGVyc2VjdGlvbiBPYnNlcnZlciBBUEkgaXMgc3VwcG9ydGVkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0xhenlMb2FkU3VwcG9ydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTGF6eUxvYWRTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gd2luZG93ICYmICdJbnRlcnNlY3Rpb25PYnNlcnZlcicgaW4gd2luZG93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdXNpbmcgQ2hyb21lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gJ2xvYWRpbmcnIGluIEhUTUxJbWFnZUVsZW1lbnQucHJvdG90eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBvYmplY3QsIGluaXRpYWxpemVkIHdpdGggdGhlIHNwZWNpZmllZCBvcHRpb25zLCBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHJhbnNmb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBvcHRpb25zIHRvIGFwcGx5LlxuICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybWF0aW9ufVxuICAgICAqIEBzZWUgVHJhbnNmb3JtYXRpb25cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtYXRpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHNyY190cmFuc2Zvcm1hdGlvbltcIm5ld1wiXSh0aGlzLmNvbmZpZygpKS5mcm9tT3B0aW9ucyhvcHRpb25zKS5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHdpbGwgYXBwZW5kIGEgVHJhbnNwYXJlbnRWaWRlbyBlbGVtZW50IHRvIHRoZSBodG1sRWxDb250YWluZXIgcGFzc2VkIHRvIGl0LlxuICAgICAqICAgICAgICAgICAgICBUcmFuc3BhcmVudFZpZGVvIGNhbiBlaXRoZXIgYmUgYW4gSFRNTCBWaWRlbyB0YWcsIG9yIGFuIEhUTUwgQ2FudmFzIFRhZy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sRWxDb250YWluZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUge0BsaW5rIFRyYW5zcGFyZW50VmlkZW9PcHRpb25zfSBvcHRpb25zIHRvIGFwcGx5IC0gRXh0ZW5kcyBUcmFuc2Zvcm1hdGlvbk9wdGlvbnNcbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9ucy5wbGF5c2lubGluZSAgICAtIEhUTUwgVmlkZW8gVGFnJ3MgbmF0aXZlIHBsYXlzaW5saW5lIC0gcGFzc2VkIHRvIHZpZGVvIGVsZW1lbnQuXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnMucG9zdGVyICAgICAgICAgLSBIVE1MIFZpZGVvIFRhZydzIG5hdGl2ZSBwb3N0ZXIgLSBwYXNzZWQgdG8gdmlkZW8gZWxlbWVudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb29wICAgICAgICAgICAtIEhUTUwgVmlkZW8gVGFnJ3MgbmF0aXZlIGxvb3AgLSBwYXNzZWQgdG8gdmlkZW8gZWxlbWVudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9ucz8uZXh0ZXJuYWxMaWJyYXJpZXMgPSB7IFtrZXk6IHN0cmluZ106IHN0cmluZ30gLSBtYXAgb2YgZXh0ZXJuYWwgbGlicmFyaWVzIHRvIGJlIGxvYWRlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8SFRNTEVsZW1lbnQgfCB7c3RhdHVzOnN0cmluZywgbWVzc2FnZTpzdHJpbmd9Pn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluamVjdFRyYW5zcGFyZW50VmlkZW9FbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluamVjdFRyYW5zcGFyZW50VmlkZW9FbGVtZW50KGh0bWxFbENvbnRhaW5lciwgcHVibGljSWQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIWh0bWxFbENvbnRhaW5lcikge1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0aW5nIGh0bWxFbENvbnRhaW5lciB0byBiZSBIVE1MRWxlbWVudCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zcGFyZW50VmlkZW9fZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB2aWRlb1VSTCA9IF90aGlzMy52aWRlb191cmwocHVibGljSWQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRyYW5zcGFyZW50VmlkZW9fY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5KCkudGhlbihmdW5jdGlvbiAoaXNOYXRpdmVseVRyYW5zcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG1vdW50UHJvbWlzZTtcblxuICAgICAgICAgIGlmIChpc05hdGl2ZWx5VHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgIG1vdW50UHJvbWlzZSA9IHRyYW5zcGFyZW50VmlkZW9fbW91bnRDbG91ZGluYXJ5VmlkZW9UYWcoaHRtbEVsQ29udGFpbmVyLCBfdGhpczMsIHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJlc29sdmUoaHRtbEVsQ29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW91bnRQcm9taXNlID0gdHJhbnNwYXJlbnRWaWRlb19tb3VudFNlZVRocnVDYW52YXNUYWcoaHRtbEVsQ29udGFpbmVyLCB2aWRlb1VSTCwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbW91bnRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShodG1sRWxDb250YWluZXIpO1xuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSBfcmVmLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gX3JlZi5tZXNzYWdlO1xuICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pOyAvLyBjYXRjaCBmb3IgY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5KClcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICB2YXIgc3RhdHVzID0gX3JlZjIuc3RhdHVzLFxuICAgICAgICAgICAgICBtZXNzYWdlID0gX3JlZjIubWVzc2FnZTtcbiAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibmV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbG91ZGluYXJ5O1xufSgpO1xuXG5hc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSwgY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbG91ZGluYXJ5ID0gKGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9uYW1lc3BhY2UvY2xvdWRpbmFyeS1jb3JlLmpzXG4vKipcbiAqIENyZWF0ZXMgdGhlIG5hbWVzcGFjZSBmb3IgQ2xvdWRpbmFyeVxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xvdWRpbmFyeV9jb3JlID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBDbGllbnRIaW50c01ldGFUYWc6IGNsaWVudGhpbnRzbWV0YXRhZyxcbiAgQ2xvdWRpbmFyeTogY2xvdWRpbmFyeSxcbiAgQ29uZGl0aW9uOiBjb25kaXRpb24sXG4gIENvbmZpZ3VyYXRpb246IHNyY19jb25maWd1cmF0aW9uLFxuICBjcmMzMjogc3JjX2NyYzMyLFxuICBFeHByZXNzaW9uOiBleHByZXNzaW9uLFxuICBGZXRjaExheWVyOiBmZXRjaGxheWVyLFxuICBIdG1sVGFnOiBodG1sdGFnLFxuICBJbWFnZVRhZzogaW1hZ2V0YWcsXG4gIExheWVyOiBsYXllcl9sYXllcixcbiAgUGljdHVyZVRhZzogcGljdHVyZXRhZyxcbiAgU3VidGl0bGVzTGF5ZXI6IHN1YnRpdGxlc2xheWVyLFxuICBUZXh0TGF5ZXI6IHRleHRsYXllcixcbiAgVHJhbnNmb3JtYXRpb246IHNyY190cmFuc2Zvcm1hdGlvbixcbiAgdXRmOF9lbmNvZGU6IHNyY191dGY4X2VuY29kZSxcbiAgVXRpbDogbG9kYXNoX25hbWVzcGFjZU9iamVjdCxcbiAgVmlkZW9UYWc6IHZpZGVvdGFnXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvYXNzaWduXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfYXNzaWduX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9jbG9uZURlZXBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jbG9uZURlZXBfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2NvbXBhY3RcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jb21wYWN0X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9kaWZmZXJlbmNlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZGlmZmVyZW5jZV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvZnVuY3Rpb25zXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZnVuY3Rpb25zX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pZGVudGl0eVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lkZW50aXR5X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pbmNsdWRlc1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2luY2x1ZGVzX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc0FycmF5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNFbGVtZW50XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNFbGVtZW50X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc0Z1bmN0aW9uXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNGdW5jdGlvbl9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzUGxhaW5PYmplY3RfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lzU3RyaW5nXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNTdHJpbmdfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL21lcmdlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfbWVyZ2VfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL3RyaW1cIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF90cmltX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG91ZGluYXJ5LWNvcmUuanMubWFwIl0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Fzc2lnbl9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY2xvbmVEZWVwX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jb21wYWN0X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9kaWZmZXJlbmNlX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9mdW5jdGlvbnNfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lkZW50aXR5X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pbmNsdWRlc19fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNFbGVtZW50X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0Z1bmN0aW9uX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1BsYWluT2JqZWN0X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1N0cmluZ19fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfbWVyZ2VfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX3RyaW1fXyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIl9fd2VicGFja19leHBvcnRzX18iLCJjbGllbnRoaW50c21ldGF0YWciLCJjbG91ZGluYXJ5IiwiY29uZGl0aW9uIiwic3JjX2NvbmZpZ3VyYXRpb24iLCJzcmNfY3JjMzIiLCJleHByZXNzaW9uIiwiZmV0Y2hsYXllciIsImh0bWx0YWciLCJpbWFnZXRhZyIsImxheWVyX2xheWVyIiwicGljdHVyZXRhZyIsInN1YnRpdGxlc2xheWVyIiwidGV4dGxheWVyIiwic3JjX3RyYW5zZm9ybWF0aW9uIiwic3JjX3V0ZjhfZW5jb2RlIiwibG9kYXNoX25hbWVzcGFjZU9iamVjdCIsInZpZGVvdGFnIiwiY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCIsIlZFUlNJT04iLCJDRl9TSEFSRURfQ0ROIiwiT0xEX0FLQU1BSV9TSEFSRURfQ0ROIiwiQUtBTUFJX1NIQVJFRF9DRE4iLCJTSEFSRURfQ0ROIiwiREVGQVVMVF9USU1FT1VUX01TIiwiREVGQVVMVF9QT1NURVJfT1BUSU9OUyIsIkRFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTIiwiU0VPX1RZUEVTIiwiREVGQVVMVF9JTUFHRV9QQVJBTVMiLCJERUZBVUxUX1ZJREVPX1BBUkFNUyIsIkRFRkFVTFRfVklERU9fU09VUkNFUyIsIkRFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTIiwiUExBQ0VIT0xERVJfSU1BR0VfTU9ERVMiLCJBQ0NFU1NJQklMSVRZX01PREVTIiwiVVJMX0tFWVMiLCJnZXRTREtBbmFseXRpY3NTaWduYXR1cmUiLCJnZXRBbmFseXRpY3NPcHRpb25zIiwiYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQiLCJhIiwiY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQiLCJjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0IiwiZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfZGVmYXVsdCIsImZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc19kZWZhdWx0IiwiaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0IiwiaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0IiwiaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCIsImlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQiLCJpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQiLCJtZXJnZV9yb290X21lcmdlX2RlZmF1bHQiLCJpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkIiwiaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCIsImRldGVjdEludGVyc2VjdGlvbiIsIm9taXQiLCJiYXNldXRpbF9hbGxTdHJpbmdzIiwid2l0aG91dCIsImlzTnVtYmVyTGlrZSIsInNtYXJ0RXNjYXBlIiwiZGVmYXVsdHMiLCJvYmplY3RQcm90byIsIm9ialRvU3RyaW5nIiwiaXNPYmplY3QiLCJmdW5jVGFnIiwicmVXb3JkcyIsImNhbWVsQ2FzZSIsInNuYWtlQ2FzZSIsImNvbnZlcnRLZXlzIiwid2l0aENhbWVsQ2FzZUtleXMiLCJ3aXRoU25ha2VDYXNlS2V5cyIsImJhc2U2NEVuY29kZSIsImJhc2U2NEVuY29kZVVSTCIsImV4dHJhY3RVcmxQYXJhbXMiLCJwYXRjaEZldGNoRm9ybWF0Iiwib3B0aW9uQ29uc3VtZSIsImlzRW1wdHkiLCJpc0FuZHJvaWQiLCJpc0VkZ2UiLCJpc0Nocm9tZSIsImlzU2FmYXJpIiwiaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQiLCJpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0IiwidHJpbV9yb290X3RyaW1fZGVmYXVsdCIsImxvZGFzaF9nZXREYXRhIiwibG9kYXNoX3NldERhdGEiLCJsb2Rhc2hfZ2V0QXR0cmlidXRlIiwibG9kYXNoX3NldEF0dHJpYnV0ZSIsImxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGVzIiwibG9kYXNoX2hhc0NsYXNzIiwibG9kYXNoX2FkZENsYXNzIiwiZ2V0U3R5bGVzIiwiY3NzRXhwYW5kIiwiZG9tU3R5bGUiLCJjdXJDU1MiLCJjc3NWYWx1ZSIsImF1Z21lbnRXaWR0aE9ySGVpZ2h0IiwiZ2V0V2lkdGhPckhlaWdodCIsImxvZGFzaF93aWR0aCIsInV0ZjhfZW5jb2RlIiwiYXJnU3RyaW5nIiwiYzEiLCJlbmMiLCJlbmQiLCJzdGFydCIsInN0cmluZyIsInN0cmluZ2wiLCJ1dGZ0ZXh0IiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInNsaWNlIiwiY3JjMzIiLCJzdHIiLCJjcmMiLCJpVG9wIiwidGFibGUiLCJ4IiwieSIsInN1YnN0ciIsInN0cmluZ1BhZCIsInRhcmdldExlbmd0aCIsInBhZFN0cmluZyIsInJlcGVhdFN0cmluZ051bVRpbWVzIiwidGltZXMiLCJyZXBlYXRlZFN0cmluZyIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwiY29uc3RydWN0b3IiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsIml0ZXJhdG9yIiwiaXNBcnJheSIsImxlbiIsImFycjIiLCJjaGFycyIsImJhc2U2NE1hcF9udW0iLCJtYXAiLCJmb3JFYWNoIiwiX2NoYXIiLCJiYXNlNjRNYXAiLCJyZXZlcnNlVmVyc2lvbiIsInNlbVZlciIsInNwbGl0IiwiRXJyb3IiLCJyZXZlcnNlIiwic2VnbWVudCIsImpvaW4iLCJlbmNvZGVWZXJzaW9uIiwic3RyUmVzdWx0IiwicGFydHMiLCJwYWRkZWRTdHJpbmdMZW5ndGgiLCJwYWRkZWRSZXZlcnNlZFNlbXZlciIsIm51bSIsInBhcnNlSW50IiwicGFkZGVkQmluYXJ5IiwibWF0Y2giLCJiaXRTdHJpbmciLCJhbmFseXRpY3NPcHRpb25zIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwidHdvUGFydFZlcnNpb24iLCJyZW1vdmVQYXRjaEZyb21TZW12ZXIiLCJ0ZWNoVmVyc2lvbiIsImVuY29kZWRTREtWZXJzaW9uIiwic2RrU2VtdmVyIiwiZW5jb2RlZFRlY2hWZXJzaW9uIiwiZmVhdHVyZUNvZGUiLCJmZWF0dXJlIiwiU0RLQ29kZSIsInNka0NvZGUiLCJhbGdvVmVyc2lvbiIsImNvbmNhdCIsImUiLCJzZW1WZXJTdHIiLCJvcHRpb25zIiwidXJsQW5hbHl0aWNzIiwiYWNjZXNzaWJpbGl0eSIsImxvYWRpbmciLCJyZXNwb25zaXZlIiwicGxhY2Vob2xkZXIiLCJhc3NpZ25fcm9vdF9hc3NpZ25fIiwiY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwXyIsImNvbXBhY3Rfcm9vdF9jb21wYWN0XyIsImRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlXyIsImZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc18iLCJpZGVudGl0eV9yb290X2lkZW50aXR5XyIsImluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfIiwiaXNBcnJheV9yb290X2lzQXJyYXlfIiwiaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfIiwiaXNTdHJpbmdfcm9vdF9pc1N0cmluZ18iLCJtZXJnZV9yb290X21lcmdlXyIsImlzRWxlbWVudF9yb290X2lzRWxlbWVudF8iLCJpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl8iLCJ0cmltX3Jvb3RfdHJpbV8iLCJfdHlwZW9mIiwib2JqIiwid2luZG93IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJIVE1MSW1hZ2VFbGVtZW50IiwiZWwiLCJvbkludGVyc2VjdCIsIm9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiaXNJbnRlcnNlY3RpbmciLCJ1bm9ic2VydmUiLCJ0YXJnZXQiLCJ0aHJlc2hvbGQiLCJvYnNlcnZlIiwiZm9ybWF0IiwicmVzb3VyY2VfdHlwZSIsInRyYW5zZm9ybWF0aW9uIiwidHlwZSIsImZhbGxiYWNrX2NvbnRlbnQiLCJzb3VyY2VfdHJhbnNmb3JtYXRpb24iLCJzb3VyY2VfdHlwZXMiLCJjb2RlY3MiLCJ0cmFuc2Zvcm1hdGlvbnMiLCJ2aWRlb19jb2RlYyIsInNlZVRocnUiLCJlZmZlY3QiLCJxdWFsaXR5IiwiZmV0Y2hfZm9ybWF0Iiwid2lkdGgiLCJhc3BlY3RfcmF0aW8iLCJjcm9wIiwiYmFja2dyb3VuZCIsImhlaWdodCIsImdyYXZpdHkiLCJ2YXJpYWJsZXMiLCJkYXJrbW9kZSIsImJyaWdodG1vZGUiLCJtb25vY2hyb21lIiwiY29sb3JibGluZCIsImJhc2V1dGlsX3R5cGVvZiIsImtleXMiLCJzcmNLZXlzIiwiZmlsdGVyIiwiZmlsdGVyZWQiLCJhbGxTdHJpbmdzIiwibGlzdCIsImV2ZXJ5IiwiYXJyYXkiLCJpdGVtIiwidiIsImlzTmFOIiwicGFyc2VGbG9hdCIsInVuc2FmZSIsInJlcGxhY2UiLCJ0b1VwcGVyQ2FzZSIsImRlc3RpbmF0aW9uIiwiX2xlbiIsInNvdXJjZXMiLCJfa2V5IiwicmVkdWNlIiwiZGVzdCIsInNvdXJjZSIsImlzRnVuY3Rpb24iLCJsb3dlciIsInVwcGVyIiwiUmVnRXhwIiwid29yZHMiLCJ3b3JkIiwiY2hhckF0IiwidG9Mb2NhbGVVcHBlckNhc2UiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImNvbnZlcnRlciIsInJlc3VsdCIsImJ0b2EiLCJCdWZmZXIiLCJpbnB1dCIsInVybCIsImRlY29kZVVSSSIsImVuY29kZVVSSSIsIm9wdGlvbl9uYW1lIiwiZGVmYXVsdF92YWx1ZSIsInNpemUiLCJnZXRVc2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJub2RlQ29udGFpbnMiLCJnZXREYXRhIiwiZWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImdldEF0dHIiLCJkYXRhIiwialF1ZXJ5IiwiZm4iLCJzZXREYXRhIiwic2V0QXR0cmlidXRlIiwic2V0QXR0ciIsImF0dHIiLCJyZW1vdmVBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVzIiwicmVzdWx0cyIsInB1c2giLCJoYXNDbGFzcyIsImNsYXNzTmFtZSIsImFkZENsYXNzIiwiZWxlbSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIm9wZW5lciIsImdldENvbXB1dGVkU3R5bGUiLCJiIiwiYWRvd24iLCJidXAiLCJub2RlVHlwZSIsImRvY3VtZW50RWxlbWVudCIsInBhcmVudE5vZGUiLCJjb250YWlucyIsInN0eWxlIiwiY29tcHV0ZWQiLCJtYXhXaWR0aCIsIm1pbldpZHRoIiwicmV0Iiwicm1hcmdpbiIsImdldFByb3BlcnR5VmFsdWUiLCJybnVtbm9ucHgiLCJjb252ZXJ0Iiwic3R5bGVzIiwidmFsIiwiZXh0cmEiLCJpc0JvcmRlckJveCIsInNpZGUiLCJzaWRlcyIsInBudW0iLCJ2YWx1ZUlzQm9yZGVyQm94Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIkV4cHJlc3Npb24iLCJleHByZXNzaW9uU3RyIiwiZXhwcmVzc2lvbnMiLCJub3JtYWxpemUiLCJzZXJpYWxpemUiLCJnZXRQYXJlbnQiLCJwYXJlbnQiLCJzZXRQYXJlbnQiLCJwcmVkaWNhdGUiLCJvcGVyYXRvciIsIk9QRVJBVE9SUyIsImFuZCIsIm9yIiwidGhlbiIsImFzcGVjdFJhdGlvIiwicGFnZUNvdW50IiwiZmFjZUNvdW50IiwiX3ZhbHVlIiwiX25ldyIsIm9wZXJhdG9ycyIsIm9wZXJhdG9yc1BhdHRlcm4iLCJvcGVyYXRvcnNSZXBsYWNlUkUiLCJwcmVkZWZpbmVkVmFyc1BhdHRlcm4iLCJQUkVERUZJTkVEX1ZBUlMiLCJ1c2VyVmFyaWFibGVQYXR0ZXJuIiwidmFyaWFibGVzUmVwbGFjZVJFIiwidmFyaWFibGUiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0IiwiaW5pdGlhbEFzcGVjdFJhdGlvIiwiY3VycmVudFBhZ2UiLCJ0YWdzIiwicGFnZVgiLCJwYWdlWSIsIkJPVU5EUlkiLCJjb25kaXRpb25fdHlwZW9mIiwiY29uZGl0aW9uX2NsYXNzQ2FsbENoZWNrIiwiY29uZGl0aW9uX2RlZmluZVByb3BlcnRpZXMiLCJjb25kaXRpb25fY3JlYXRlQ2xhc3MiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJfc2V0UHJvdG90eXBlT2YiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJOZXdUYXJnZXQiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXBwbHkiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImdldFByb3RvdHlwZU9mIiwiQ29uZGl0aW9uIiwiX0V4cHJlc3Npb24iLCJfc3VwZXIiLCJjb25kaXRpb25TdHIiLCJkdXJhdGlvbiIsImluaXRpYWxEdXJhdGlvbiIsIl9zbGljZWRUb0FycmF5IiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiY29uZmlndXJhdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJjb25maWd1cmF0aW9uX2FycmF5TGlrZVRvQXJyYXkiLCJfaSIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsIm5leHQiLCJkb25lIiwiZXJyIiwiY29uZmlndXJhdGlvbl9jbGFzc0NhbGxDaGVjayIsImNvbmZpZ3VyYXRpb25fZGVmaW5lUHJvcGVydGllcyIsImNvbmZpZ3VyYXRpb25fY3JlYXRlQ2xhc3MiLCJjb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24iLCJDb25maWd1cmF0aW9uIiwiY29uZmlndXJhdGlvbiIsIkRFRkFVTFRfQ09ORklHVVJBVElPTl9QQVJBTVMiLCJpbml0IiwiZnJvbUVudmlyb25tZW50IiwiZnJvbURvY3VtZW50Iiwic2V0IiwibWVyZ2UiLCJjb25maWciLCJtZXRhX2VsZW1lbnRzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiX3RoaXMiLCJjbG91ZGluYXJ5X3VybCIsInF1ZXJ5IiwidXJpIiwidXJpUmVnZXgiLCJwcm9jZXNzIiwiZW52IiwiQ0xPVURJTkFSWV9VUkwiLCJleGVjIiwiX3ZhbHVlJHNwbGl0IiwiX3ZhbHVlJHNwbGl0MiIsImsiLCJuZXdfY29uZmlnIiwibmV3X3ZhbHVlIiwidG9PcHRpb25zIiwicmVzcG9uc2l2ZV9jbGFzcyIsInJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzIiwicm91bmRfZHByIiwic2VjdXJlIiwibG9jYXRpb24iLCJwcm90b2NvbCIsIkNPTkZJR19QQVJBTVMiLCJsYXllcl9jbGFzc0NhbGxDaGVjayIsImxheWVyX2RlZmluZVByb3BlcnRpZXMiLCJsYXllcl9jcmVhdGVDbGFzcyIsImxheWVyX0xheWVyIiwiTGF5ZXIiLCJyZWYiLCJyZXNvdXJjZVR5cGUiLCJwdWJsaWNJZCIsImdldFB1YmxpY0lkIiwiZ2V0RnVsbFB1YmxpY0lkIiwiY29tcG9uZW50cyIsImNsb25lIiwidGV4dGxheWVyX3R5cGVvZiIsInRleHRsYXllcl9jbGFzc0NhbGxDaGVjayIsInRleHRsYXllcl9kZWZpbmVQcm9wZXJ0aWVzIiwidGV4dGxheWVyX2NyZWF0ZUNsYXNzIiwidGV4dGxheWVyX2luaGVyaXRzIiwidGV4dGxheWVyX3NldFByb3RvdHlwZU9mIiwidGV4dGxheWVyX2NyZWF0ZVN1cGVyIiwidGV4dGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInRleHRsYXllcl9nZXRQcm90b3R5cGVPZiIsInRleHRsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwidGV4dGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInRleHRsYXllcl9UZXh0TGF5ZXIiLCJfTGF5ZXIiLCJUZXh0TGF5ZXIiLCJfcmVzb3VyY2VUeXBlIiwiX3R5cGUiLCJfZm9ybWF0IiwiZm9udEZhbWlseSIsIl9mb250RmFtaWx5IiwiZm9udFNpemUiLCJfZm9udFNpemUiLCJmb250V2VpZ2h0IiwiX2ZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJfZm9udFN0eWxlIiwidGV4dERlY29yYXRpb24iLCJfdGV4dERlY29yYXRpb24iLCJ0ZXh0QWxpZ24iLCJfdGV4dEFsaWduIiwic3Ryb2tlIiwiX3N0cm9rZSIsImxldHRlclNwYWNpbmciLCJfbGV0dGVyU3BhY2luZyIsImxpbmVTcGFjaW5nIiwiX2xpbmVTcGFjaW5nIiwiZm9udEhpbnRpbmciLCJfZm9udEhpbnRpbmciLCJmb250QW50aWFsaWFzaW5nIiwiX2ZvbnRBbnRpYWxpYXNpbmciLCJ0ZXh0IiwiX3RleHQiLCJ0ZXh0U3R5bGUiLCJfdGV4dFN0eWxlIiwiaGFzUHVibGljSWQiLCJoYXNTdHlsZSIsInJlIiwicmVzIiwidGV4dFNvdXJjZSIsInRleHRTdHlsZUlkZW50aWZpZXIiLCJpbmRleCIsInVuc2hpZnQiLCJzdWJ0aXRsZXNsYXllcl90eXBlb2YiLCJzdWJ0aXRsZXNsYXllcl9kZWZpbmVQcm9wZXJ0aWVzIiwic3VidGl0bGVzbGF5ZXJfY3JlYXRlQ2xhc3MiLCJzdWJ0aXRsZXNsYXllcl9jbGFzc0NhbGxDaGVjayIsInN1YnRpdGxlc2xheWVyX2luaGVyaXRzIiwic3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YiLCJzdWJ0aXRsZXNsYXllcl9jcmVhdGVTdXBlciIsInN1YnRpdGxlc2xheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mIiwic3VidGl0bGVzbGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInN1YnRpdGxlc2xheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlN1YnRpdGxlc0xheWVyIiwiX1RleHRMYXllciIsImZldGNobGF5ZXJfdHlwZW9mIiwiZmV0Y2hsYXllcl9jbGFzc0NhbGxDaGVjayIsImZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyIsImZldGNobGF5ZXJfY3JlYXRlQ2xhc3MiLCJmZXRjaGxheWVyX2luaGVyaXRzIiwiZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZiIsImZldGNobGF5ZXJfY3JlYXRlU3VwZXIiLCJmZXRjaGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YiLCJmZXRjaGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJmZXRjaGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsImZldGNobGF5ZXJfRmV0Y2hMYXllciIsIkZldGNoTGF5ZXIiLCJfdXJsIiwicGFyYW1ldGVyc190eXBlb2YiLCJfZ2V0IiwicmVjZWl2ZXIiLCJiYXNlIiwiX3N1cGVyUHJvcEJhc2UiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZiIsInBhcmFtZXRlcnNfaW5oZXJpdHMiLCJwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mIiwicGFyYW1ldGVyc19jcmVhdGVTdXBlciIsInBhcmFtZXRlcnNfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwicGFyYW1ldGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwicGFyYW1ldGVyc19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrIiwicGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzIiwicGFyYW1ldGVyc19jcmVhdGVDbGFzcyIsInBhcmFtZXRlcnNfUGFyYW0iLCJQYXJhbSIsInNob3J0TmFtZSIsIm9yaWdWYWx1ZSIsInZhbGlkIiwibm9ybV9jb2xvciIsImJ1aWxkX2FycmF5IiwiYXJnIiwicHJvY2Vzc192aWRlb19wYXJhbXMiLCJwYXJhbSIsInZpZGVvIiwiY29kZWMiLCJwcm9maWxlIiwibGV2ZWwiLCJiX2ZyYW1lcyIsInBhcmFtZXRlcnNfQXJyYXlQYXJhbSIsIl9QYXJhbSIsIkFycmF5UGFyYW0iLCJzZXAiLCJhcnJheVZhbHVlIiwiZmxhdCIsIl90aGlzMiIsInBhcmFtZXRlcnNfVHJhbnNmb3JtYXRpb25QYXJhbSIsIl9QYXJhbTIiLCJUcmFuc2Zvcm1hdGlvblBhcmFtIiwiX3N1cGVyMiIsIl90aGlzMyIsIl90aGlzNCIsImpvaW5lZCIsIm9yaWdWYWx1ZTEiLCJudW1iZXJfcGF0dGVybiIsIm9mZnNldF9hbnlfcGF0dGVybiIsInBhcmFtZXRlcnNfUmFuZ2VQYXJhbSIsIl9QYXJhbTMiLCJSYW5nZVBhcmFtIiwiX3N1cGVyMyIsIm5vcm1fcmFuZ2VfdmFsdWUiLCJvZmZzZXQiLCJtb2RpZmllciIsInBhcmFtZXRlcnNfUmF3UGFyYW0iLCJfUGFyYW00IiwiUmF3UGFyYW0iLCJfc3VwZXI0IiwicGFyYW1ldGVyc19MYXllclBhcmFtIiwiX1BhcmFtNSIsIkxheWVyUGFyYW0iLCJfc3VwZXI1IiwibGF5ZXJPcHRpb25zIiwibGF5ZXIiLCJwYXJhbWV0ZXJzX0V4cHJlc3Npb25QYXJhbSIsIl9QYXJhbTYiLCJFeHByZXNzaW9uUGFyYW0iLCJfc3VwZXI2IiwidHJhbnNmb3JtYXRpb25fdHlwZW9mIiwidHJhbnNmb3JtYXRpb25faW5oZXJpdHMiLCJ0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZiIsInRyYW5zZm9ybWF0aW9uX2NyZWF0ZVN1cGVyIiwidHJhbnNmb3JtYXRpb25faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwidHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2YiLCJ0cmFuc2Zvcm1hdGlvbl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwidHJhbnNmb3JtYXRpb25fYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwidHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheSIsInRyYW5zZm9ybWF0aW9uX2FycmF5V2l0aEhvbGVzIiwidHJhbnNmb3JtYXRpb25faXRlcmFibGVUb0FycmF5TGltaXQiLCJ0cmFuc2Zvcm1hdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsInRyYW5zZm9ybWF0aW9uX25vbkl0ZXJhYmxlUmVzdCIsInRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkiLCJ0cmFuc2Zvcm1hdGlvbl9jbGFzc0NhbGxDaGVjayIsInRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXMiLCJ0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyIsImFzc2lnbk5vdE51bGwiLCJ0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UiLCJUcmFuc2Zvcm1hdGlvbkJhc2UiLCJ0cmFucyIsIndpdGhDaGFpbiIsIm9wdCIsIm90aGVyT3B0aW9ucyIsImNoYWluZWQiLCJ0ciIsImZyb21PcHRpb25zIiwiYWJiciIsImRlZmF1bHRWYWx1ZSIsInJhd1BhcmFtIiwibGFzdEFyZ0NhbGxiYWNrIiwicmFuZ2VQYXJhbSIsImFycmF5UGFyYW0iLCJ0cmFuc2Zvcm1hdGlvblBhcmFtIiwibGF5ZXJQYXJhbSIsImdldFZhbHVlIiwicmVtb3ZlIiwidGVtcCIsIlZBUl9OQU1FX1JFIiwic29ydCIsInRvUGxhaW5PYmplY3QiLCJoYXNoIiwiY2hhaW4iLCJuYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZXNldFRyYW5zZm9ybWF0aW9ucyIsImZyb21UcmFuc2Zvcm1hdGlvbiIsIm90aGVyIiwiY2FtZWxLZXkiLCJfbGVuMiIsInZhbHVlcyIsIl9rZXkyIiwidHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24iLCJtZXRob2RzIiwiaGFzTGF5ZXIiLCJpZlBhcmFtIiwiaiIsInBhcmFtTGlzdCIsInJlZjEiLCJyZWYyIiwicmVmMyIsInJlZjQiLCJyZXN1bHRBcnJheSIsInRyYW5zZm9ybWF0aW9uTGlzdCIsInRyYW5zZm9ybWF0aW9uU3RyaW5nIiwidmFycyIsInByb2Nlc3NWYXIiLCJsZW4xIiwicGFyYW1fc2VwYXJhdG9yIiwidHJhbnNfc2VwYXJhdG9yIiwidG9IdG1sQXR0cmlidXRlcyIsImF0dHJOYW1lIiwic25ha2VDYXNlS2V5IiwiUEFSQU1fTkFNRVMiLCJ0b0h0bWwiLCJsaXN0TmFtZXMiLCJpc1ZhbGlkUGFyYW1OYW1lIiwiaW5kZXhPZiIsImFyZ3MiLCJjYWxsYmFjayIsInZhckFycmF5IiwiX3ZhckFycmF5JGoiLCJwcm9jZXNzQ3VzdG9tRnVuY3Rpb24iLCJfcmVmIiwiZnVuY3Rpb25fdHlwZSIsIl9UcmFuc2Zvcm1hdGlvbkJhc2UiLCJUcmFuc2Zvcm1hdGlvbiIsImFuZ2xlIiwiYXVkaW9Db2RlYyIsImF1ZGlvRnJlcXVlbmN5IiwiYml0UmF0ZSIsImJvcmRlciIsImNvbG9yIiwiY29sb3JTcGFjZSIsImN1c3RvbUZ1bmN0aW9uIiwiY3VzdG9tUHJlRnVuY3Rpb24iLCJkZWZhdWx0SW1hZ2UiLCJkZWxheSIsImRlbnNpdHkiLCJkcHIiLCJfZWxzZSIsImVuZElmIiwiZW5kT2Zmc2V0IiwiZmFsbGJhY2tDb250ZW50IiwiZmV0Y2hGb3JtYXQiLCJmbGFncyIsImZwcyIsImh0bWxIZWlnaHQiLCJodG1sV2lkdGgiLCJfaWYiLCJpZlZhbCIsInRySWYiLCJ0clJlc3QiLCJrZXlmcmFtZUludGVydmFsIiwib2NyIiwiZW5kX28iLCJzdGFydF9vIiwiX3JlZjIiLCJfcmVmMyIsInN0YXJ0T2Zmc2V0Iiwib3BhY2l0eSIsIm92ZXJsYXkiLCJwYWdlIiwicG9zdGVyIiwicHJlZml4IiwicmFkaXVzIiwicmF3VHJhbnNmb3JtYXRpb24iLCJzb3VyY2VUeXBlcyIsInNvdXJjZVRyYW5zZm9ybWF0aW9uIiwic3RyZWFtaW5nUHJvZmlsZSIsInVuZGVybGF5IiwidmlkZW9Db2RlYyIsInZpZGVvU2FtcGxpbmciLCJ6b29tIiwiaHRtbHRhZ19jbGFzc0NhbGxDaGVjayIsImh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyIsImh0bWx0YWdfY3JlYXRlQ2xhc3MiLCJodG1sdGFnX0h0bWxUYWciLCJIdG1sVGFnIiwiaHRtbEF0dHJzIiwiYXR0cnMiLCJwYWlycyIsImVzY2FwZVF1b3RlcyIsImh0bWx0YWdfdG9BdHRyaWJ1dGUiLCJnZXRPcHRpb25zIiwiZ2V0T3B0aW9uIiwiaHRtbEF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRyIiwiY29udGVudCIsIm9wZW5UYWciLCJ0YWciLCJjbG9zZVRhZyIsInRvRE9NIiwiY3JlYXRlRWxlbWVudCIsImlzUmVzcG9uc2l2ZSIsInJlc3BvbnNpdmVDbGFzcyIsImRhdGFTcmMiLCJfZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic291cmNlS2V5cyIsIm1ha2VVcmwiLCJob3N0IiwicGF0aG5hbWUiLCJpc1VybCIsImNkblN1YmRvbWFpbk51bWJlciIsImhhbmRsZVNpZ25hdHVyZSIsInNpZ25hdHVyZSIsImlzRm9ybWF0dGVkIiwiaGFuZGxlUHJlZml4IiwiY2xvdWRfbmFtZSIsImNkblBhcnQiLCJzdWJkb21haW4iLCJwYXRoIiwicHJpdmF0ZV9jZG4iLCJjZG5fc3ViZG9tYWluIiwic2VjdXJlX2Nkbl9zdWJkb21haW4iLCJzZWN1cmVfZGlzdHJpYnV0aW9uIiwiY25hbWUiLCJoYW5kbGVSZXNvdXJjZVR5cGUiLCJfcmVmJHJlc291cmNlX3R5cGUiLCJfcmVmJHR5cGUiLCJ1cmxfc3VmZml4IiwidXNlX3Jvb3RfcGF0aCIsInNob3J0ZW4iLCJlbmNvZGVQdWJsaWNJZCIsImVuY29kZVVSSUNvbXBvbmVudCIsImZvcm1hdFB1YmxpY0lkIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXJyb3IiLCJ0cnVzdF9wdWJsaWNfaWQiLCJ2YWxpZGF0ZSIsImhhbmRsZVZlcnNpb24iLCJpc0ZvcmNlVmVyc2lvbiIsImZvcmNlX3ZlcnNpb24iLCJpc1ZlcnNpb25FeGlzdCIsInZlcnNpb24iLCJoYW5kbGVUcmFuc2Zvcm1hdGlvbiIsInBsYWNlaG9sZGVyVHJhbnNmb3JtYXRpb25zIiwiYmx1ciIsInByZXBhcmVQdWJsaWNJZCIsInVybFN0cmluZyIsInByZXBhcmVPcHRpb25zIiwidXJsX3VybCIsInJlc3VsdFVybCIsInNka0FuYWx5dGljc1NpZ25hdHVyZSIsImFwcGVuZGVyIiwiYXV0aF90b2tlbiIsIl9hcHBlbmRlciIsImdlbmVyYXRlQnJlYWtwb2ludHNfc2xpY2VkVG9BcnJheSIsImdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlXaXRoSG9sZXMiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiZ2VuZXJhdGVCcmVha3BvaW50c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsImdlbmVyYXRlQnJlYWtwb2ludHNfbm9uSXRlcmFibGVSZXN0IiwiZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5IiwiZ2VuZXJhdGVCcmVha3BvaW50cyIsInNyY3NldCIsImJyZWFrcG9pbnRzIiwiX21hcCIsIm1pbl93aWR0aCIsIm1heF93aWR0aCIsIm1heF9pbWFnZXMiLCJOdW1iZXIiLCJfbWFwMiIsInNvbWUiLCJzdGVwU2l6ZSIsIk1hdGgiLCJjZWlsIiwibWF4IiwiY3VycmVudCIsInNyY3NldFV0aWxzX2lzRW1wdHkiLCJzY2FsZWRVcmwiLCJwdWJsaWNfaWQiLCJjb25maWdQYXJhbXMiLCJyYXdfdHJhbnNmb3JtYXRpb24iLCJnZXRPckdlbmVyYXRlQnJlYWtwb2ludHMiLCJnZW5lcmF0ZVNyY3NldEF0dHJpYnV0ZSIsImdlbmVyYXRlU2l6ZXNBdHRyaWJ1dGUiLCJnZW5lcmF0ZUltYWdlUmVzcG9uc2l2ZUF0dHJpYnV0ZXMiLCJzcmNzZXREYXRhIiwicmVzcG9uc2l2ZUF0dHJpYnV0ZXMiLCJnZW5lcmF0ZVNpemVzIiwic2l6ZXMiLCJnZW5lcmF0ZVNyY3NldCIsInNyY3NldEF0dHIiLCJzaXplc0F0dHIiLCJnZW5lcmF0ZU1lZGlhQXR0ciIsIm1lZGlhUXVlcnkiLCJzcmNzZXRVcmwiLCJpbWFnZXRhZ190eXBlb2YiLCJpbWFnZXRhZ19jbGFzc0NhbGxDaGVjayIsImltYWdldGFnX2RlZmluZVByb3BlcnRpZXMiLCJpbWFnZXRhZ19jcmVhdGVDbGFzcyIsImltYWdldGFnX2dldCIsImltYWdldGFnX3N1cGVyUHJvcEJhc2UiLCJpbWFnZXRhZ19nZXRQcm90b3R5cGVPZiIsImltYWdldGFnX2luaGVyaXRzIiwiaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YiLCJpbWFnZXRhZ19jcmVhdGVTdXBlciIsImltYWdldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImltYWdldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJpbWFnZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJpbWFnZXRhZ19JbWFnZVRhZyIsIl9IdG1sVGFnIiwiSW1hZ2VUYWciLCJzcmNBdHRyaWJ1dGUiLCJzcmNzZXRQYXJhbSIsImNsaWVudF9oaW50cyIsInNvdXJjZXRhZ190eXBlb2YiLCJzb3VyY2V0YWdfY2xhc3NDYWxsQ2hlY2siLCJzb3VyY2V0YWdfZGVmaW5lUHJvcGVydGllcyIsInNvdXJjZXRhZ19jcmVhdGVDbGFzcyIsInNvdXJjZXRhZ19nZXQiLCJzb3VyY2V0YWdfc3VwZXJQcm9wQmFzZSIsInNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZiIsInNvdXJjZXRhZ19pbmhlcml0cyIsInNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZiIsInNvdXJjZXRhZ19jcmVhdGVTdXBlciIsInNvdXJjZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJzb3VyY2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNvdXJjZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzb3VyY2V0YWdfU291cmNlVGFnIiwiU291cmNlVGFnIiwibWVkaWEiLCJzb3VyY2V0YWciLCJwaWN0dXJldGFnX3R5cGVvZiIsInBpY3R1cmV0YWdfY2xhc3NDYWxsQ2hlY2siLCJwaWN0dXJldGFnX2RlZmluZVByb3BlcnRpZXMiLCJwaWN0dXJldGFnX2NyZWF0ZUNsYXNzIiwicGljdHVyZXRhZ19nZXQiLCJwaWN0dXJldGFnX3N1cGVyUHJvcEJhc2UiLCJwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mIiwicGljdHVyZXRhZ19pbmhlcml0cyIsInBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YiLCJwaWN0dXJldGFnX2NyZWF0ZVN1cGVyIiwicGljdHVyZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJwaWN0dXJldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJwaWN0dXJldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInBpY3R1cmV0YWdfUGljdHVyZVRhZyIsIlBpY3R1cmVUYWciLCJ3aWR0aExpc3QiLCJ2aWRlb3RhZ190eXBlb2YiLCJ2aWRlb3RhZ19jbGFzc0NhbGxDaGVjayIsInZpZGVvdGFnX2RlZmluZVByb3BlcnRpZXMiLCJ2aWRlb3RhZ19jcmVhdGVDbGFzcyIsInZpZGVvdGFnX2dldCIsInZpZGVvdGFnX3N1cGVyUHJvcEJhc2UiLCJ2aWRlb3RhZ19nZXRQcm90b3R5cGVPZiIsInZpZGVvdGFnX2luaGVyaXRzIiwidmlkZW90YWdfc2V0UHJvdG90eXBlT2YiLCJ2aWRlb3RhZ19jcmVhdGVTdXBlciIsInZpZGVvdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInZpZGVvdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJ2aWRlb3RhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJWSURFT19UQUdfUEFSQU1TIiwidmlkZW90YWdfREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMiLCJ2aWRlb3RhZ19ERUZBVUxUX1BPU1RFUl9PUFRJT05TIiwidmlkZW90YWdfVmlkZW9UYWciLCJWaWRlb1RhZyIsInNldFNvdXJjZVRyYW5zZm9ybWF0aW9uIiwic2V0U291cmNlVHlwZXMiLCJzZXRQb3N0ZXIiLCJzZXRGYWxsYmFja0NvbnRlbnQiLCJmYWxsYmFjayIsImlubmVyVGFncyIsInNyYyIsImNyZWF0ZVNvdXJjZVRhZyIsInNyY1R5cGUiLCJkZWZhdWx0T3B0aW9ucyIsImhhc1NvdXJjZVRhZ3MiLCJzb3VyY2VUeXBlIiwibWltZVR5cGUiLCJ2aWRlb1R5cGUiLCJjb2RlY3NTdHIiLCJjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mIiwiY2xpZW50aGludHNtZXRhdGFnX2NsYXNzQ2FsbENoZWNrIiwiY2xpZW50aGludHNtZXRhdGFnX2RlZmluZVByb3BlcnRpZXMiLCJjbGllbnRoaW50c21ldGF0YWdfY3JlYXRlQ2xhc3MiLCJjbGllbnRoaW50c21ldGF0YWdfaW5oZXJpdHMiLCJjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2YiLCJjbGllbnRoaW50c21ldGF0YWdfY3JlYXRlU3VwZXIiLCJjbGllbnRoaW50c21ldGF0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mIiwiY2xpZW50aGludHNtZXRhdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJjbGllbnRoaW50c21ldGF0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiY2xpZW50aGludHNtZXRhdGFnX0NsaWVudEhpbnRzTWV0YVRhZyIsIkNsaWVudEhpbnRzTWV0YVRhZyIsIm5vcm1hbGl6ZVRvQXJyYXlfdG9Db25zdW1hYmxlQXJyYXkiLCJub3JtYWxpemVUb0FycmF5X2FycmF5V2l0aG91dEhvbGVzIiwibm9ybWFsaXplVG9BcnJheV9pdGVyYWJsZVRvQXJyYXkiLCJub3JtYWxpemVUb0FycmF5X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9ybWFsaXplVG9BcnJheV9ub25JdGVyYWJsZVNwcmVhZCIsIm5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheSIsIm5vcm1hbGl6ZVRvQXJyYXkiLCJlbGVtZW50cyIsIm1vdW50Q2xvdWRpbmFyeVZpZGVvVGFnIiwiaHRtbEVsQ29udGFpbmVyIiwiY2xJbnN0YW5jZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW5uZXJIVE1MIiwidmlkZW9UYWciLCJjbG91ZGluYXJ5VmlkZW9FbGVtZW50IiwicXVlcnlTZWxlY3RvciIsInRyYW5zcGFyZW50VmlkZW9fbW91bnRDbG91ZGluYXJ5VmlkZW9UYWciLCJhZGRGbGFnVG9PcHRpb25zIiwiZmxhZyIsImFkZEZsYWciLCJlbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8iLCJhdXRvcGxheSIsIm11dGVkIiwiY29udHJvbHMiLCJtYXhfdGltZW91dF9tcyIsImV4dGVybmFsTGlicmFyaWVzIiwidHJhbnNwYXJlbnRWaWRlb19lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8iLCJsb2FkU2NyaXB0Iiwic2NyaXB0VVJMIiwiaXNBbHJlYWR5TG9hZGVkIiwic2NyaXB0VGFnIiwidGltZXJJRCIsInNldFRpbWVvdXQiLCJzdGF0dXMiLCJtZXNzYWdlIiwib25lcnJvciIsImNsZWFyVGltZW91dCIsIm9ubG9hZCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInhocl9sb2FkU2NyaXB0IiwicmVqZWN0T25UaW1lb3V0IiwibWF4VGltZW91dE1TIiwiZ2V0QmxvYkZyb21VUkwiLCJ1cmxUb0xvYWQiLCJmZXRjaEJsb2IiLCJmZXRjaCIsImxvYWRVcmxVc2luZ0ZldGNoIiwibG9hZFVybFVzaW5nWGhyIiwiYmxvYiIsInBheWxvYWQiLCJibG9iVVJMIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicmVzcG9uc2UiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInJlc3BvbnNlVHlwZSIsIm9wZW4iLCJzZW5kIiwieGhyX2dldEJsb2JGcm9tVVJMIiwiY3JlYXRlSGlkZGVuVmlkZW9UYWciLCJ2aWRlb09wdGlvbnMiLCJwbGF5c2lubGluZSIsImxvb3AiLCJ2aWRlb1VSTCIsInZpc2liaWxpdHkiLCJwb3NpdGlvbiIsInJldm9rZU9iamVjdFVSTCIsInRyYW5zcGFyZW50VmlkZW9fY3JlYXRlSGlkZGVuVmlkZW9UYWciLCJpbnN0YW50aWF0ZVNlZVRocnUiLCJ2aWRlb0VsZW1lbnQiLCJjdXN0b21DbGFzcyIsImF1dG9QbGF5IiwiX3dpbmRvdyIsInNlZVRocnVJbnN0YW5jZSIsInJlYWR5IiwiY2FudmFzRWxlbWVudCIsImdldENhbnZhcyIsInBsYXkiLCJ0cmFuc3BhcmVudFZpZGVvX2luc3RhbnRpYXRlU2VlVGhydSIsIm1vdW50U2VlVGhydUNhbnZhc1RhZyIsInRyYW5zcGFyZW50VmlkZW9fbW91bnRTZWVUaHJ1Q2FudmFzVGFnIiwiY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5IiwiY2FuUGxheSIsImNhblBsYXlUeXBlIiwidHJhbnNwYXJlbnRWaWRlb19jaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kiLCJjbG91ZGluYXJ5X2NsYXNzQ2FsbENoZWNrIiwiY2xvdWRpbmFyeV9kZWZpbmVQcm9wZXJ0aWVzIiwiY2xvdWRpbmFyeV9jcmVhdGVDbGFzcyIsImFwcGx5QnJlYWtwb2ludHMiLCJjbG9zZXN0QWJvdmUiLCJkZWZhdWx0QnJlYWtwb2ludHMiLCJjbG91ZGluYXJ5X2ZpbmRDb250YWluZXJXaWR0aCIsImNsb3VkaW5hcnlfbWF4V2lkdGgiLCJ1cGRhdGVEcHIiLCJzdGVwcyIsInJlc2l6aW5nIiwiY2FsY19icmVha3BvaW50IiwiZmluZENvbnRhaW5lcldpZHRoIiwiY29udGFpbmVyV2lkdGgiLCJFbGVtZW50IiwiZGlzcGxheSIsInJvdW5kRHByIiwiZGV2aWNlX3BpeGVsX3JhdGlvIiwicmVxdWlyZWRXaWR0aCIsImltYWdlV2lkdGgiLCJjbG91ZGluYXJ5X0Nsb3VkaW5hcnkiLCJDbG91ZGluYXJ5IiwiZGV2aWNlUGl4ZWxSYXRpb0NhY2hlIiwicmVzcG9uc2l2ZUNvbmZpZyIsInJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCIsIm5ld0NvbmZpZyIsIm5ld1ZhbHVlIiwidmlkZW9fdXJsIiwidmlkZW9fdGh1bWJuYWlsX3VybCIsInRyYW5zZm9ybWF0aW9uX3N0cmluZyIsImltYWdlIiwiaW1nIiwiaW1hZ2VUYWciLCJjbG91ZGluYXJ5X3VwZGF0ZSIsInBpY3R1cmVUYWciLCJzb3VyY2VUYWciLCJ2aWRlb190aHVtYm5haWwiLCJmYWNlYm9va19wcm9maWxlX2ltYWdlIiwidHdpdHRlcl9wcm9maWxlX2ltYWdlIiwidHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2UiLCJncmF2YXRhcl9pbWFnZSIsImZldGNoX2ltYWdlIiwic3ByaXRlX2NzcyIsImJvb3RzdHJhcCIsInJlc3BvbnNpdmVSZXNpemUiLCJ0aW1lb3V0IiwicmVzcG9uc2l2ZV9yZXNpemUiLCJtYWtlUmVzcG9uc2l2ZSIsImRlYm91bmNlIiwicmVzZXQiLCJydW4iLCJ3YWl0Iiwid2FpdEZ1bmMiLCJyZXNwb25zaXZlX2RlYm91bmNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwb2ludCIsImNhbGNfc3RvcHBvaW50IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImRwclN0cmluZyIsInByb2Nlc3NJbWFnZVRhZ3MiLCJub2RlcyIsImltYWdlcyIsIm5vZGUiLCJ0YWdOYW1lIiwiaW1nT3B0aW9ucyIsInNldFVybCIsInJlc3BvbnNpdmVfcHJlc2VydmVfaGVpZ2h0IiwiaXNMYXp5TG9hZGluZyIsImlzTGF6eUxvYWRTdXBwb3J0ZWQiLCJzZXRBdHRyaWJ1dGVJZkV4aXN0cyIsInRvQXR0cmlidXRlIiwiZnJvbUF0dHJpYnV0ZSIsImF0dHJpYnV0ZVZhbHVlIiwiaW5qZWN0VHJhbnNwYXJlbnRWaWRlb0VsZW1lbnQiLCJpc05hdGl2ZWx5VHJhbnNwYXJlbnQiLCJtb3VudFByb21pc2UiLCJjbG91ZGluYXJ5X2NvcmUiLCJVdGlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cloudinary-core/cloudinary-core.js\n");

/***/ })

};
;